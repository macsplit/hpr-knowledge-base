Episode: 3067
Title: HPR3067: Getting my Python3 code working in Python2
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3067/hpr3067.mp3
Transcribed: 2025-10-24 16:08:39

---

This is Haco Public Radio Episode 3,067 for Tuesday 5 May 2020.
Today's show is entitled Getting My Python 3 Code Working in Python 2
and is part of the series A Little Bit of Python. It is hosted by Mr. X
and is about 25 minutes long and carries an explicit flag. The summary is
what I had to do to get my Raspberry Pi per face CAD board working after a
Debian upgrade. This episode of HPR is brought to you by An Honesthost.com
Get 15% discount on all shared hosting with the offer code
HPR15, that's HPR15.
Better web hosting that's Honest and Fair at An Honesthost.com
.
.
.
Hello this is Mr. X and I'll start this episode a little bit differently from usual.
This is an episode I found lying about my hard drive and it actually dates back to 2018.
It was to do with an upgrade that I did to my Raspberry Pi downstairs running Debian
and after it broke something after that upgrade and I wasn't able to load a module,
I had a Python module that I had on PyFace board to work, but you'll find it more about it
when I play the actual thing. But it didn't mean about a sequence because
obviously I've supplied the latest version of my PyFace code with previous episodes
and it has all these things and go up into it. So there we go.
But just to clear that up and it's a bit confuddling and a bit rambly but probably as per usual.
Anyway I hope you enjoy it and you get something out of it.
Normal service will be resumed.
Hello and welcome Hacker Public Radio audience and welcome to this podcast.
I'd like to start by thanking the people at HPR for making this all possible.
It really is an invaluable service on these intertops.
I've gone to a great deal of effort to make it very, very easy to do.
HPR is a community podcast created by the community for the community.
That means you can contribute to just pick up a microphone, hit the record button and off you go.
Use your phone, PC, addictive phone, anything.
It's as simple as that and just post it in.
This episode is like some of my other ones.
It's a bit hard-passed and I haven't really done a great deal of preparation for it.
And it's also kind of out of sequence because it's about an add-on board.
A problem came across as an add-on board to have.
And I was planning to cover the add-on board and the project I've written for it.
And by the time you hear this I may well have covered it.
It depends on whether I am brave enough to publish my terrible Python code.
Anyway, I have a Raspberry Pi model B. It's one of the early ones.
And I bought one of the original Raspberry Pi.
Well, the Pi-Face add-on boards.
It was a Pi-Face CAD Pi-Face command and display, I think that's what it stands for, add-on board.
And I mentioned in one of the podcasts that I haven't published yet.
But you probably have heard that this project is first free and it really works almost like an item you buy off the shelf.
But you know, there wasn't one to put my project complete.
It's almost like a purchase piece of hardware.
I give it so little attention these days, it just works.
At least that was the case until very recently.
And what happened was I came across an email.
Now, an email saying that you should move.
If you're running Debian 7, which is wheezy, you really should upgrade to Debian Jesse, Debian 8.
Because the security is going to be kind of fault by the wayside.
And I thought, well, I know it's getting a bit longer to this distribution.
You know, I really should change it.
So I kind of rushed it to the build by the horns and decided to do that.
And you've got two options.
You can either start from scratch or you can obviously have upgraded the distribution.
And obviously this is Debian running on the Raspberry Pi.
So it's actually Razbian, which is based on Debian.
And they don't recommend you upgrading the recommended fresh install, really.
However, it's relatively straightforward and attempt and upgrade.
And you can find that information online.
If you want to find it, I'm not going to cover that.
It's a quick straightforward.
If it works.
So I recently, so I'm going to be here.
I've recently upgraded the operating system on my Raspberry Pi
from wheezy Debian 7 to Jesse Debian 8.
All seem fine until I try to run my Python 3 project.
It reported that the PiFace CAD module wasn't present.
I tried to install the module using the standard AppGet command,
given the PiFace CAD documentation.
It installed OK for Python 2, but it would not install for Python 3,
as there was a dependency issue with the Python-Lark library.
I'm guessing that would broke something.
So I installed a fresh minimal installation of Razbian Stretch,
there being 9 onto a new SD card,
and on a standard installation command in the PiFace CAD documentation.
It all is installed, but there was a warning about the SPI,
which I forgot to enable.
I enabled this using the last Pi dash config,
you tell, and rebooted the Pi.
So the SPI is an interface that you've got to enable on the PiFace.
So you're going to, I believe, anyway, if you're going to use the SPI-Face CAD,
I don't board.
That's all that was in the standard Raspberry Pi config tool.
I'll just turn that off and on.
So then I decided to test installation by running the sys-info.py example,
as mentioned in the installation documentation that comes with the PiFace CAD board.
I think the example gave a warning saying that the PiFace CAD hardware could not be found.
At this point, I gave up, decided instead to run my project in Python 2.
Of course, at first the code wouldn't run using Python 2,
and I had to do a bit of digging around to find out what was going wrong.
And that's what we're going to get basically covered today.
The changes I had to do to go from Python 3 down to Python 2.
I'm guessing that most people want to go the other way from Python 2 to Python 3.
But I still, I suppose, show the differences that come up going from 2 to 3 or 3 to 2.
I believe there's a tool available to go from Python 2 to Python 3,
or at least to an attempt to take a project from Python 2 to Python 3.
I haven't tried it, and it might break your project.
I don't know. I didn't give a go.
And maybe it's got an option to go from 3 to 2.
Maybe I should have tried it, I don't know.
But anyway, I've got, I've got the two versions of my Python code installed,
opened and meld, M-E-L-D, it's a graphical, diphtool, meld, M-E-L-D.
And it makes it very easy to see where the changes are,
the two versions are side by side, and they scroll together,
and the differences are marked in different colors.
It's a very, very easy way to see where the changes are.
So I'll just very briefly go through the differences.
The first thing I had to do obviously was tell us my Python script,
what Python interpreter it was using.
So it was hash, bang, slash user, slash bin, slash n, space, Python 3.
It's now Python 2, so I just changed that to 2.
Now the other thing that I came across was this common gotcha is that the print command in Python 3 is a function,
whereas I think in Python 2 it's a built-in thing.
So, and I don't fully understand and didn't take the time to really look at the subtleties between it,
but there's differences and options that are available for the function,
which isn't with the built-in.
And you tend to put a quote, sound, an event, a comma,
around the print statement on Python 2 in brackets,
round the curly bracket, no curly bracket, say brackets, you know, just straight brackets,
round the print statement for Python 3.
So, yeah, I could have gone through and fixed all the print statements and whatnot,
but I found out that there's, you can use, you can incorporate the print function into Python 2,
so that all the print functions that were on Python 3 will work on Python 2, if that makes sense.
So, you use the command from space, underscore, underscore, future, underscore, underscore, space, import,
space, print, underscore, function.
And that just allows Python 2, the Python 2 interpreter to use Python 3, the Python 3, the print function.
And that worked well, I seem to be to work OK, so that's a great way of solving all your problems.
That's probably the biggest problem is the way Python 2 and Python 3, the differences are the way they handle the print command.
So, that was the first one.
Next thing I came across was, hmm, Python 3, and again, I don't understand the subtleties of it,
but the module that Python 3 uses is url-lib, I use the url-lib.request module, url-lib,
url-lib, I doctrequest, where is in Python 2, I had to use import and use url-lib 2.
And url-lib, url-lib 2 works a bit differently from url-lib, url-lib.
And again, I don't fully understand it because I didn't have a thing, I just wanted the thing to work,
which is obviously a bad way of doing things, but what I had to do was, I'll cover how I used url-lib differently a bit later on,
because I'm just going down through the code, so that I had to import the url-lib2 module as opposed to using url-lib.request,
so that's quite straightforward.
I have a section here with global variables, and some of these global variables hold commands that are on at various times to do various things,
so I've got a variable called get-ip command, so I obviously get it's IP of the Raspberry Pi,
and I've also got the get- underscored ESS-ID command, and that obviously gets to the Wi-Fi,
and I had to tweak that because the, let me get this right now,
originally I had a user command hostname, space-dashall-ip-address,
and that grabbed the IP address using the hostname command.
But with this version of Debian, you also get your MAC address appended to the end of that.
Now, again, I was lazy, I was in a hurry, and I wanted to fix it.
I wonder if there's a husband, another option where I could just say,
just like dash dash IP address is supposed to all IP address,
I bet there is an option for that, I haven't looked, but it was a difference anyway,
and I picked that into the cut command, used a dash-d-delimitor space,
and then dash f1 to field 1, so it picked up the IP address,
ignored the MAC address on the end, so that solved that.
And then, getting the Wi-Fi ESS-ID, the Wi-Fi name in other words,
originally I used IW-Config command, but with this version of Debian,
IW-Config had changed from slash bin to slash S-bin,
and so the script didn't see it, so I had to put an absolute reference.
So I changed it from just IW-Config to slash S-bin slash IW-Config,
and that solved that problem.
It just obviously moved the location of IW-Config within Debian.
So I've got a function that gets the number of Q's and HPR,
the number of shows and HPRQ, and I used your IW-Config to capture that.
And that originally, I passed it, I passed a variable called text,
but the command I used was urlib.request.url open,
open bracket, the url, close bracket, dot read open bracket,
close bracket, and that read it.
But for Python 2, I had to change that to urlib2.url open,
open bracket url, close bracket, dot read, open bracket,
close bracket.
So there's a different way of accessing the urlib2,
as I say, novice Python programmer,
and I haven't got the time to really look at the subtleties and the differences.
So I'm sure there's plenty of people here screaming at their spot,
I said, oh, I know what the difference is.
It's easy, it's just, well, I'm not going to go into that.
It's just watch out for that one.
If you're using the urlib2.url between 2 and 3, what else?
What else?
I've got a function called, it's actually button 1.
But it basically grabs the gets information about the currently
currently, currently playing podcast or the current track being played by mock,
which is our InCurses music player and it uses the command
mockp space dash i and that basically spews out a whole other stuff about the current
playing track and that gets stored in a variable called mock info and then what I do is
I go through the various light so that variable holds a multi-line list of attributes
about the information so I'll say you know like the file name, the track, whether it's
paused or played or whatever. So for example to get the actual current state of mock I pick
the first line from that list so if I use mock info, open square bracket, close square bracket
0 and that picks a first line from that information in that variable and I pass it to a variable
called mock state so that holds the state you know what state's mock and is it in play, pause or
whatever. I think that mock info might be actually an array, maybe it's an array or something
like that and because I want to print it to to the pie face command and display thing
and it to convert to string so I use the string function, string function, open bracket,
mock state, close bracket and I pass that variable to the variable again mock state so it basically
converts from the value from an array into a string and that's fine and obviously the way
Python 2 and 3 deal the strings, I think there's a bit of a difference there as well
once you do that conversion to string there's additional stuff in here that's generated I think
by Python which I'm not actually sure what it is but it isn't really needed so to crop it I have
to find where there's a colon or this is too complicated, basically Python handles strings
a bit differently between two and three and I think I think I changed I had originally i plus
two colon minus one so it basically finds the colon in the string and then moves two characters
past that colon so it chops it off from there and then it also chops it one back from the end if
that makes sense so it's too past the colon and one before the end if I remember rightly
but after going back to Python 2 I looked at that variable I printed it to the screen to see
what was actually happening because it was going to get an error and there was that minus one
that was chopping a bit off the end of the string was actually chopping stuff off the real
bit of text that was one thing so I just took that off so it went from i plus two colon minus one
to i plus two colon and that was it and that's all it was required to take out that minus one
from a whole pile of these variables because we're all the same they all had minus one on the end
quit that was of a complicated and I bet you don't can't even follow it and I'm explaining it
very badly I used to do a bit more programming in the past but I'd and so even trying to explain
find the right terms you know functions variables all these sort of things and passing values
as I say it's all a bit kind of my bit rusty I think that's probably what I'm trying to see
or a lot of rusty so that strings are different anyway what else changed was there anything else
this might be down to strings again so I had a function or a bit the code which
if I was in a system menu and I pushed a certain button it would shut the pie down and it would
say it would print out shut down at touch and such and that wasn't formatted correctly and again
it was it's down to the way that strings are handled originally had the command string open bracket
shut down time close bracket square bracket two semi colon dash three close bracket and
just hit me colon double dots where you call that and I had to remove that two double dots minus three
and then it printed fine so it's obviously handling the string a bit differently
this is a dreadful explanation I do apologise but at least you'll know what to look out for
strings you're a lib that's one thing um print function another thing uh that's the sort of
things you've got to look out for I'm sure there's a whole list of other things I wasn't anything else
oh yes answer now I've got a an an I think we're um I cut out the program by by hitting Q
so so I've gotten I think while answer is not equal to Q um and I had answer equals
input and then it uh enter Q at any time to quit basically is what I had well um Python three
handles the input differently from Python two and I think it's because um it can't Python two
if it comes across a non um a non a non numeric value then it bombs out so you have to say
I think that's what it's to do with so I think you have to rather than using input you use raw underscore
input for Python two so raw underscore print raw underscore input and your brackets and then
where you go sort of thing um remember reading somewhere about that that might be it I'll just see um
yeah and that that's it that theme that you know the the thing I said at the beginning about
using the from from future input print function thing which allows you to use the print function
there's uh there's uh there's a number of these things these features that you can import from
the future back in time um from Python three to Python two which we'll obviously make um dealing
with um these issues easier if you're going backwards to Python two and that unlikely I went
yours stupid is me anyway uh I think that's enough that that's I really apologise it I
really as always plan to make that a bit a bit more um a bit more coherent but then is it a dive
into it you think oh I didn't prepare and I can't think how to explain this uh I should have
prepared better I'm sure I'll I'll promise we'll do next time so thanks very much for taking
the time to listen to us anyway and I hope you enjoyed it and it wasn't too bad um if you want to
contact me I can be contacted at mrx at hpr at googlemail.com that's mrx at hpr the at symbol google
mail.com so until next time thank you and goodbye
you've been listening to hecka public radio at hecka public radio dot org we are a community podcast
network that releases shows every weekday Monday through Friday today's show like all our shows was
contributed by an hpr listener like yourself if you ever thought of recording a podcast then click
on our contributing to find out how easy it really is hecka public radio was founded by the digital
dog pound and the infonomican computer club and it's part of the binary revolution at binrev.com
if you have comments on today's show please email the host directly leave a comment on the website
or record a follow-up episode yourself unless otherwise stated today's show is released under
creative comments, attribution, share a light 3.0 license
