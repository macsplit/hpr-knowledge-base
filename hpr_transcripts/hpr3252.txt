Episode: 3252
Title: HPR3252: Simple JSON querying tool (also YAML, and to a lesser extent XML)
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3252/hpr3252.mp3
Transcribed: 2025-10-24 19:43:38

---

This is Hacker Public Radio episode 3252 for Tuesday the 19th of January 2021.
Today's show is entitled Simple Case on Queering Tool, also YAML and TOSRX10XML.
It is hosted by CRVS and is about 19 minutes long and can remain an explicit flag.
The summary is CRVS talks about KQ, it can be Q.
This episode of HBR is brought to you by an honest host.com.
Get 15% discount on all shared hosting with the offer code HBR15.
That's HBR15.
Better web hosting that's honest and fair at an honesthost.com.
Hello Hacker Public Radio audience, this is CRVS, coming to you with an episode about Jason.
Jason is a very simple serialization language, much like YAML.
What makes it preferable over YAML is that, well at least for me, I find it preferable over YAML
because it has explicit syntax, meaning there's no guessing about whether we're using a number of spaces
or what's the other thing called taps and there's no weird syntax like requiring a triple-dash
at the beginning of the document, such as Clatu pointed out in his episode about YAML.
Jason instead has a very very explicit syntax type, but it remains an extremely flexible
language for configuration. It is not sort of the be-all-end-all of configuration languages
that would be another episode that someone might want to do on UCL, the Universal Configuration
Language. So Jason has a few nice features, well it has a nice feature that is a completely
flexible language, so it is composed of sort of atomic values and these are either strings or
numbers, and these numbers can be integers or floating points, or also a null, null is also a
valid atomic value, and so a null is just the string null without any decorations, and then numbers
can be placed without any quotes also, so either floating point numbers or integers doesn't matter.
What other than that, everything else needs to be quoted, and that is quoted with double quotes,
not with single quotes. Yes, and that's about it for atomic types, and then you just have
other more complicated types, other composite types really, which are basically dictionaries where
you have a key value pair, where the keys are always strings, so always quoted, and the values
can be anything, and that is either it can be either strings, numbers, so floating point numbers
integers, null, or even lists. The notation for dictionaries is much like the notation for
dictionaries in Python, it's curly brace, and then the key value pairs are given as a key,
so a string with the key, and then a colon followed by the value.
And other than dictionaries, you also have lists, which can have an arbitrary number of elements,
and the elements can be of any type, again like in Python, so the elements can be numbers, strings,
dictionaries, and mixes of these things, it doesn't really matter, it's like it's fully flexible.
You'll see an example in my show notes.
Okay, so that's all that is to the syntax, the syntax only has these elements.
Oh yeah, of course, key value pairs in a dictionary are separated by a comma,
and different elements in a list are separated by a comma, that is it.
One problem that people point out about JSON is that for human configuration,
so configuration that is intended to be used, written, and maintained by humans, it lacks one
major feature, which is the ability to comment. That is where UCL comes in, basically,
why am I even talking about UCL, but okay, basically,
UCL is just a more forgiving version of JSON, maybe sometime. Anyway, moving on,
yeah, so why continue talking about JSON? Why do I like JSON so much?
Well, it's not only does it have a nice configuration, it's like you look at the file and you can
sort of figure out how the thing, how it's actually structured, and you can see all the different
elements of the syntax, and so you're making sure that things are not being hidden from you,
and things are going to be interpreted correctly. You also have this very nice tool for
inspecting your JSON files, which is called JQ, and this should be available from your repositories.
And if it's not in your repositories, you can also get it on GitHub.
I put a link to it in the show description.
Show notes. Yeah, and so the way JQ works is that it allows you to inspect into a dictionary
by using the dot notation, so dot key. So then normal way to have a JSON file is that your first
level is always either a list or a dictionary, most often a dictionary, and then inside you have
different key value, you have different keys with different values associated to them. And so,
for example, if we have a list, if you have at the base level a dictionary where the first element
is called first list, and then it has a list inside, and I want to see the first element of that list,
then I can simply issue JQ, space, and then single column, a single comma, single, not comma,
not column, quote, single quote, dot, and then double quote, first list, close quote, and then
bracket one. So what we do here is like with the dot, we inspect the given key, the value
associated to the given key and the key is first list, so there we go. And then with the bracket
notation, we just simply get the kth element inside, which is the one-th element, in which case it's
the first element of the list, or actually it's the second element, because the lists are zero
indexed. Yeah, and if you want to inquire on a four of your, for example, file, which elements,
which keys does it have, you can simply call the function keys, and that's you do JQ,
single quote, the keys, and that's no quotes, and then you can give it, yeah, and that gives you
the list of keys. If you want to just unravel that list of keys, you can also put empty brackets
in front of it. The language is very versatile, it allows you to compose these things further by using
pipes also inside the language. And yeah, so this makes it, makes it relatively easy to use
Jason for configuring shell up some bash scripts, like if you want, if you decide to make a
bash script and you want to have your configuration be in some standard language, then Jason might be
your friend, and JQ might be the tool for the job of configuring it. Okay, but how does this
then relate to YAML? Well, another tool that you might also be able to find,
well, that you can also find online, and I will put a link to it in the show notes,
is called YQ, and YQ and XQ actually, are both tools that you can find, they're both python
packages, you can install them with PIP, and they have the exact same syntax, and they perform
exactly the same way, and if you give YQ a YAML file, it will output it in Jason, and pretty
printed of course, if you just give it and no command whatsoever, the first thing is what it does
by default is output in Jason. If you query it, if you perform any queries, then it will output
those queries also in Jason, the results of those queries in Jason.
XQ does the same thing for XML, so you can just, so this allows you to sort of have the same syntax
for querying XML, YAML and Jason, and they all output to Jason, I'm pretty sure that with YQ,
you can also output to YAML, but YQ,
yeah, YAML output, yeah, if you pass the minus Y, it will emit output,
and if you can, and if you input with Jason, you can pass it, I think JQ, no.
Yeah, and I think you can also output, yeah, let's, okay, fine, let's try this in place.
Let's go to HPR and JQ, YQ, XQ, and cat, example.json, there's my example file,
and so now if I do JQ, no command, empty command, example.json, there we go, I have my example,
if I instead do YQ, that does exact, okay, so if I feed it to Jason, it will know what to do,
and if I do, yeah, and if I do YQ minus Y, and then I give it the Jason query,
which is an empty query, and just do example.json, it just, it just shows the example in,
and it just shows the example in YAML, and so this way, this way you can get a valid YAML from
a Jason file, and similarly, I guess if I do XQ minus X, that doesn't work, so let's see,
so if I just do XQ, how do I make it output in XML,
components that are pretty printed, I should do, transgo, json output, back into XML in the midget,
hm, hm, okay,
okay,
okay, this way I can see for sure, okay, so it's giving me exactly this,
so if I do YQ minus X, and then example.json, yeah, that outputs it in XML,
why didn't it do for XQ, it do the same for XQ, I don't know, this is very weird,
hm, okay, but anyway, that gives you a quick and easy way to, you know, parse json files,
or YAML files, or XML files, with one single, very simple, query language,
hm, provided your use case is simple, there's more details on the show notes,
if you would like to read those, and with that, that is all, thank you for joining us today on
Hacker Public Radio, and remember to tune in tomorrow for yet another episode, or, you know,
next week, this might come out on Friday, I don't know, but hey, stay safe, and have a nice
day, bye, wait, I'm actually back now, I figured out what was the problem with the XQ,
so XQ is a bit a little bit more finicky, because XML is a little bit more finicky,
it requires having, as a base value, single key value pair, so a dictionary with a single
key value pair, and it requires that the keys don't have spaces in the names, so I was in my
stupidity, I had made the JSON file as illustrative of all the horrible things that you can put into a
JSON file that won't break, and it still won't break, turns out that those things do break the
XML contract, or the XML definition, because the XML file, so because the keys and the key value pairs
in XML files are XML tags, and they are required to have main global tag, so root tag,
and this was not satisfied by the output of YQ minus X, or indeed XQ minus X,
actually, let's try that with, let's try doing that, so I have this, I just copied my example to
a file JSON example 2.json, which I'll open it now, and I removed all the spaces in the keys,
and now I just put a root tag, which is basically, I just have an initial,
the root dictionary has a single key value pair, where the key is in this case file, and the value
is the rest of what used to be the content of the file really, better knowing, but if I now do
XQ example 2.json still doesn't work, minus X still doesn't work, but if I do YQ,
it does work, and it generates everything properly, so yeah, XQ can query the output,
I can query the output of this with, can I query it without YQ? Interestingly enough, YQ
doesn't seem to do well with querying the output of XQ of itself, but XQ does query it properly,
so if you do XQ, and then just pass the command . file, it will get all of the output inputs
that were there before, I hope this will be, I'll try to make this more explicit in the show notes,
once again, thank you all for listening, and have a nice day, bye!
If you ever thought of recording a podcast, then click on our contribute link to find out how easy it really is.
HECCA Public Radio was founded by the digital dog pound and the infonomicon computer club,
and is part of the binary revolution at binrev.com. If you have comments on today's show,
please email the host directly, leave a comment on the website, or record a follow-up episode yourself,
unless otherwise stated. Today's show is released under Creative Commons,
Attribution, ShareLite, 3.0 license.
