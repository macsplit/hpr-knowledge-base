Episode: 1499
Title: HPR1499: How I Got Into Computers
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1499/hpr1499.mp3
Transcribed: 2025-10-18 04:19:08

---


Hello and welcome to Hacker Public Radio. This is Charles from New Jersey and I'm here with
an episode called How I Got Into Computers. I ran into my first computer when I started high school
back in the early 70s. My school had a deck PDP 1120 mini computer with two teletype terminals.
It also in the computer room had a key punch machine, a card-sorter, card reader,
line printer, and the machine itself. Now the terminals that the students could use were
actually the terminal, most of the time, was an ASR Model 33 teletype, which had a paper tape
punch where you could print your program listing and then read it back into the teletype.
Now the PDP 1120 was one of the earlier systems. I think it was installed in 1969 or 70. It didn't
have the processing power or the core memory. And when I say core memory, I mean little magnetic
cores wired point to point by people who were good at knitting. You could actually open a drawer
and see the core memory. So it was literally core. So we were running Ristus 11 version 4A.
We couldn't run anything more recent than that because it didn't have the power, as I said.
We had 16 words of core memory. The machine had a 16-bit word and the cabinet was about
the size of a double-wide kitchen upright refrigerator. The air conditioner was as big as the computer
that was outside and they kept the room quite cold. Now the system itself and the way it interacted
with you was by today's standards very rudimentary. Its idea of a prompt was just the word ready
in all caps. If you didn't have to say anything, they just sat there saying ready and then waited
for you to enter something at the terminal. It may be stating the obvious, but the teletype
terminal does not have a screen. So the print head is the only cursor that you have to let you know
you are. So one of the tricks you could pull on someone is to advance the paper and tear it off.
So people are just sitting there wondering whether they were still logged in after they'd gone.
Yes, we were evil. Now in the show notes, I found pictures of the PDP 1120 on the computer museum
page and retro technology. I found a nice picture of an ASR model 33 with a PDP 11 and I actually
found on the site called the BitSavers.bitSavers.trailingedge.com. Trailing hyphen edge that is. I found
PDF versions of the Ristus 11 system manager's guide, the Ristus 11 system user's guide. I actually
also found the deck basic plus language manual that we used to learn to program. I never thought
anybody was saving that stuff, but I found it when I went online, I searched and didn't take any time
at all to find scanned PDFs of all that stuff. If you wanted to use that computer at all, you were
pretty much forced to learn basic plus, at least at some level, or at least know how to run
programs that were written by someone else. At the first opportunity, I took a course in basic plus
from one of the math teachers in the school, and he wasn't exactly an amazing programmer,
but he was a fabulous teacher. He could explain how to get us going, figure out what kinds of projects
would motivate us and gave us just basic amounts of help, and we learned it on our own. I was in
that class with a friend of mine. His nickname was Ducky. I have no idea why. People called me
Chuck at the time, so we sort of anticipated pairs programming by working on programs together.
We signed our programs Chuck and Duck and our prizes, but we weren't really in business. We were
just having fun doing programs. Now we started really out of necessity because there's only one
terminal, but we ended up getting satisfying results faster than either one of us could have done
on our own. What we would do is surprisingly similar to what the pairs programming advocates
are describing today in methodologies like extreme programming, XP, which is now well over,
gosh, it's well over a decade old. One of us would sit in type code. The other would look over the
the typists shoulder, the drivers shoulder, and see what was being coded and help with debugging
and catch errors and syntax errors, typing errors, misspellings in strings and that kind of thing.
And then we would switch places. And as it turned out, I was fairly good with the design portion,
framing up the conceptual parts of the code that we were about to write. And my friend was very
good at just hammering away code and getting the whole project framed up so that it was executable.
He'd get it so it would sort of do the things that we wanted. He'd get that going fast. And then
we'd spend the rest of the time fixing everything because it wouldn't necessarily work. But that was
close enough. And we got the framing up. We then had some behavior that we could determine
that we could use and determine what it was doing, what we wanted, what we should have wanted,
and how to make those those things all meet by changing the code. We ended up both being able to
write code. And we learned about the benefits of using complementary strengths and skills to get
good work done. Now, I have a couple of resources on pair programming in the show notes,
one from extremeprogramming.org, and one from an academic, a woman named Dr.
Laurie Williams, who has published several studies on pairs programming. Now her other stuff is
really good too. So you should definitely read it and look for Laurie stuff in the show notes.
Okay, now we're working on a small computer with small memory. And we wanted to do things that
were fun, not just boring, you know, print my name until I get sick of it and hit control C.
So I think that having small memory actually led us to be a bit more innovative in what we're
trying to do. I remember one of the programs we were working on was an ASCII art poster program.
And what we did with that one was we would type in text at the terminal and the program would
process that and create a banner on the line printer in block letters based on what we typed.
And we'd have it in very large forms who can make signs and so on. Now if we just had put in data
statements with the characters that we needed to make the ASCII artwork, that probably would have
blown memory on that on that machine if anything else was running. So we developed like a little
mini-language to encode the characters that we wanted to print and the number of them and
then the white space and new lines and so on for each character. It was sort of a compression
algorithm of a kind. We didn't call it that. We called it, you know, either a mini-language or
a bit of encoding or something or a code because we were high school kids. We wouldn't have had the
access to the kind of terminology that the academics used. Now while this was kind of a special
purpose language making air quotes that we used to compress data that we needed, it wouldn't really
call it a domain-specific language which means something quite particular these days. We just
wanted to make cool banners come off the line printer. And if you want to know why our language
wasn't a DSL or domain-specific language I put in a link in the show notes to Martin Fowler's
website which has an article on domain-specific language what it is and what they look like
how they behave. Now he and a co-author have written the book on that. If you stray into other things
that Martin Fowler has written on that site you're probably going to write and thank me that you
were pointed to that material because he's he's just written a lot of really good stuff on IT
and on programming and on getting things done in software engineering. Okay I did eventually graduate
from high school and I did a math major in college. I actually applied to the computer science
program at my college but I switched away after the first year for several reasons to summarize
them I guess I'd say that math had advantages for me as an individual because I had more flexibility
to design my curriculum and study what it was I wanted to study with the people I wanted to study with
and at the times that I wanted to do it. And you know when it comes to myself I'm kind of a
control freak I like to control my environment and so on with other people I sort of let them be.
And I guess another reason that I went with math is that the abstractions that I could see them
studying at that time were just more fun to play with. I didn't really want to get super specific
on the hardware that existed at the time the programming notions that were available and all
that I would use computers to get things done and to have fun for have fun in ways that I wanted to.
Yeah the abstractions that I saw the math people studying just seemed more fun to play with
they had more tools at their disposal they they had a larger set of ideas and relationships
between those ideas than the computer science people did because they were the computer science
people were making up to a large degree what would be the foundations of their discipline at the
time and I was probably a little short-sighted to not get in on the ground floor but I had plenty
of opportunity to play with computers and that's what I really wanted to do. Now while I was in
college I did use computers on jobs as a research assistant a teaching assistant I was a tutor I
typed papers and I used them in my coursework of course because I did some math courses and
science courses that required numerical work and computing made that easy. Now I went into college
with a fairly good handle on basic plus I'd been doing it for oh three and a half almost four
years and when I got there I was thrown in with the other folks into a Fortran course and Fortran
to my mind quite similar to basic except that it was compiled and when I started looking at
the output from the compiler especially the the object listing I realized just how much Fortran
was doing for us and I got to appreciate it however I was advised and I took this advice I was
advised not to think not to try to think in Fortran and that seemed like a good idea to me now
thinking in Fortran is I think it's become something of a it's become something of an insult
but what we meant by that was to so internalize how Fortran does things and how it works that when
we see a problem when we're approaching a problem we know instantly what to do and code can just
come pouring out. I knew that I could work really efficiently if I had done something like that
and train myself in that way but I think I was a little afraid that Fortran would not be around
it would be replaced by the next big thing because the language that I had liked at first basic plus
was replaced by this thing that was new at least to me even though it was an older language
called Fortran it said well how long is it going to be for another language replaces that
so I decided to attack problems from a what I would call a first principles approach
which would give me a more general perspective on things it's it felt a little slower as far
as getting individual jobs done but it seemed like it would be a more reliable way to do things
and more generally applicable it would go beyond programming of course and I think that I found
over time even though I was slower at getting started that I found better solutions by taking
the step back and looking at what was going on in a more abstract framework which admittedly
fits the way I think anyway then I might have then I might have come up with by just following my
nose using the ideas that are are sort of embedded in the design of Fortran. Now when we were learning
this was in the middle of the structured programming craze where the there was a huge controversy
about the go-to statement so I learned Fortran using a kind of a quirky preprocessor for the language
that was meant to encourage structured programming it was called SFK not sure why it was called that
I think it was out of Waterloo but even though I'm not sure and I don't really care enough to
research it I did care enough to put in the show notes a link to a site that's underworldcant.org
that talks about fundamentals of structured programming using Fortran with SFK and want five
so if you want to look it up you'll be able to find a reference and get a nice starting point for it
now in the remainder of college it didn't even take more than a year and a half for another language
to come along and I ended up picking up Pascal and also assembly language for the the new
deck system 2060 which was running the top 20 operating system I learned that that system is
assembly language so that sort of rounded out my programming education now Pascal I learned both
from doing exercises and I learned it from the source which was the the Pascal user manual and
report published by Springer it was written by Kathleen Jensen and Nicholas Wirt so I got that
right from the people who created the language and I put a I put a reference to the actual book
in the show notes just so if you wanted to look this thing up it's probably in a library somewhere
near you and you could see the beautiful type setting that they had I'm being a little facetious
there but it was only about 167 pages because Pascal is kind of a simple language it's a at the time
it was a one-pass compiler so you had to write your code in a certain way so that when you were using
a function or a or a variable that referred to an entity you had to have defined it already so
you learned how to do things from kind of a top-down perspective and lay out lay things out and kind
of a reverse order with the details first and then the general flow at the bottom not unlike the
way one might program in Python in today's world okay I don't want to leave the gear heads out
so here's the gear and software rundown from my college days when I started in college my university
had a 0x or relabeled Honeywell sigma 6 which descended from scientific data systems we had that
for a couple of years and I have the Wikipedia articles that describe the STS sigma series and
the CP5 operating system that was used on it and CP5 is the abbreviation for control program 5
which had just a bunch of applications that that you used to get everything done there was a file
manager and I'm not going to remember the name and then there was there was pickle the peripheral
control language and there were a bunch of different things you can look it up in the in the article
in the show notes for your entertainment and in the last couple of years we had a deck system 2060
which was basically a relabeled PDP 10 I think they called it a deck 2060 because they didn't want to
appear to be selling something that was on some kind of older architecture because the PDP model
number was lower but it was a beefier machine and there's actually an article or a resource that I
found in on the bit savers website that describes that machine and it's operating system let's see
do I also have the think I also have the processor reference I do in the user in the show notes
and I may even have the user guide but there's a couple of articles nonetheless it should be
that should be enough to satisfy your your lust for obsolete computing gear okay after college
I started looking for jobs in what we would call IT now but after being rejected for a number of
those I ended up working in property casualty insurance which would be general insurance or
non-life insurance outside of the US just so they all know what I'm talking about and oddly enough
the end user computing that we had in the actuarial group where I started was actually basic plus
on PDP 11 machines and that wasn't 1120 because we were doing time sharing with the what do we
call it MIS department management information systems had a bunch of PDP 1170s and we had
word processing to do our typing and that was using either deckward which is an application on the
on the PDP 11th or the a similar program that deckward was emulating on the the whips 8 which was a
PDP 8 computer that was a dedicated uses a dedicated word processor now my first very first project
even though I was joining an actuarial department pricing automobile insurance was to build a
database from main from a mainframe data dump that was on you know with some some sort of a common
data source that we used in in in actuarial land now the data was coming from an IBM type mainframe
so the original encoding of the characters was Epsidic and the fields were they were signed so we had
we had an interesting time when we converted the data to ASCII that led that experience led to my
education about signed data fields that especially arise from cobalt programs now I knew hexadecimal
math and I also knew the Epsidic encoding from the from the old sigma six because that used Epsidic
but I hadn't had to convert between Epsidic and ASCII before so it was it's very interesting to get the
to get my first taste of what that was like I used to go up to the 13th floor to the I.O. room and
pick up a nine track tape and hand it to someone else to mount on the on the pdp 1170 where they
would drag the data down for me and then I would have this thing that was technically in ASCII characters
but it had a bunch of fixed length fields and at the end of each numeric field there was what we
were calling overpunch characters which contained both the last digit of the number and the sign of
the entire number and I have a couple of examples in the show notes where I I spell this out and I
actually have a link to some kind of a data conversion site that has a nice article on signed fields
and how to how to decode them so if you ever get this stuff and there are still main frames and
there's probably still stuff coming out in fixed width fields with you know with signs signed data
in them because there's nothing wrong with that format and I'll just briefly tell you what how
this works now when you when you have a signed number field and it's converted to ASCII the last
character in the field is no longer a number now fortunately the encoding is such that it's easy
to make the translation for humans to make the translation for every number but zero and even zero
has a has a way of being translated you can create a rule in your head so you can remember how that
goes but if the field is positive the number will end in one of the letters from a to i now you
won't be surprised perhaps to know that if the field ends in an a then the values final digit
is one and it's positive now b means that the field is positive and it ends with a two
and and c is three and d is four and so on up to i which is nine so if I have a field that looks
like it's let's say it's nine digits long and it's zero zero zero zero three seven five seven d
as in dog or delta well the d tells me the numbers positive and ends in four and since I was
dealing with currency us currency us dollars there was an implied decimal point so that was in
dollars and cents so the value in that field four zeros three seven five seven d was us dollars
plus or positive three seventy five three seventy five dollars and seventy four cents now when
the numbers were negative which they sometimes were for losses or when oh let's say policy
cancellations with return premium happened near the end of a year in a line with a small volume
you might get negative premium because the the transaction that was the offset of the original
payment was in the wrong year so that it didn't match back to that original positive amount to
offset it it just showed up as a negative number and it happened and when you had negative numbers
the field ended not in a through i but in j through r except for zero which I'm going to get to
now if the field ends in j through r the values negative and the numbers the last digits are
mapped the way you think they would be j gets one k gets two and so on up to r which gets nine
so if I have a nine digit field with a an implied decimal point that's gives me dollars and
cents and the value is let's say zero zero zero zero zero two five five r well ends in a nine
it's negative so the value is negative twenty five dollars and fifty nine cents and you will thank
me for laying this out in the show notes and if you don't care about it you'll thank me for
stopping on this topic right here now at this point one of life's little ironies in terms of
my path to becoming eventually Linux user is that our pdp 11s were not running exclusively the
ristus operating system some of them were running a flavor of unix in fact we were pricing
automobile and homeowners insurance in my department but the underwriting manuals and rules pages
that told people the procedure for how to make how to rate the policies you know put go from
the rate pages through the rules looking at all the information and application and coming up
with the final price the premium those documents were created with something called an r off
that was running under unix now there are variants of an r off that are still in use today we can
you probably have one in the package manager if you have a one of the common Linux distros
and what it does is it it's basically an all text format and you just put in formatting codes
to to do a markup on the text to make it formatted the way you want it was one of the earlier
markup languages but it's definitely not in the sgl sgml family now when i came along i was with the
company a few months and the management decided that having only two people who knew how to edit
these documents for the rates and rules manuals was a little restrictive so they decided to convert
all of the rates and rules manuals and they were we operated in all 50 states we had more than one
we usually had about four different automobile programs in each state and at least three or four
homeowners programs which meant that there were as many as 400 manuals that could run 300 pages
in typescript that's a lot of that's a lot of text to have to convert so they ran through a
conversion program to get the text ready to go from an r off in unix to deckward on the ristas
based pdp 11s that they were running and this was about 1982 so in 1982 i was asked to help with a
conversion that was failing when we were trying to move documents away from unix onto a time-sharing
system that may actually have delayed my adoption of linux for a while because i i saw unix as
something that people were moving away from at that early stage now i i did end up using unix in
the form of altrix on yet another deck mini computer back in the i'd say early to mid 90s to
read data tapes when clients sent us data for reinsurance submissions and i would do the
translation from epsidic from the mainframe to ascii which which the dd program helped me to do
all in a one-liner and to put in the line endings and everything and then i would process it
using my os2 machine now eventually i had to move on to windows 95 and windows nt and i used those
for much longer than i wanted to but i'm getting ahead of myself okay um so that was kind of an
adventure and what i did when i was when i was moving the stuff off off unix to deckward was basically
just running someone's you know pre someone's someone else's program conversion program and there
were some codes that were not as commonly used as as the others and there was no conversion routine
so instead of of flagging it and and putting an error message in the log the program crashed
and no one knew what to do no and they certainly didn't want to retype three or four hundred
rate manuals with all of that detail on how to rate things that were governed by the different laws
and the different rates and rules and everything that was different by state as well as the marketing
materials now we we wanted to make sure this this got done one way or another and i came up with
the idea to just well it's tripping over a code that it doesn't know why don't we just
dress the thing up so they can't be recognized as a code and all i did was put a question mark
the the codes were in the form of dot and then two characters to tell the uh and are off what to do
and i just put a question mark between the dot and the code so that would the code would still be
there but it would be ignored by the conversion program and then we could just search for that
pattern of characters and fix all the codes that couldn't be converted and that one little sentence
was all we had to do to get the presses rolling again and it sort of saved the day um i
i can't really say that it was uh something it took me a lot of time i was just coming at the problem
without any preconceived notions about how to solve it i just said well it's looking for a code
it can't look it up in the table because it's not it doesn't know what it is well let's just
have it not look it up then it won't crash sometimes simple ideas are the the wisest and best
okay now i had a dark period that lasted a very long time when i was using first doss which was
actually fun having a personal computer was fun and doss was much better than than the windows
that ran on top of doss in fact i would not use anything before windows 3.1 but i did use
doss and windows for quite a long time uh with a year and a half of of relative calm when i was
running os2 which never crashed on me the only time i had to restart it really was when the power
went off it was very stable but in that period i was able to take advantage of my experience with
Pascal when turbo Pascal came out and that was my that was my favorite program when personal
computers first came out because i was i went away from my first company and i joined a company
that was doing a turnaround and starting a new actuarial department so i had to recreate all the
programs and stuff that we had in my prior engagement that was written in basic and we didn't have
anything that was in a decent basic we had you know the the ones that came with the machines
GW basic or um just plain basic that came with doss and i decided that wasn't really working for me
so i um i looked around and at that time turbo Pascal came out there were some primitive
spreadsheets that frankly sucked so i built all of my pricing exhibits using text file input and
turbo Pascal and it was great and then somebody joined my department who didn't know Pascal and he
knew apl so i rewrote all of the stuff i'd written in turbo Pascal in apl i had to learn it first
and um then we were fine for another few years and in the meantime lotus one two three came out
and i became a spreadsheet guy as well and toward the end of my gig at that second company
we got a new boss for our department and he liked only spreadsheets so we took everything
that we had in apl and we converted it to static spreadsheets and had to do a lot of work by hand
because he didn't like anything that was a program even though he could look at the source code
and know exactly what was happening if you could just read it he didn't want to do that so
we ended up dumbing everything down to spreadsheets let's see other just hitting the high spots i
i ran on something called pick the pick system and pick basic which was kind of fun with those
multi-valued fields that it had um i used quick basic for data grubbing for a while because
i had to share my data grubbing programs with others when i started working in re-insurance so
i just used basic again uh i moved on to visual basic and then as soon as the lotus one two three
went into the windows version and excel changed from its macro language to visual basic with
applications i switched to excel and really didn't look back for spreadsheets um at work that's
what i have to use at home i like something a little more how should we say open source so i end
up using a new maryk or uh open office calc something like that i can still program these things
and do whatever i need to do but at work it's excel and vba and nothing else now in dealing with data
course and automation and things which i do on my job i learned a number of uh sql dialects i
played around with automation with calm and dotnet and learned a few scripting languages over time
and i still um i still i i still like to learn languages that i can uh like and work with to get
things done efficiently and take advantage of of uh their unique abilities to uh to take care
of certain jobs you know efficiently and take care of you know take advantage of their strengths
and code around their weaknesses of course um i used uh i used a unix system and i read up on unix
during the uh during the nineties because we were using a unix system at the office i wanted to
be able to um understand what we what we were dealing with and how i could use it to my advantage
let's see now fast forwarding a lot because i don't think you need to know about my time as a windows
developer which i still still am sort of um windows plat i'm developed applications on a windows
platform come on let's not exaggerate my importance here but i finally did give linux a try
partly because my my brother and lost started using debian to be able to run some of his
programs to build cool circuits i guess he did it on his job but this is mainly for home he would
program uh various microprocessors you know write write code on uh on debian and then burn it on
to his uh his chips with a programmer but also because i had friends who were playing around with
the buntu and and um and other linux distros so i gave linux a try um i guess my start with with
linux was the same as mr. gadgets started with a flavor of nopics because that was the earliest
form of a live cd that you could get now you can get a live cd for just about any distro
but i gave um linux a try using quantian which was a uh and this is back in the latter part of
2006 and i have a couple of links in the show notes to the quantian uh the quantian website
that describes what was in it it had just about every math and science and electronics and
educational and game thing that i would ever want to use and it would run on anything you know
the the nopics stuff would just detect the hardware figure out what it had to do and just run
and i could save my data on a usb thumb drive and it was great so i used nopics for a while just to
try out all of the uh all the packages that i could find you know i knew are from um
its windows incarnations and i got to play around with um with with basically debian without having
to do a full install or or uh dedicate one of my extra machines to that so i tried numeric and
python and r and the educational software and of course tux racer and eventually i wiped my vista
laptop that i was using for a consulting job in april of 2008 and just installed ubuntu full time
i think we were on i think when i installed it it was at that point probably it was probably hearty
so that was the place where i came in um now i was doing a few things with my windows pc's at home
you know music and um i guess eventually podcasts and stuff and and my checking account and
maybe some photo editing stuff i was doing that really kept me from switching my other pc's to
linux full time so i kept you know i kept booting quarantined to try things and then going back to
windows when i had to do any of these other jobs um something that helped me along the way to accelerate
the process was um woobie that would be whiskey uniform bravo india and that was in a buntu
installer that let me run ubuntu as if it were an application on windows and just had a primitive
boot manager that let me choose whether i wanted to boot up a buntu or windows xp on my computer
so that was cool because it let me try ubuntu full time on a disk install that was fairly fast
without having to set up an actual dual dual boot or use the live cd now it was really easy to install
it and remove it it was just like a windows app i could just go to the to the control panel and
remove it if i wanted it to be gone there was no virtualization setup no virtual box or VMware
any of that sort of thing um i could just install it run it and when i'm running on the Linux side
i could actually see and use the files on my windows partition as if i were in windows so it was
pretty cool i did it at about the right time i guess um now i switched my main home desktop
which was which i call racing cow and ironic name it was a very old gateway computer and i did
that in april of 2011 and that went full time to Linux now i was running a buntu at the time
and at that point i struggled a little bit longer with um trying to make my itunes stuff
sync with my ipod and finally i went to a website and got a sansa clipzip music player which i'm
using to record this for lack of anything better hope i can outlast this water this running
okay it's going to keep going so i'm going to keep going okay i used a buntu and it worked
all right for me but when i finally got the um got the nerve to convert to it full time i just
threw out the ipod i was using and switched to a player that could handle um syncing to my computer
using either our sync or just you know file copy you know moving things over using the file
manager and that's worked fine for me ever since now i was one of those people who liked
gnome 2 and i was very unhappy when unity hit in uh one in one of the uh 2011 releases of
of a buntu and gnome 3 looked like it was coming and that i was going to have to probably find
some other way to do my computing because my computer just didn't have the the graphics processing
power or the raw processing power total to run the the compositor and window manager that was used
in the uh the newer desktops so at that point i decided well i know i can get along with the
the uh Ubuntu classic desktop that they introduced when unity came around but i wasn't going to be
able to stay with it forever and i had an idea to suggest that you know there'd be a fork uh of
the gnome desktop which turned into the mante or mate project and i don't really have an opinion
on that so i'm not going to go there but i can say that at the time my my tastes and my older
machines led me to go distro hopping now i tried a few things i tried lighter weight distributions i
think i tried antics uh mapus i tried which wasn't light um i tried a number of things and finally
i was listening to the linux outlaws and dan lynch mentioned that he was running crunch bang
so i decided to try that and i've been running it ever since on basically all my machines except
the one that my wife wants to use which i i think i loaded with linux mint because it was uh had
more minty freshness let's see what other things that i run during my uh my pilgrimage from
Ubuntu to crunch bang well i at one point decided i would try to make the linux distro that i wanted
so i started playing with gentoo that was in june of the year that i switched racing cow over
the gentoo website is listed in the show notes now i can tell you that it it was not a straight forward
put the disk in and you're done kind of install but i think gentoo gets a or fun to now or you know
whichever you prefer and i'm not jumping on that hand grenade either it's just neither one is
really as super hard as you might have been told that they are and you learn a lot when you try
to um put them on your system now i installed gentoo very systematically i had read the documents
over several days on the on my train trips to work so i really had it planned out and i installed it
in three four hour sessions over a few nights and it turned out it was a good idea that i'd read
the documents because i sort of knew what to do as i got to each stage um when i compiled the kernel
it worked and actually booted on the first shot so maybe i was lucky uh i was able to add modules
for devices that i liked and that recompile worked i even got x working well enough to use a browser
and a window manager um but i did eventually have to give up on on gentoo not because it was too
hard to keep up with it but i hadn't really i had to give up because i hadn't decided on my own
workflows what i was going to do how i liked to do it and what software i wanted to use so the
problem really was between the keyboard and the chair in this case now at that point i didn't know
enough about the the difference differences uh between applications that had dependencies on gtk
or cute or um maybe the kde uh packages i didn't know if i could mix them or run them together
or whether that would load huge amounts of stuff on my system and i was really unsure about
my ability to reverse wrong choices given that it took several days to put several days to put
the system on and i guess the unfamiliar toolkits and um system admin tools was a little bit intimidating
to me but i must say i never really had any problems with gentoo it worked it worked uh as advertised
and it ran well enough on my system i just didn't have my own stuff together well enough to keep
running it i wanted a little bit more guidance and experience with linux and what was available and
how it worked together before i would go back to something like that now i also tried slackware
and i tried it several times and i must say that slackware gets a bad rap you know it's being hard
to use somehow and again my problem was always between again you know between the keyboard and chair
because slackware i i i i must admit i start with the huge kernel so it always installs for me on
the first try and i have really old gear but once again you know knowing what to do after that
initial install was really my problem now to get over my fear of the unknown i installed the uh
13.37 release and i updated all of the patches after the initial install by hand
i learned the i learned the package manager you know i did the manual updates after the install i
think it took me two hours and that's including learning how to use package tool now i did have
some problems using generic or custom kernels but i only had these problems when i was well
being stupid i was operating with the uh by the seat of my pants and i hadn't really um
done enough homework to uh to do it right if i had studied up the way i did when i installed gen2
i probably wouldn't have had any problems at all with slackware now the the deal with with
compiling a kernel in any context um if you don't want to have problems you should really be sure
that the drivers modules you need to operate your boot disk are compiled in and if you wanted
display you should make sure that supported as well uh i guess enough said right there um another
thing i learned from playing with slackware is that after i had used and hated the older versions of
it i must say i really like kde4 and i didn't expect that because i did not like kde3 i
believe i uh i once called it the lead weight package for for linux you know if you're getting
mileage that's just too good put kde3 on there and it'll bring you back down to where you want to be
having your computer run just as slow as windows but um i guess either i'm better at uh at doing
the customizations and tweaking the settings or kde4 is just a lot better than kde3 for my
style of usage either way i'm liking it a lot better these days so uh good on you kde developers
um i guess while i'm on the topic of slackware i found a resource that that concerns slackware
and how to use it and it's the slacker media book which is a uh slacker slackware based uh linux
from scratch kind of approach it doesn't come with an install disc it is a book that tells you
step by step not only how to install and run and administer your slackware system but how to think
about designing a workstation that fits you now slackware is already the kind of system that's very
kind of unixy and all of the config files can be with some exceptions can be looked at and
filled in by hand if you follow the instructions you can understand what your system is doing
so slackware in general is a is in a it's not just a linux distro it is an approach to running Linux
that lets your computer be truly your computer now slacker media helps you to go back to those
first principles that i was talking about earlier and decide okay i want to use this computer
to do these certain things in the case of slacker media was doing some kind of multimedia
communication now that could include writing which it does uh audio and it does that video which
it covers quite nicely uh web design one could argue programming documentation whatever you want
to use it there are combinations of applications that will fit what you want to do now slackware the
full install comes also comes with a a dialect of tech which lets you use it for math documents and
science documents um because it does typesetting them all the symbols tables page formats and
other things that you would need to create really attractive readable and standards compliant
documents it's uh it's actually quite nice it comes with the system now i got the idea when i was
looking at the the basis of slacker media the technical basis which is to start with a full install
slackware and then as you're adding the applications that you want to use and and installing them in
order so that all their dependencies are satisfied um you can control how those things are compiled
and when they're updated thank you very much so that your stuff doesn't get clobbered you can
use slack build and to order the slack build to run them in the order that you want you can use
slack build cues and putting those two things together if you line them up and put them in a place
where you can find them you could actually set up your slackware machine as a repeatable configuration
so that if you wiped it tomorrow you can install do a full install of slackware add a few tools put
your cues on there run them and everything is back to the way that you want it in terms of the
applications you might have to make some tweaks here and there but very cool that you can you know
cut a lot of time and guesswork out of setting up your computer the way you want it i got the idea to
use this for groups of people who are working on math software in progress for one thing the
slackware package format is pretty simple and easy to grasp at least when you're making binaries
so it's easy to share those or to share the source project through slack builds because it's just
the script that tells how to how to configure and build and install your applications or your new
program so it's it's kind of a universal format the slack build is for communicating shared program
source that you're using for a program that's in progress and actually you could use it when
you're done but why get into creating packages for debian or for you know rpms or
or whatever other package formats you would want if the program's not finished so if you're
working on it at this kind of unfinished broken half done half baked stage why not use a simple
package format and an extremely portable format for sharing the source which you're going to
you're going to have to compile anyway so it seemed like a great way to build a math workstation
that wouldn't get screwed with by an over zealous software update that clubbers some dependencies you
need by installing a very helpful software update now why did i look at slackware for this well for
one thing it comes with tech for math writing but it also had there are so there are some slack
builds grips that i saw for sage and some other projects that i like so a lot of the things i like
are there and slacker media has cues already created for audio video web editing and publishing
and no matter what field you're in especially in math and related things you have to communicate
so why not choose from more than just writing things in text or in tech why not have some have
support for multimedia when you want to use it it's great so the idea for slacker math was born and
still kind of rattling around in my head um i haven't really had time to flesh it out partly because
i have a three year old grandson and partly because i've been trying to put together my podcast
episodes the recreational math stuff the practical math and stuff on on the understanding units of
measure and how to convert between them and all that that's coming up so it's still in a kind of
an amorphous state the idea is out there so if you want to get going go to it the stuff is all
out there for free on slackermedia.info now you can uh what in my vision the slacker math would be
just like the slackermedia the idea you know you take take slackware the full install you
use slack builds and slack slack build cues to to set things up exactly as you want get together some
some packages that you like and that get work done for you including of course tux racer for the
child and me and then put whatever support for programming languages and compiling and whatever
that you like so slacker math it's out there um okay like i guess i'll go back to where we are now
i'm a linux user and we had let's see when i first started toying with linux we had six windows
computers in our house now five of those have all converted to linux one of them retired with
crunch bang as its final operating system it was surfing cow it was an even older gateway desktop
that just couldn't get out of its way anymore and its disk started to go and its memory was old
and its motherboard battery couldn't be replaced so we uh finally decommissioned it uh my original
ubuntu laptop which i called titanic because it weighed a ton was huge um actually that name was
tempting fate because it died after a baptism in red wine um i guess my grandson thought it was thirsty
he saw he poured um a very large amount of red wine over the keyboard i must say that that
machine is back to life has a new keyboard a new disk and a new name um thanks to tom
from going linux the that laptop which was once known as titanic is now called phoenix no
it's called lazarus phoenix was the other name tom suggested lazarus is a name that indicates
that it's back from the dead now machine number six is about to go over to uh linux with some
kind of graphical desktop i i'm pretty sure that my wife is going to want to put uh linux men
ton it uh in any case it needs kind of a granny distro because it's probably going to be used
by you know people who visit anyone who needs a computer at our house um because it's lightweight
it doesn't have a lot of power but it doesn't need it because people are just going to be checking
email and surfing the web on it so you know a nice light lightweight but somewhat graphical uh
granny distro would probably be fine well that's uh that's my story how i got started with computers
all the way up to linux and where i am today um so that's it and we're going back to the math after
this i'm going to be doing a a series on practical math topics and starting with units of distance
and area english units as bizarre as they are and metric units and maybe even converting between
the two i know that's something that's old hat for folks in some countries who've been using
the metric system for a long time in the states we are taught the metric system in school and chemistry
class and we forget it along with the rest of chemistry and go back to using the english system
so i'm going to try to knock some some rust off the memories of some of our us listeners and um
hopefully people in other parts of the world will get some sort of benefit out of this as well
trying to give people a a way to feel comfortable converting between units without worrying about oh
should i divide or multiply is there an offset is there something i wasn't thinking about oh maybe
i'll just go to wolf from af will from alpha or the units program on my uh on on bash in my terminal
and if you want to look up units of course you could just do that and there's actually a linux in
the shell episode on that i think it's number 26 but i'll probably get that wrong all right so
i'll see you next time and i'm looking forward to hearing i'm looking forward to hearing your show
on hacker public radio thanks for listening
you have been listening to hacker public radio at hacker public radio does our
we are a community podcast network that releases shows every weekday on day through friday
today's show like all our shows was contributed by a hbr listener like yourself
if you ever consider recording a podcast then visit our website to find out how easy it really is
hacker public radio was founded by the digital dog pound and the infonomicum computer club
hbr is funded by the binary revolution at binref.com all binref projects are proudly sponsored by
luna pages from shared hosting to custom private clouds go to luna pages.com for all your hosting
needs unless otherwise stasis today's show is released under a creative comments
attribution share a life lead us our license
