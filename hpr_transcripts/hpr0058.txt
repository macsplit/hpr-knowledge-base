Episode: 58
Title: HPR0058: Microcontrollers
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0058/hpr0058.mp3
Transcribed: 2025-10-07 10:52:22

---

.
Hi everybody, this is BitViper and I'm here to talk to you today about something a little different than just pure Linux, even though that's a good stuff.
I'm here to talk about something interesting on the hardware side that could really help you out.
For example, if you've ever wanted to hack around with hardware and maybe make an alarm, sorry, clock, alarm clock or talk to an LCD screen or make your own MP3 player or robot or something like that, you really have been limited kind of to with just using a computer to get that done.
That's kind of lame because the computer is expensive, big, power-hungry and all that, so I wanted to be nice.
If there was a cheap version of the computer that you can program, that can do everything you need it to do to make the clock or the BitViper player or whatever project you want to make.
So, it turns out to be such a device and that's called a microcontroller.
So, microcontroller is the best way to explain it is what it is and that's a micro-processor by itself.
Everyone knows a penny or something doesn't do much by itself. You have to give it RAM, you have to give it a hard drive or a floppy disk or something to put off of.
You have to give it a USB chip or something or a network chip or whatever.
You have to keep surrounding it with different components until you get what you need, which is good because that gives you the freedom to actually choose what you want.
And indeed, electrical engineers, when they make little embedded devices like WRT 54G or anything else that uses some sort of computer inside, they generally will use a micro-processor that does exactly what they want, the speed and has the features they need.
And then they'll buy exactly the memory they need, speed and size as well and so forth.
So, you can really dial in exactly what you want your system to do and only pay for what you use.
That's well and good for, you know, if you got the abilities to do that. However, me, I'm actually a mechanical engineer, so I know a little bit of electrical but not a lot.
So, I sure could use all the help I could get. So, that's why microcontrollers are so nice because what a microcontroller is.
It's a chip that has a micro-processor inside, but it also has a lot of the other things that you need to make it a full running system.
Like, you know, flash memory for the program to be stored on. Maybe some e-proms, like a little mini hard drive kind of thing.
Even things like input output pins, which you can use to either sense or control things with, you know, and tons of other things.
So, what's nice is that you can find the microcontrollers all kinds and you can find one that has the speed and the resources and features you need.
And instead of costing as much as a computer or all the other separate components like the electrical engineer would use, it's cost like a couple bucks.
Maybe as much as $10 if you get like a super mega powerful one with tons of pins and RAM and flash and all that.
But generally, you could probably get by with a $2 or $3 model. I use the AT Mega 64 myself. I'll talk about that in a little bit.
So, let's run microcontrollers. It's got everything built in. So, you have to buy the different parts and figure out how to wire it before you get started in the program. It's already ready to go.
So, there's two, there's all kinds of companies that make microcontrollers, you know, Hitachi, Megzome, Siemens Megzome. It's unique, have a cool.
However, those are generally more specialized. They have a specific purpose to exist. Maybe they're using cars or maybe they're used in other, you know, environments where they have some features that you generally want to need.
So, there are two companies though that make more of a generic catch all process or microcontroller.
First is microchip, the company. They make the pick processor, which has been around a long time. It's got a lot of support and a lot of community following around it.
And the other one is sort of newer. And that's the AVR chipset. And it's made by a company called Atmel, which you might have heard of. They make a lot of flash memory in other products.
So, kind of made sense for them to start one up. Actually, they bought that design for somebody else. But anyway, that's they make the AVR series of microchips.
Now, there's a big debate. If you go Google and look up like AVR versus pick or something like that, you'll see all kinds of lively debates by people, you know, saying, you know, that's better, no mind's better, mind's cheaper, mind's got more feet, whatever.
And I don't really have the data to tell you which one is better. I do have some small things I know about that kind of suggest AVR might be a little better, but you know, who knows.
I can't really tell you for sure what's better. The only reason I use the AVR series is because a friend of mine happened to have an AVR development kit, which allowed me to program a chip and actually test it right on the developing board.
And so that's why I got started with it turns out that AVR series has some other features on later that I'm so glad I started with it, but you know, I'm sure pick does just fine.
You might have a friend that knows how to pick processors and probably would make sense to learn those as well.
So anyway, I'm not going to say either one's better, but I am going to talk more about the annual version of AVR series, because that's all I know.
So if you want to get started with any of this, it's actually with the so no more pick talk. I'm just going to talk about AVRs.
If you want to get started with this, you don't have to buy anything actually. You can go to at mel.com. I'm going to step through it right now.
And I'll probably put a link up. I remember if you want to add mel.com at the top, you can click on products.
And then in the upper left, you see microcontrollers, a bit risk. Click on that.
And then you're in the 8-bit microcontroller section, and you can look at devices. You can look at the instruction set, the different commands it understands.
You can click on devices, and you can see all the different kinds of chips in this family.
And I'll back up a minute because what's an 8-bit chip? What's a 32-bit chip? That was an option as well. You know, what's all the difference here.
The difference is an 8-bit chip works with variables that are 8-bit large or a byte.
So it can only add two 8-bit numbers together because it's registers inside. This are used to do addition, subtraction, and all the other commands.
So that means you can only go 8-bits, and you can go from 0 to 255 decibel with 8-bits.
So that kind of is lame because if you write a program, you need to go past 255 with a variable, what do you do?
Well, what you end up doing actually is you use more than one register to store the variable.
If you want to make a 16-bit number, which you can go up to, was a... I forgot. I think it's like 65,000 or something.
Let's say two to the 16... Yeah, 65,000. So that's a decently big number. If you want to make a 32-bit number and it goes up to 4-billion, you can.
The way you do it is you break it up. Let's talk about a 16-bit number for a second.
What you do is you take the first 8-bits from the left. That's the most significant bits because it's a larger number on the left side. It's more significant.
You put that in one register and then you take the right most 8-bits and put that in another register.
And so say you want to increment that variable when you increment the lower, the least significant register.
But then you have to test to see if there was an overflow. If it was all at 1-1-1-1-1, once, then you increment it and it goes overflows to 0-0-0-0-0.
So you need to look for that. You need to actually see after you increment the first part if there wasn't overflow.
If so, then you need to increment the other number, the other register, the most significant one.
So that's, and then you can take that all the way up to 32-bit, 64-bit.
But what's interesting about that is that it takes more instructions to work with a 32-bit number, as an example, or a 16-bit number.
Because instead of just incrementing the number, you'd have to increment the lower byte, then check that for overflow and then do an if statement.
And if there wasn't overflow, then do another command, which is to increment the upper register. So it takes a few different instructions.
That contrast with a 32-bit register, where you can have all the entire 32-bit number in one register and you can increment it, you can, you know, subtracting all that.
You don't have to worry about overflow, except if you get to 4 billion or whatever 32-bit gives you.
So that's the difference between a 32-bit and 8-bit generally. I imagine it's more, but it's the basic difference.
So why do people use 8-bit processors, though, if you have this problem going to 255 in all these workarounds?
Well, it turns out that there's a nice shortcut that we'll get to that in a second.
But if you're going to do it all in assembly, then you have to do it manually.
You have to, you know, increment one, do a check, and all that stuff.
And so you got to make sure that you're using it correctly.
Make sure you don't have overflows without knowing about it.
Okay, so that's what a 32-bit first 8-bit processor is. I'm not sure what other things they do, but that's the thing I know.
Okay, so, anyway, if you wanted to play around with, you know, playing with these things, you can actually go to appnell.com, like I said, and go to products, 8-bit, or risk chips.
And then you can go to tools and software, which is about halfway down the gray menu.
And then you've got a whole bunch of things you can download.
And at the top, you can see development kit.
Development kit has a link. You can click on that, and it takes you down to the, where did it go?
You might have to go a little bit. AVR Studio.
So AVR Studio is the program you use in Windows.
There are options for Linux, but AVR Studio works.
I think it works in wine as well. The older version did for sure.
3.5 something.
Anyway, so AVR Studio, what that does is it gives you an IDE development environment, where you have, you know, where you can write your program in assembly.
And then you can actually step through it line by line and watch it run.
And you can see the very, the registers of the macro controller, you can see what's happening to the line by line.
So it's really neat to download an assembly program and just step through it with this tool.
It's familiar quite a bit. And then you can start tweaking it and playing and making your own thing.
And you can also look at the pins. If you have input output pins, which most of the chips do, you can control.
You can say whether or not the pin is an input or an output.
And it's an input, you can actually read it. It's a certain kind of register, and you can look to see if it's 1 or 0.
And that means that there's 5 volts or not, or 0 volts.
And then you could do something based on that.
Because it's an output, you can actually push a value to it 1 or 0.
If it's 1 and it's high, that means it's 5 volts, it's 0 and it's low, of course.
So you can control the pins and you can look at their status in this environment, maybe our studio environment as well.
So really useful, ton of fun. And it's completely free.
So I know just aside for the pick processor, I believe they have an assembler as well.
It does pretty much the same thing.
Anyway, assembler is good to start with with these microcontrollers, because you're right at the hardware level.
You generally, in the beginning of a program, you write to some specific registers to say how you want the processor to behave.
For example, you can say whether or not you want to use interops, or if you're going to use a counter.
If you're going to use a counter, how you want the counter to behave, all these kind of initialization kind of things.
And you can see examples of that.
Just for fun, I'll tell you about what a counter is in case you don't know.
Generally, if you have a program and it's doing its thing, it's going through some infinite loop, because you don't want it to stop.
If you want it to keep going forever, you might want to interrupt it at certain times.
Perhaps like if you make a clock, like I did, you might want to interrupt every second and have it force it to go to the increment second function.
So you can increment seconds to keep things accurate for the time accurate.
So you can make a counter that counts up.
And then when as soon as it gets to a certain number, or if it overflows or something, it can actually make an interrupt, which forces a procedure and interrupt procedure to be started.
And so it's neat, because you can actually have the counter count clock cycles.
And if you know how fast the clock is, say it's an eight megahertz clock, eight million ticks per second, then you can have a counter that does accounts to eight million.
And then we'll tell you when it gets there, and then it'll generate the interrupt.
So that's an example of what a counter is.
You can also have interrupts like on the input output pins.
So if a pin goes high, it generates interrupts, or you can just simply pull it, meaning you're looking at the pin intentionally.
Say, hey, is this pin higher low yet? I don't want it to interrupt me. I just want to check it right now.
So there's tons of different little features. So it's neat, because the counter is like a separate thing running at the same time as your program.
So it's like a little parallel circuit is kind of neat.
And you know, there's other things. There's one other thing I want to talk about is the stack in its memory.
All these chips have flat or regular memory like SRAM, very fast.
You know, it goes away when you turn it off, but it's very useful, very fast when it's running.
And the end, so it has only so much memory, and you know, you work from the top down, you put variables into memory.
If you're not, you know, you don't always have to put variables in the register as you can push them onto the memory.
But you can also, if you want to be able to do functions, so in other words, you want to call a function and then be able to have the function return you back to where you called it from, like a, like any language does, they need to activate what's called a stack.
And what that means is it uses the bottom of the SRAM memory to keep pointers of where the instruction, instruction pointer is pointing at before it goes off to the function that you ask it to go to.
So when the function's done, it tells it to go to the stack to find the pointer that it's stored before it went to the function so it can put that into the instruction pointer.
It gets it back to where you were.
So it saves its locations, what the stacks for. So that's neat for functions from returning from functions and that's how that works.
So it's all an assembly.
You can do any of these things and I really recommend it because you learn about all the initialization things and you understand how what abilities it has and very useful.
But eventually you're going to get tired of assembly because anyone who's ever programmed it knows that it's very action, it's actually very easy like an instruction could be a simple as put this number in register one, put this number in register two.
And then then do an add instruction where it adds R1 and R2 and it puts the result in say R1 whatever.
You know, this is really easy stuff.
So it's generally not that hard to learn. The real challenge is to understand how to take these very basic elementary steps and combine them to do some actual useful stuff.
So, you know, with an assembly, it's kind of hard if you do really complicated if statements, lots of orders and it just gets kind of paid but to change things.
It's fast because you're controlling the hardware directly and you can you can make sure it doesn't do anything extra.
You don't want it to do. But again, it's, I mean, it runs fast, but it's slow to program.
Of course, we have these high-level languages like C and it turns out that you can actually get a C compiler for the AVR for both families actually.
You can buy a basic compiler, I believe, called BASCO. I'd ever used it for the AVR and you can buy a C compiler, I forget from where for some of my money.
But I'm not sure why you do that because it's actually a free C compiler for the AVR chips.
And this is why I'm really glad I stayed or I started with AVR. I'm still using it because when I learned about it, I just couldn't believe it.
Because some of these compilers could cost like a thousand bucks or like $500 per year or things like that.
So they get really expensive because it saves you a lot of time. It takes a lot of work to make a compiler.
But anyway, the free compiler for the AVR you can find at, sorry, win AVR as kind of like window AVR, winavr.sourceforge.net.
And you can download it there. And what that is is they've actually taken the GCC, the compiler for, you know, using Linux.
And they've made a library, a libc library for the AVR series that understands the instructions that are available and can move around it.
And you can actually compile C right there for free. And it works great. It's not hard to use it all.
There's a couple demo programs to get started when you download it. And it does, how do you run GCC on Windows?
Well, it's kind of uses SIGWIN, which allows you to do Linux stuff. So they've packaged SIGWIN and it together in a way that allows you to, you actually don't see it propped.
It just does it in the background after you take your program and say compile. It just calls it and tells you if there's an error or not.
If there's not, you get a assembly program that can be burned or actually it's not the term a compiled object or just a file that you can copy onto the chip and run.
So very cool. It saved me a lot of time. One example was I was making a machine that required or I was making a coiling machine and had to have an LCD screen so you can read what stage it was at on the coiler.
And so I wanted to actually communicate with the LCD screen. It's just four lines of text. You know, it's a very basic thing like you see on a alarm system or something like that.
However, it's pain. Yes, because you have to know how it works with the instructions are to control the LCD screen and so forth.
It turns out that, you know, they're all kind of standard. So someone just decided to write a library for it. You include that.
And then you can just simply say put S, parentheses and quotes and hello. And that's it. That's like the entire thing right there. And you hook up the LCD to the right pins.
And you define the pins and header file of which which venture using and it works. It was amazing. I actually set aside a couple of weeks to learn how to do it until I found out about that library. And of course, just all these other libraries, like serial port libraries to make everything easy to do.
And that's with beauty, beautiful, beautiful thing about C on a VR is they have all these libraries and it's just gorgeous. So props to these guys. They did a great job. Of course, you can run this stuff in Linux as well.
You just don't use a single part. You can now use a tool chain that's made for Linux to pile for cross compile for the record drawer, the VR series.
So I just really couldn't believe how easy it was to use how amazing and free. So again, still haven't paid for any except a couple of devices, which cost me about three bucks or each or so.
Oh, and a development board. And you can get the development board from now. If you go back to where was it tools, I guess. And development kit.
And you'll see one of the options around there is STK 500. And that's you click on that link. You'll and I'll try to put all these links in the show notes. If I remember, I'm kind of sick. So I might not do it tonight.
But this is the night before the show. I left it to the last minute. But you can actually get this little development board that has all these different socket sizes for all the different size AVR chips. You can program all these different kinds of chips.
And I even have some lights and some headers to help you connect directly from the chip to some stuff you're playing with big testing. So you can do it. You can just keep the chip in the development board and run the program right on the development board.
And play with it that way until you're ready to make your own circuit board.
Okay, so anyway, I thought I'd give away one of my programs. I actually way back when it was like 12, 13 years old. I went to San Francisco, I was born raised in Oakland.
Went to San Francisco and went to the nature company. There is a little store and they had this sweet clock. It's called the alien clock. And it basically tells time patterns of light. And so I loved it. I was like, this is so cool. But it was $100.
And by the way, you can actually now I didn't notice the time when you go to alien clock.com. Well, I don't know what the site went live. But you can see what I'm talking about is patterns of light. It's not like a binary clock. I've seen those around. I don't like those because it takes too long to read.
But they think the alien clock has patterns of light. So it's actually easier to read. I can read it in a second or so.
So I didn't have access to that at the time. Oh, so I saved up my money, $100. That'll load a few long. Went back there and they were discontinued. So I didn't have any place to buy it from. It was really fun.
So I've always had that in the back of my head. I really want to clap. It looks like that. Well, finally, when I heard about these these microcontrollers, I was saying, well, that was my chance.
I can make a circuit board with that LEDs on it. And then make a little bracket to mount it in so it stands up on your desk. And because I didn't have this clock in front of me, I made my own pattern of light, my own configuration. And it turns out actually it's a little more efficient than what the professional one you can actually reach fewer lights to get the time.
Anyway, so I'll release the circuit board spec as well as the source code, the schematics for it. So you can see what lines up what it's very, very basic. By the way, I'm a mechanical engineer. I'm not an electrical guy. I know very little bit, very little about electronics.
So I know how to turn a light on with a light with an input output pin using a transistor. There's very basic circuits to do that or control motor with a relay things like that.
Really not much to learn after that. So there's a couple schematics. You can find how to control stuff with my controllers. And there's very well known methods to do so.
Let's just go dig them up and use them and you don't have to be a professional engineer.
Okay, so finally, let's talk about some links. Again, we talked about at mel.com. That's where you can download the assembler that allows you to step through it.
And then you can go to other areas to download. If you go to data sheets on the ABR 8-bit part, you can download all the instructions and learn all the different instructions you can run on these chips. Some of them have more instructions than other, but in general, they're pretty much the same across the entire families. You don't have to relearn it for different chips, which is nice.
Finally, win avr.sourceforge.net. One other thing, not only can you compile and see with that win avr, but you can also run gdb, the debugger, which is useful if you want to, if your program's not doing what you want, and you want to step through it, look at variables change one by one and add breakpoints and all these other things, you can run your program in the debugger.
And so that's very powerful to use your nice tools to check things, figure out what's wrong.
Website I go to a lot is avrfreaks.com. Unfortunately, it's pretty graphic, heavy, it takes a while to load even on a cable motor, but you know, there's a form where you can ask questions.
There's a subform for regular avr discussion 8-bit, as well as gcc avr. So you have to see compiler questions, you can look them up there and do a search first.
And let's see. I think that's pretty much all I got to say on it, again, very cheap hobby to get into.
I don't have to be professional, electrical stuff, very useful, made a lot of things, I've made a lot of sheets, robots to produce things for a company at work for.
You don't have to be a genius to do it. It's all inside the microchore.
And using C, compiler C is just very helpful. All right, so I hope that was interesting and maybe a few people take a look at that. And again, I'm pretty sick tonight.
I don't know if I'll get around to actually do the links and the source could have all that tonight, but I probably will put it up tomorrow, the 20th of March, midday or something like that. So please check back and you should see everything I promised you here.
Anyway, so that's another hacker public radio show.
Thank you for listening to hacker public radio.
HPR is sponsored by Carol.net, so head on over to CARO.ENC for all of us here.
You
You
