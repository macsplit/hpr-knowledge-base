Episode: 982
Title: HPR0982: LiTS 006: pmount
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0982/hpr0982.mp3
Transcribed: 2025-10-17 16:57:31

---

Welcome to Linux in the Shell episode 6.
My name is Dan Washco and today we are going to be talking about the P-Mount command.
But before I do so, I want to remind you, read the full article over there at LinuxIntheShell.org.
Watch the video of the examples of using the P-Mount command and also thank you, Hacker Public
Radio for supporting the show and I hope you support Hacker Public Radio by listening
and hopefully some day contributing.
Well, P-Mount is one of my favorite commands.
I've talked about this on some other shows I do, but I'm going to go through P-Mount
at least one more time because I find it so versatile.
If you use a desktop environment like GNOME, KDE, XFCE, you may be accustomed to when
you plug in a flash device or pop in a CD that auto mounts the device and it's available
to your preferred file manager or for use, however you want to use it.
Well, if you're on a lighter end system, maybe you don't want to run a heavy duty desktop
environment or maybe you're like me, you prefer to run something like fluxbox most of
the time.
You don't get that easy auto mounting feature in those environments.
Therefore, you have to find another way to mount your mass storage devices and P-Mount
is hands down, probably the easiest method to get running.
These are not installed by default in your distribution, but it's easily accessible
by whatever package manager you use.
I have not found a distribution.
I should say a distribution that I use Ubuntu, Debian, Arch, Fedora, Slackware, you name
it.
That does not have P-Mount accessible in some repository, so it should be quick to install.
By default out of the box, any user should be able to mount devices that are removable
storage.
All P-Mount is pretty much a wrapper around Mount that lets standard users mount devices.
Once you get P-Mount installed, there used to be that you had to add people to the P-Mount
group, but you don't have to do that in newer versions.
You could just elicit or execute the P-Mount command, and you're good to go.
The device, of course, is the device that you're trying to mount.
I said it amounts removable devices out of the box to check if a device is a removable
device.
You can plug it in, and then just issue the cat, space, slash cis, slash block, slash
the device, slash removable.
If the value that comes back is 1, it's a removable device, if it's 0, it's not.
If it comes back as a value of 1, P-Mount should be able to mount that without having to
create the white list for the device.
The devices that you want to mount, or allow users to mount none mount, that are not removable
devices, you can specify in the Etsy P-Mount.allow file, and that's the white list.
Devices can be listed in there one at a time, like SDA, SDA 1, SDA 2, SDA 3, or you can
glob them together, like SDA, open bracket, 1, 2, 3, close bracket, to achieve the same
result.
Now again, make sure in that white list you're specifying the path to the device, so it
will be dev SDA, not just SDA, so always put the path in there.
Dev SDA, open bracket, 1, 2, 3, close bracket, you'll be good to go.
So once a device is mountable, you might be asked, well, let's take a step back a second.
How do you determine what the device is that you plug into the system if you don't know
off hand?
Well, that is really simple.
Plug into device, wait a couple of seconds if it's a USB device, and then type the D-message
command, that's D-M-E-S-G, and at the end of that command, you should see the output
showing you, it found the USB mass storage device, or some kind of device, and it's available
now at some partition, like dev SDA, or SDB, actually, dev SDB, SDB1, it'll list the
partitions available to you.
Again, depending on the device, how fast it is, what not, you might have to wait two or
three seconds before it actually shows the device.
All right, once you find a device number, once you plug the device, get everything go
on, it's a removable device, all you need to do is type in P-mount, path to the device,
like, for instance, I plug in my zip clip, it comes up as dev SDB for the zip internal
flash, and device SDC1 for the flash card that's in there, this is Partition 1, so I can
type P-mount, slash dev slash SDB, and hit enter.
Devices are created, or device mount points are created under slash media, so in my case
here, I should find a device, if P-mount was successful, under slash media slash SDB.
Now you could pass a label to P-mount to use as the mount point, as opposed to using
the device name, so I could have said P-mount slash dev slash SDB, clip zip, and it would
mount it under media slash clip zip, and be accessible to me that way.
That's up to you.
Now once you have a device mounted, you want to probably know how to unmount it, and
as simple as issuing the P-U mount command, so that's P-U mount, dev SDB, or whatever
your device is, and it will unmount it.
Now, understands some of the default options in P-mount, when it mounts a device, if it's
a flash device, it will mount it with the sync turned off, so it mounts it in async mode,
with that means it's a caching as implemented, and a flash storage device.
So if you are writing to the flash, it caches that right to the flash and doesn't perform
it immediately, as you're working still, if you're copying files to it, it might appear
to take a while like it's actually copying the device, files straight to the device,
but what is in reality is happening is it's copying it into the cache, and before you
remove that device, you need to unmount it to make sure that everything is written from
the cache to the device, otherwise there's an option you could pass to mount it in synchronous
mode, which means all operations to the disk will occur immediately, and that will increase
your wait time performing any actions on that device, because it has to completely write
everything to that device until it's finished.
Now, if you're one who's prone to ripping out USB drives without amounting them, maybe
you want to turn on that dash S or sync option.
The other mount options available that you can alter are the dash R read only, or the
dash W or read right, you can pass those options by default, the devices are mounted
read right, there's the dash A or no A time, which will mount the device without A time
support, the default is A time, and there's also the dash E or dash dash execute, which mounts
a device with execute bit set that you can execute programs or shell scripts off that
device, default is no X, no X not being able to execute those, so be aware of those options
in there.
Let's also talk about file system support, pretty much all the file systems that you're
going to use are supported by the P mount command, with the exception that I know of as
of this writing, being butter FS, it does not support butter FS out of the box yet, but
it will support of course EXT 2, 3, 4, Ryzer FS, Ryzer FS 4, XFS, JFS, it does NTFS, VFAT,
UDF, HFS plus, HFS, OMFS and ISO 9660, so it'll probably do most of everything that
you want it to do, except for butter FS right now, unfortunately, so if you, it does a good
job at auto detecting the file system, unless the file system is borked, I've not had a
problem with P mount detecting file systems for me, but you can pass the dash t or type
option to P mount if you want to, to specify the file system on your own.
You mask, the default you mask for P mount, like most file, Linux file system is 022, so
any files created in a Linux based file system or most file systems that support a UMask
will be created with the 022, now just a reminder to determine what permissions a UMask
maps to, it's very simple equation, for files it's 666 minus the UMask and for directories
it's 777 minus the UMask, very simple, so the default UMask being 022, maps to files
being created as 644 and that is read, write for the owner, read for everybody else, directories
are created with 755 UMask, which equates to read, write, execute for the owner and read
and execute for everybody else, remember when talking about the executable bit on a directory
it's different than on a file, an executable bit in a directory, it's dictates that a user
can move into that directory or look at stuff inside that directory, it doesn't mean they
can execute programs in that directory, but they can actually enter into that directory,
whereas an executable bit on a file means that they can actually run that file as a command,
so those are the things to be aware of, default UMask for VFAT and NTFS files is always
077, you can change that if you want, which equates to files being created, the owner has
read, write on files and read, write, execute on directories and nobody else has any permissions
on there, so be aware of that, if you are mounting an encrypted file system it will ask
you for the passphrase to unencrypted, you can also pass to that dash p or dash dash
passphrase option and supply the file with the passphrase in there should you want to,
so there's that, there's a few other commands, but they go on beyond general usage if you
want to check out what those are, go to the man p-mount command and remember, always
unmount your devices before removing them from your system, so always type the p-U mount
command to remove said device, the last thing I will say about p-mount is that if you want
to see what devices are mounted with p-mount, currently type in p-mount with no other options
and it will show you just like the mount command with devices are mounted with the p-mount
command, I hope you enjoyed this episode, I hope you find p-mount very useful, I caution you
about installing it on a server-based system, but for a general use desktop I found it invaluable
to be able to mount removable file systems, particularly my clip zip and other flash media
devices without having to do some funky configuration of the mount command or run an autofs
or have your desktop. My name is Dan Washco, you're listening to Linux in the shell, read all
about the p-mount command over on the website, check out the example video and thanks again to
Hacker Public Radio for their support, see you in a fortnight.
You have been listening to Hacker Public Radio or Hacker Public Radio does our,
we are a community podcast network that releases shows every weekday on day through Friday.
Today's show, like all our shows, was contributed by a HBR listener by yourself,
if you ever consider recording a podcast then visit our website to find out how easy it really is.
Hacker Public Radio was founded by the digital dog pound and the infonomicum computer club,
HBR is funded by the binary revolution at binref.com,
all binref projects are proudly sponsored by Lina Pages.
From shared hosting to custom private clouds, go to LinaPages.com for all your hosting needs.
Unless otherwise stasis, today's show is released under a creative commons,
attribution, share a like, details or license.
