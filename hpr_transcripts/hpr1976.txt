Episode: 1976
Title: HPR1976: Introduction to sed - part 1
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1976/hpr1976.mp3
Transcribed: 2025-10-18 12:46:22

---

This is HPR Episode 1776 entitled Introduction to said Part 1.
It is hosted by Dave Morris and in about 44 minutes long.
The summary is what said is and how to use it in a simple way.
This episode of HPR is brought to you by An Honesthost.com.
Get 15% discount on all shared hosting with the offer code HPR15.
That's HPR15.
Better web hosting that's honest and fair at An Honesthost.com.
Hello everyone, this is Dave Morris.
I'm going to talk to you today about the said program.
You probably know what said is, but just in case you don't, it's an editor.
It expects to read a stream of text and then apply some action to that text
and then send it out to another stream.
It filters and transforms the text along the way and you can control what it does by giving it instructions.
The instructions are referred to as a said script.
So the name said, as you might well have guessed or probably know, is based on the words stream editor
because of that the process I just described.
And said was originally developed between 1973 and 1974.
And it was a unique utility by Lee McMahan.
And I think you'd say it or Mack Mahan, I don't know how you'd pronounce that name.
It was Irish, it would be McMahan.
Anyway, he was in Bell Labs and he came up with this.
Then in later times, the GNU project has enhanced said.
And it's really GNU said that I'm going to be talking about.
There's quite a lot of new features been added in GNU said.
And there's much better documentation.
Though one of the things about the GNU project is that a lot of the documentation is available mainly
through the info command, not through the man command.
And I'm not a great fan of info myself, you might think otherwise.
But anyway, there's a full manual in enormous detail, which is available on the web.
And I've linked to it in my notes.
So let's look at using said in a basic way.
The command is said, SED.
And it's usually, it's invoked from the command line, naturally enough.
And it's usually given a said script on the command line.
And an input file is nominated there.
So I've given an example which consists of said the command space minus e space.
Then in quotes, S slash old slash new slash close quotes followed by infile.
A greater than sign and out file.
So what we have here is the minus e thing introduces the said script.
And it's enclosed in quotation marks.
You don't actually always have to enclose it in quotation marks because it depends on whether it's got spaces in it or other shell related.
But throughout this, I'm just going to use quotation marks all the time.
Because I think it's just a good habit to get into.
The file in this example is the file that's going to be read and edited.
And in this particular case, the result is written to an output file.
But normally it's just written to standard out.
So the greater than sign here is redirecting standard out into this file.
I've called out file.
This is not doing anything useful.
It's just to give you some idea of the structure.
So in this episode, I'm using a small file of text which is the contents of which are listed in the notes.
And it's also available on the HPR site for this particular show.
The text is just pulled from the about page on the HPR site.
The file I've called said underscore demo1.txt.
If the input file is missing when you invoke said, then it expects its input to come from standard input.
So I've given an example of a sort of pipeline you might type on the command line.
And if you're not aware of what a pipeline is, it's where you type multiple commands on the command line and you join them together.
So that the output of one is processed as the input of the next.
So in this particular case, I've got WC, that's the word count command, space minus L.
That's asking for the number of lines in the thing it's counting.
And I've given it the file said underscore demo1.txt as its input.
So we've asked how many lines there are in this file.
But because the WC command, if you run it in this way, returns you an answer that consists of the count followed by the name of the file.
Because it does that, I'm piping the result into a said script.
And so there's a vertical by which is the connector, the pipe symbol.
And it's followed by said, SED, space minus E.
And then in single quotes, we have S slash space dot star dollar slash slash close quote.
So what that actually does is it removes the file name.
So as I said, WC would generate 13, because there's 13 lines in this file, space, SED underscore demo1.txt.
If you actually just want the 13, then this piece of said script will strip out the file name bit from it and just return the number.
It's a very artificial example of this because it just so happens if you run WC without giving it a file.
But with telling it to take its input from a file by redirection.
So WC space minus L space less than sine space said demo1.txt.
You'll get back the answer 13 because it's coming.
That's causing bash to feed the file to WC on its standard in channel.
And so it never sees a file name per say.
So as you might imagine, the said command takes a bunch of options, which will deal with a few here just now.
But we'll be looking at more in further episodes of this.
And I'm planning on at least back four episodes, possibly five on this particular subject.
It's hard to know how many episodes are going to take.
I haven't mapped them all out yet. I've only got about as far as number three.
And it looks like there's going to be several more.
Anyway, the options you're most likely to see, we've already seen one, the minus E option.
The minus E is followed by a script, and it stands for expression.
You can also put two hyphen, double hyphen expression, the word expression equals, and then the script.
So this is the way you define the said commands to be executed.
So the so-called said script has been using.
You can have minus E followed by script multiple times in your said command.
And it just concatenates them all together.
We'll look at this in more detail later.
The other option is minus F, lower case in both cases, I should say.
And that's followed by the name of a file.
The alternative is minus minus file equals, and then the name of a file.
This defines a file that contains the said commands.
And you can have multiple files, and you also combine that with the minus E variant, if you wish.
The final option is minus minus help, which gives you some basic help on how to use said.
If you don't provide any options at all, if there's no minus E, minus minus expression, minus F or minus minus file, then the first non-option argument is taken to be the said script.
So you can actually just type said, and then put the script.
I don't really know why you would choose one over the other.
I just like to use the minus E personally just to make it completely unambiguous.
After the script, in this case, all the remaining arguments are names of input files.
You could have more than one input file.
And if there's no input file at all, then we read from standard input.
We've already seen this in brief.
So it's worth looking at how said actually works.
This is quite a large subject, so I'm not going to go into a lot of detail.
I'll pick up on this later.
But it's useful to have some sort of concept of how said works to this stage, I think.
So said takes in commands or scripts in its own editor language.
It takes them from the command line or from file.
And then it stores them.
It can catanate them altogether and stores them.
It then processes the data it's been given through the input files, plural,
or pipe to it on standard in.
It reads this one line at a time, and each line is placed into an internal structure called the pattern space.
Then said runs the saved commands on the pattern space.
So you might have just the one command.
We've only seen one so far.
But you might have a whole file of them that you want to apply to the data.
So it applies all of the commands to the pattern space, which contains sequential lines from the input sources.
There's quite a range of available commands.
There are conditional commands as well.
But we'll leave them till cultural quite further on down the road in this series.
The commands may change the data in the pattern space.
In most cases, that's the point of running said in the first place.
You're changing the data.
But it won't change all lines.
It'll change the ones that you've asked it to.
Now we want all the commands to be executed on a given line.
The contents of the pattern space are printed.
The pattern space is cleared and then the next line from the input source is red.
Now the printing of the pattern space is the default behavior, but it can be overridden.
And we'll look at that later on.
So that's it in a nutshell.
You can gather there's a fair bit more, but that's enough to be getting along with.
But it's useful to have that concept in your mind, I think, to understand what said is actually doing.
So let's look at simple said scripts in this particular case.
And we'll just concentrate on what's really the commonest said command, which is the S command, which is short for substitute.
So you've already seen me using it, but I didn't explain a lot about it.
It consists of the structure, an S, a low case S, a slash, then it's then followed by a pattern, which is a regular expression.
In the notes, I've spelled it, regexp or rejects.
Then another slash follows the regular expression, then a replacement.
That's the thing that is going to replace the pattern if it's found.
And that's then followed by a final slash and optional flags.
The power of said it really exists in the regular expression matching.
So it's really quite important to understand the basics of regular expressions anyway, which is what we'll look at shortly.
The flags just going back to them are used to modify the behavior of the command.
And we'll just look at one particular flag in this episode, but there's more to come in later episodes.
So let's look at simple regular expressions.
A regular expression is a pattern which is used to match a string.
And a regular expression is a sort of a language.
People would say I think that it's quite an obscure language, but I hope you'll find that it becomes clearer as we go through this.
And I've put together a table of some of the various parts of the regular expression language, if you like to call it that.
In a table in the notes, these are the long notes I'm talking about.
There are various so-called meta characters which are used in the regular expression.
First of all, let's look at the case of any character.
Any character which is not the meta character, and we'll do all the meta characters in a minute.
Any character that you put in your regular expression that's not the meta character is just treated as that character.
So a letter A means I want this pattern to contain a letter A.
The next one is a dot or a full stop or a period, if you're American.
And that is a generic meta character which matches any character in the pattern space.
Then the asterisk is the next example.
And that is a modifier which when placed after another character, a meta character or an ordinary character,
says apply that particular expression, if you want to call the letter that you're talking about, an expression, the meta character expression.
Match it 0 or more times.
So the preceding item is to be matched 0 or more times.
I'll expand on these with examples in a minute.
Then there's square bracket, followed by a list and a closed square bracket.
And what this does is it matches any single character in the list between the square brackets.
So for example, open square bracket, AEIOU, closed square bracket,
means that you're prepared to match any vowel in your pattern space.
The other variant of this is after the opening square bracket, you put a carrot character, put an upward arrow thing and then the list.
And that reverses the meaning of list.
So it matches any single character which is not in the list.
And the next example of an expression is the carrot or the up arrow or on its own.
What that means is your pattern, your regular expression, is to match the beginning of the line.
So it's an anchor, meaning the beginning of the line.
An equivalent one is the dollar sign which matches the end of the line and anchors the search at the end.
So let's go into these in a bit more detail.
If we look at the simple character matching form, if we were using it, all of these examples are going to be using the S command.
So if we take the example ABC as a regular expression, that just matches any string which contains the characters ABC in that order.
It doesn't matter where about the ABC exists when we're just dealing with it in this form.
So the example is S slash ABC slash DEF, close slash, final slash.
This will find the first occurrence of ABC and we'll change it to DEF.
We're talking here about a literal A, literal B, literal C. There are no meta characters in here at all.
But if we move on to the case of matching arbitrary characters using the dot character as we saw earlier, it matches any character.
So we could search and change the string ABC or AAC or any other three character string beginning with A and ending with C with the S command.
S slash A dot C slash DEF slash.
So what that's saying is any sequence of characters that get three characters, which begins with an A and ends with a C, want to be changed to DEF.
Then you might be asking, well, what do you do if you actually want to match a literal dot full stop character?
Well, the answer to that is you need to tell said that you're not wanting to use the dot as this meta character, the match anything character.
And you do that by proceeding with the back slash, backward slash.
So that tells the regular expression parser that you don't want it to have this meta character function.
So my example is if you had the string 17 dot 30 and you wanted it, it was a time which had been mistakenly typed without the standard colon between the elements.
So it's meant to be 17 30. Then you would put you would type the command S slash 17 back slash dot 30 slash 17 colon 30 slash slightly artificial.
I know, but it will certainly find the sequences sequence of characters 17 dot 30 and change it to 17 colon 30.
Moving on to the asterisk character, which means zero or more of the preceding expression, we can then match sequences of variable length.
Number is zero or more that we can match. So if we are looking for a sequence of characters, say, say, for example, we're prepared to match with BC or ABC or A, ABC or A, ABC, then using the command S slash A star BC slash DEF slash.
It means is the A followed by a star means you're prepared to match, you want to match one zero A's up to any number of A's followed by B and C.
One of the star means zero or more instances of the preceding item. If you actually need to indicate a real or literal star asterisk, then surprise, surprise, you escape it as the term is by putting a lead, a backslash character in front of it.
So you stop it being a meta character and you want to match a literal asterisk. So the next case is when we want to match sequence of characters, which are in or not in a set of characters.
So remember, we saw the open square bracket, followed by a list of characters, closed square bracket, expression. So if we wanted to match the letter C, followed by any vowel, followed by T, and then replace it with DOG, then we would use the expression S slash C, open square bracket, AEIOU, closed square brackets, T slash.
So that will find any instance of CAT or CET or CIT or COT or CUT and replace them with DOG.
So the thing in the square brackets, the list matches just one character in the form that we've used here.
So the other form of the list format, the list expression, then its open square brackets, followed by an up arrow or a carrot, I tend to call it up arrow by the way, but it is officially a carrot, C-A-R-E-T character.
Anyway, the up arrow list closed square bracket matches any character not in the given list. So for example, my example shows we're looking for the sequence open round bracket, open parenthesis, followed by any sequence of characters which are not a closed parenthesis, followed by a closed parenthesis.
So we've got S slash open parenthesis, open square bracket, up arrow, closed parenthesis, closed square bracket, star, rasterous, closed parenthesis, slash, then open parenthesis, example space, one closed parenthesis slash.
Now this might look confusing first glance, but it's a common type of expression used in said and elsewhere where you would use regular expressions.
We're matching an open parenthesis, followed by any characters which are not a closed parenthesis, followed by a closed parenthesis.
So anything in parenthesis, any sequence of characters in parenthesis are going to be matched by this expression, and then we replace what we find by the text open parenthesis, example one closed parenthesis.
This is a sufficiently generic way of expressing a thing that says take that bracketed thing and replace it with this particular string.
Now if you had a piece of text where the parenthesized sequence span two lines, this is not going to work because said is a line oriented editor and it's not going to see the closed parenthesis on the line that it's read in.
So that's an issue, there's something you need to be aware of.
So this list construct, this list expression can just be a list of characters like we've seen, we put the vowels, for example, but it can also be a range.
So for example 0, hyphen 9, that means all of the digits from 0 to 9 inclusive, so that's quite powerful, you can save yourself some typing that way.
So my example shows a case where you're dealing with, you're looking for a string that begins with a capital A followed by a digit, one digit, and the digit is any digit between 4 and 6.
So it's s slash capital A, open square bracket, 4 hyphen 6, closed square bracket slash an.
So this will replace a 4, a 5 or a 6 with an.
So finally in this look at, brief look at regular expressions, we have the use of the a barrow and the dollar to anchor at the start or end of line.
So the, the character, the up arrow character, which is also called circumflex, I've forgotten that when I was mentioning it earlier, it's also called carrot I think.
When it starts at the beginning of a regular expression, it means the start of a line, we saw it being used as a, as a negation in the square bracket list thing, but elsewhere it indicates the, at the beginning of a line, it indicates the start of the line.
If you use it elsewhere in the line, in your regular expression, if you use it elsewhere in your regular expression, it indicates itself is just itself.
The character dollar, the dollar sign, when it occurs at the end of a regular expression indicates the end of a line, and if it's yourself sorry it just is a dollar character.
So if we're, if you look at an example, s slash up arrow a b c slash d e f, then it will replace, it will find and replace the sequence a b c at the start of a line only and replace it with d e f.
If we want to replace a b c at the end of a line, we would use s slash a b c dollar slash d e f slash.
So looking further at the s command, remember after the regular expression is the replacement, we've seen lots of examples, but mainly d e f, we've been replacing things with.
But there's a little bit more to be said about this replacement, it's been very simple so far, we can make it a lot more complex.
We'll go into more detail later on in the series, but for now we'll just look at the ampersand and character.
The uncharacter denotes the whole matched portion of the regular expression part of the command.
If you want to have an actual ampersand character, then you have to escape it with the back slash.
So we take the example s slash a b c slash ampersand d e f, what that means is you want to replace the string a b c with itself plus d e f.
So you can regard that as replacing a b c with a b c d e f.
There's an example that shows the literal ampersand.
So s slash fruit slash apple space back slash ampersand space pairs slash means you want to replace the word fruit with apples and pairs.
But if you forgot to put the back slash before the ampersand, you would find that it substituted in the original regular expression match.
So there's an example in the notes where we echo the string, eat your fruit, exclamation mark, to said and then say as it's a full command, this particular case.
Said minus e space open quote s slash fruit slash apples space ampersand space pairs slash close quote.
So this is the case where the the back slash has been forgotten.
So the result is the string eat your apples fruit pairs.
So to replace the ampersand with the thing that was matched in the first place, the word fruit.
Okay, that's clear. So I said we'd look at one example of flags.
In this case, and we'll look this time at the g flag.
So that happens that that's placed after the replacement part of the s expression.
Yes, command, I guess it's better way putting it.
And what this does, it causes the replacement to be reply applied to all matches, not just the first.
So g stands for global, make this change globally in this line.
So s slash a b sleaze a b c slash d e f slash g.
That means that all instances of the sequence a b c will be replaced with d e f in the current line.
And as we already saw earlier, if you don't put the g on the end, you just replace the first instance.
So finally, let's just briefly look at how you would structure things so that said red is commands from a file.
And we've seen already that use the minus f option.
Normally you would lay out the commands in the file one per line, but you don't have to.
The one per line separates out the commands, the end of line is the sort of command separator.
But you can put multiple commands on a line if you want to.
If you do that, you need to separate them with semicolon.
So I've shown an example here.
I hope it's not confusing.
I was looking at it again.
It looks slightly advanced.
But I'm using a feature of bash, which I haven't covered in the bash tips series that I've been doing.
It's called a Heardoc function.
It's a way in which you can provide what's effectively a file to a command simply by typing the lines after the invocation of the command.
But you need to enclose that chunk of the script with some extra features, which I'll talk about now.
So in my example, I've got said space minus f space.
And then a minus, what that means is there isn't a file at all.
I want you to read from standard in as if it was a file.
Minus f space minus the followed by space said underscore demo one dot txt.
So I'm using the example file, but we that I mentioned before.
That's then followed by two less than signs, no space in between them.
So it's less than less than and then the word END in capital.
Now that END is merely a label that says, right, the Heardoc, as it's called,
which is a sort of temporary file, is all of the lines from this point in the script to align the begins of the word END in capital.
So you put anything there you like, but you have to match it exactly to the end of everything to terminate the included stuff.
So following that line, I put s slash back slash dot slash exclamation mark slash g.
So what that says is replace all full stops with exclamation marks throughout each line and do it for every line.
Then the next line is s slash community with a lowercase c slash community with an uppercase c slash.
So what that says is replace in the first instance of lowercase community with uppercase community on a given line.
And the next line in my example is capital END.
So what that's doing is it's slurping those commands into said command storage and it's getting them from the lines that you type.
You can type this on the command line if you want to, but it's amazing, the inconvenient thing to do.
And as I've shown in the example afterwards, you could you could just as well do this by making a command using a quoted string.
So said space minus e space, open quote, and then the first line of the commands.
I won't read them out again.
Then a new line, then the second line of the commands, close quote space said underscore demo one dot txt.
So it's not, it's not particularly you will see this done.
This was probably why I'm referring to it here.
But in the majority of cases, it's better to actually create a said command file.
And you would do that as you would create any other file text files such as using an editor.
I tend to give such files an extension of dot s ed, which helps you, helps remind you what it is.
It's also useful if you're using more advanced editors that check the extensions of files to determine how to handle them.
For example, in VIM, if you do that, it considers this to be a file of said commands and will highlight them appropriately.
So in my final example here, I've assumed that a file called commands dot s ed has been created.
And the first command is to cat that file so you can see its contents.
And it's the same two lines as we've already seen.
Then the last command is said space minus f space commands dot said space said underscore demo one dot txt.
And that then runs the commands in that file against the example file that I'm using here.
I haven't shown you what this produces.
You could easily run this yourself.
Well, that's the whole point of me including a copy of the file for you to experiment with.
So I'm going to finish this episode by going through some examples.
And the examples hopefully contain enough explanation in the notes to explain the various features that I'm trying to demonstrate.
The first one is the one we've already seen.
The example one is the WC command where we use WC space minus l space said underscore demo one dot txt.
That's that example file we've been looking at.
Then that's piped as a vertical bar space said space minus e space quote s slash space dot star dollar slash slash quotes.
Now we already know that this is an artificial example, but it's here to to give you a clue as to how said works and hopefully you will understand the regular expression here much more than before.
So remember that WC returns when it's used in this way the string 1313 space and then the name file that it's been given.
So running this script the said script against it then what this does it replaces the first space and the zero or more characters that follow up to the end of the string.
So that's what the regular expression matches space dot meaning any character star meaning zero to to infinity instances of that any character followed by a dollar which means at the end of the string.
And it replaces them by the replacement string is empty so it deletes that so it deletes the space and the file name and just leaves the number.
So example two years applied to the example file and it consists of said space minus e space open quote s slash i s space n o space a re space n o slash close quote space said underscore demo one dot txt.
This fixes the grammar in this file where there's a sentence that says there is no restrictions and it replaces it with there are no restrictions.
The word restrictions is on the next line so you can't include that in the regular expression.
We can't just change the word is to the word art because there's other instances of is but there's only one instance of is no in the text so we use that as the regular expression the pattern that we're trying to match.
We're not making permanent changes to the file with this command you can do this to demonstrate what said will do it's often good thing to to make said do this type of thing and to see the results to prove that the expression that you the said program said script that you're constructing actually works but I've shown since it's a 13 line file you don't really want to run it against the you don't want to see the entire file every time you make one small change.
So I have given an example of running this script and then piping the result into grep grep as you hopefully know is a is a tool for selecting particular lines from a from a file based on a regular expression.
I'm using an option to grep minus capital A1 what that means is every time you match the thing I've asked you to match print the line after it the one line after A1 means the line after one line it could be A2 and you get two lines after.
And the regular expression on matching is the string R0 ARE space N0. So what I get back is the line that's changed the line that ends that begins with produced by the community fellow listeners like you and then ends with there are no so it's changed is no to R0 on that line.
And then just to give more context I get the line following it so I see that the full text is there are no restrictions on how long the show can be as opposed to there is no restrictions on how long the show can be.
We'll look at how said can ultra file and say the results back to it in the next episode actually.
For three does the same as example to changes this is no to R0 but it also changes the word topic to topics makes it plural and it does this by simply offering two expressions in the command line.
Minus E followed by the string the the command we were looking at before followed by another minus E followed by the S command which is open quote S slash topic space slash topics T O P I C S space slash close quote and it's running this again of course on said underscore demo 1 dot TXT.
It fixes the same fragment as we did before but it also fixes the phrase the topic you can cover because it really should be a plural there because later on in the sentence the word they is used to refer back to the topic and it's obviously should be a plural.
In the the regular expression we're trying to match we're matching topic space and we're doing this because the word topics with an S occurs later in the file so we we would hit that one as well and turn it into topics as if we didn't make it specific by adding space to the end.
So this is just really to demonstrate how you can use multiple commands in a set set script set call.
But you don't have to put a minus E followed by another minus E you can actually put them both both of the two S commands in one string of quoted material but you separate them with semicolon.
I mentioned semicolon before in the context of the minus air function so you see the final example is the same two S commands but separated from one another with semicolon.
I didn't know about this when I first started using said fair fair time ago I have to admit I didn't know you could you could use multiple commands in one line.
You will see in many cases people who are not aware of this they call said multiple times process the same text so you'd see said minus E something name of file pipe that into said again and make another change and pipe that into said again and make another change and that's not very efficient.
It's calling said multiple times it's it's much more elegant to do it all in one go or indeed put all the commands in a file if you're doing something complex.
So example four we're going to do something that's not really very practical but just to demonstrate we we're going to change the word hacker into hobby and we're going to change hackers into hobbyists.
So we've got said space minus E space open quote S slash hacker space slash hobby space slash semicolon S slash hackers with an S slash hobbyists slash quote space said underscore demo one dot TXT.
So there's one instance of the word hacker and one instance of the word hackers and plural we don't want hackers to be turned into hobbies which is silly so we differentiate the two instances in the way I've shown.
So example five is going over similar ground again but doing a few more odds and ends to it and what we've got here is one string one quoted string containing four said commands.
So we change the is no to are no we change the topic to topics and then I also change the all the full stops to full stops followed by spaces that is to a full stop followed by double space that was just just for demonstration but it's used to be the in typing material like this.
Full stop should always be followed by two spaces but that's going back to manual type writers and stuff don't think anybody cares about that these days.
And the final S command is to replace every space with a hash mark so that's S slash space slash hash mark slash G so that that means for each line that said sees do this to it.
So it fixes the grammatical issues that I was fixing before the double spacing is just silly really and the and very silly is turning all the spaces into hash marks using a G flag to process everything.
But what it really shows is that all of these commands is this for said commands here all of these commands are applied in turn to each line so remember said is pulling each line from the file into its pattern space is looking at the list of commands that it's that it's stored and it's applying them all in sequence to the line and then it's writing it out.
So it's if you get into the stage where you're putting multiple said commands together on one line you should really be looking at putting them in a file that force probably a reasonable number to put in the line but it the point is that what we've got here is a little said program effectively which is applying many many changes throughout a file or can do anyway.
So we're going to look at this in a lot more detail later on in the in this series which is really why I included it.
Okay, well that's it. I hope you found that interesting and you'll be back for the next episode whenever that's going to be.
Okay, then bye.
You've been listening to Hacker Public Radio at HackerPublicRadio.org.
We are a community podcast network that releases shows every weekday Monday through Friday.
Today's show like all our shows was contributed by an HBR listener like yourself.
If you ever thought of recording a podcast then click on our contributing to find out how easy it really is.
Hacker Public Radio was founded by the digital dog pound and the infonomicom computer club and is part of the binary revolution at binwreff.com.
If you have comments on today's show please email the host directly leave a comment on the website or record a follow-up episode yourself.
Unless otherwise stated today's show is released on the creative comments, attribution, share a like, 3.0 license.
Thank you.
