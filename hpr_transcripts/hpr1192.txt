Episode: 1192
Title: HPR1192: LiTS 024: time and /usr/bin/time
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1192/hpr1192.mp3
Transcribed: 2025-10-17 21:20:55

---

Welcome to episode 24 of Linux and the Shell of the Time Command.
My name is Dan Waschko, I'll be your host, and before I get talking about the Time Command,
I'd like to thank Hacker Public Radio for hosting a website and the audio files, and
I'd also suggest that you head on over to Hacker Public Radio and subscribe to their
RSS feeds, or at the very least download some shows and listen to them.
It's a great community and great organization.
Also consider contributing, because they're always looking for hosts.
Anything your geeky heart desires, they'll do a show for you.
Head on over there, hackerpublicradio.org.
All right, today we're going to talk about the Time Command.
The Time Command is a pretty handy utility for determining how long it takes an actual
application or process to run, but it not only shows the time, it also shows how much
CPU time was running as well as some other information, but at its nut shell you just
run time and you type out time and then the command that you want to run.
For example, Time Space LS would time how long it takes the system to run the LS command
in the current directory.
Now what you're going to get back are three different values.
You're going to get what's called real time, user time, system time.
Well, it's actually real time, which is wall clock time.
That means how much time it actually took the run in seconds.
So that's wall clock time, real time.
Now there's user time, which is actually user CPU time.
And what that means is how much time the CPU spent performing the action for the program
and not actually making any system calls.
It's just actual how much time that CPU spent for that application or that process.
Now the third value, system time, system time refers to how much CPU time that was used
performing system calls on behalf of the program.
So it separates user, which is the actual running of the program from system CPU time,
which is actual how much time the CPU was making system calls on behalf of the program.
Now you're going to get those three different values there.
And there's really not necessarily any correlation between the three.
So to speak that real time is not going to equal user time plus system time.
Because there's other things in there like IO and overhead in there that are not,
you're not seeing in these values.
But chances are, if it's a real simple process, user time might be zero seconds, system time might be also zero
or you're going to look at values in the nanosecond, microseconds actually.
Nanoseconds would be awesome, but microseconds.
That is what you're going to see by default.
Now another thing that you have to understand what you're going to see by default.
And don't get tripped up by this if you actually type in man time and see all these wonderful things
that you can do that I'm going to talk about.
And you try and do them and it doesn't work for you.
It comes back and says something's funky, right?
That's because chances are you're running bash.
And bash has a built in time command.
So by default, bash is going to run its own built in time command
as opposed to the actual quote time command that we're going to now start talking about.
If you type in which time and you don't get a response, that means time's not installed.
And it was not installed on my arch system, but it was installed on my Slack system.
So what I had to do for arch was pack man dash capital as time.
And chances are it's going to be called time in any other distribution and it installed time application in user bin time.
That's where it was. Now if I want to execute time, I have to supply the full path to time as opposed to just typing time.
So it would be anything going forward is going to be user bin time and then the process that I want to run.
Okay, so just be clear on that there is a built in time function in bash that will take precedence.
You want to run the time command that we're going to continue talking about.
It's you have to provide the full path. Okay, they both do at the basic level.
The same thing report those three values, but the actual time command is far more powerful.
And if you run it now user bin time LS run that command, you're going to get a world of difference in a response.
You're going to get two lines of output that have far more information on there, but still contain the same information that we just talked about.
The first line is going to have, of course, a number value in seconds is going to be some value in seconds followed by the word user.
It's another value in seconds followed by the word system and another value in seconds followed by elapsed.
The same things we just talked about. First value is user CPU time.
Second value is system CPU time and third value is elapsed or wall clock time.
Now we're going to start getting into some of the differences.
The fourth entry in there is CPU time.
Okay, what that actually means is how much time or how much of the CPU that process utilized at that was get devoted to that process.
Now that is not necessarily doesn't mean that's how much total CPU time the process took or how much of it, it's just how much it was devoted to the process right there.
What that usually equates to is the user CPU time in seconds plus the system CPU time in seconds divided by the elapsed time in seconds.
Okay, that's the equation for that's how much CPU time percentage right there of the CPU time to begin talking about these other things we're going to start verging on how to format the output of the time command.
And that would get rather dry if I started talking about formatting variables.
So I want to recommend that you head on over to the website to read the different format variables or run the man command.
But I'm going to talk about them as what they mean not necessarily their their variables.
Okay, how to how to achieve those.
So let's move on we talked about those first four outputs of time next you're going to come to a some values in parentheses.
And it's going to be some number average text plus some number average data and then it's going to show some number max resident and outside there's going to be in.
Okay, for kilowatt what that actually is is you're getting an average of the for average text average text is a value that shows how much of the program the process how much of the memory was used for the actual program.
Okay, that's just the full program then you have average data and data is how much memory is being utilized by the global data and the variables et cetera it's not the actual program the code the program it's the data for the program.
Okay, and then that the next one max resident max resident is the resident set size of the process during its lifetime.
It's the maximum amount of RAM that it actually memory that it actually took up.
Okay, that's physical memory that was utilized by the process during its lifetime.
It's not the average, but it's the maximum amount that it actually took up.
So that's what those next values then you have the second line and you have some number inputs plus some number outputs.
Okay, those values some number inputs some number outputs those values equal it's a number of file system inputs by the process so how much the process pulled in from the file system.
So those two values right there then you're going to get parentheses again and in there you're going to see some number major some number plus some number minor.
These are page phones so you're going to have the number of major major page phones and what that means what a major page fault is.
Is when a process attempts to access a page now pages is a page of memory that is mapped in the virtual address space but is not available in physical memory.
So it's it's trying to access memory that's mapped in the virtual address space could be swap or whatever but it's not actually in physical memory.
Okay, so it's trying to access that what it needs to do is it needs to file.
It needs to find space in the physical memory to map the page so it has to stop to find space that ends up becoming that's what a major page fault is.
Now the minor page fault on the other hand that is again is trying to access a page and address and again the page is actually loaded in memory at the time.
But is not marked in the memory management unit is being loaded in memory.
So the operating system needs to stop marked the page is being loaded in memory and then continue on with the application with the process.
So that is a minor page phone and then the last thing is swaps value swaps and swaps are the number of weights the program had to that happened to the program as it was switched out of memory.
Or out of the CPU so in a multi threaded environment where there's many processes going into the CPU each process is given a slice of time slice of CPU time a time slice.
If a if a process goes into the CPU and it exceeds its slight time slice it will be swapped out for another process and then swap back in.
Now there could be a whole bunch of reasons why it swaps out it could be because it's waiting on some IO to happen is waiting for data to come from a disk so the CPU swaps it out until that data is ready pushes out through another process swaps it back in.
So that'll tell you how many times that that actually happened that is the default output of the time command.
You can alter that with the dash F switch and then in double quotes you can put all sorts of text in there that you want but the formatting variable similar to the date command are going to be percent and some letter.
Okay now the letters are on the website or in the man page and you again you have all the ones that we talked about for showing different amounts of CPU usage you have different amounts of memory usage that it will show and then you have different amounts of input output that it will show.
So head on over there to look at those you encapsulate those in like double quotes and then whatever one of those values you want to put in there percent acts and then any other text that you want to and then it will spit that information out some other switches that may be valuable to you the dash O switch will take the output of the command time command and put it straight into a file.
So if you wanted to run an application or process that runs on a fairly regular basis you can you put time in front of it and do dash O and some file name and it will output the value to the file instead of on standard out or actually time is considered standard error standard out would be the actual output of the application standard error would be the value of time it would actually output standard error which is time to that file.
If you wanted to instead of overwriting the file append to it you would do the dash O with the dash A command also which means to append otherwise it's going to output now the last command I do believe I would like to mention or last switch that is the last switch is the dash V now if you want to see all the output that time will give you dash V and that's a verbose output.
And it shows all the values possible to be possible to be captured by time and the output is going to be very long it's going to be each one of those values on a separate line.
Okay so it's going to be all the values that we talked about you're going to see average shared text size average stack size average total size remember we talked about all those major faults minor faults all those things are going to be on the output so that's very handy if you want to see.
Everything that a process is doing for helping you debug a program. Now that is essentially the differences between time built in bash and user been time the actual application.
Get on over to the website to read the full write up also I have links down there and bibliography to talk about a lot of different things that I have mentioned like system calls what is resident set size what is actual data set size how is the memory layout done page faults context switching all those things right there.
There's a lot of in depth information time provides a very good nutshell of what's going on if you need to debug a program or see what's going on with an application.
Head on over there Linux in the shell.org this has been episode 26 of Linux in the shell.org with a time command I want to thank hacker public radio one more time.
hacker public radio dot org and I want to thank you for listening my name is Dan wash go you have a great day.
You have been listening to Hacker public radio at Hacker public radio does our we are a community podcast network that releases shows every weekday Monday through Friday today show like all our shows was contributed by a HBR listener like yourself.
If you ever consider recording a podcast then visit our website to find out how easy it really is.
Hacker public radio was founded by the digital dot pound and the economic and computer cloud.
HBR is funded by the binary revolution at binref.com all binref projects are proudly sponsored by linear pages.
From shared hosting to custom private clouds go to lunar pages.com for all your hosting needs.
Unless otherwise stasis today's show is released on the creative commons attribution share a life lead us our license.
