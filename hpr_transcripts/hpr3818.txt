Episode: 3818
Title: HPR3818: nop test redux
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3818/hpr3818.mp3
Transcribed: 2025-10-25 05:54:55

---

This is Hacker Public Radio Episode 3818 for Wednesday, the 22nd of March 2023.
Today's show is entitled No Optest Redux.
It is hosted by Brian in Ohio and is about 10 minutes long.
It carries a clean flag.
The summary is, a better No Optest.
Greetings, Hacker Public Radio, Brian in Ohio here.
I'm out from under my rock and I'm surprising.
I'm doing another show.
You usually don't put them together this quickly, but I really wanted to do a redo of the
No Optest, the last episode on the Z80 computer build, mostly because sometimes you get hit
in the head with the obvious stick.
When I listen to the episode and the one prior, I realize that it's a little bit boring
to hear somebody read off what comes out as output, even though it's in the show notes.
I thought to myself, and then I was reading an article about an old Z80 computer and
I saw a tone generator and then it just hit me.
It's like, oh, I could use the Arduino Mega Board to generate some tones to signal that
output from the logic probe and make it a little bit better podcast material than just
my voice.
That's what I've done.
I've modified the logic probe words a little bit by initializing another timer on the Arduino
Mega.
This is so ancillary from the main project.
I'll eventually show that maybe I'll post a code in the notes, but I'm not going to
go through a bit by bit here.
Anyway, there's another timer running that when you use a little PZO buzzer on it, you
can change the frequency and you can get different tones out of it, a pretty easy thing to
do.
I defined a couple of words to do a high tone and a low tone and an alternating tone.
The high tone would signify that when you put the logic probe, when you sample it, if
it senses a high level logic, it'll give it the high tone.
If it senses low level logic, it'll give the low tone and if it's alternating, if it's
pulsing, if it's just activity pulsing, then it'll give an alternating tone.
I have the system running here and I'll do a quick demo of the sounds that you'll be
hearing.
This is the low tone and that's what this one sounds like.
The next one is the high tone and the last one is alternating tone.
Those are the three tones.
What I'll do now is I'll just redo that no-optest describing which pins I'm probing, but this
time, at least I'll be a little bit more sensory feedback for you who are listening at
home.
To start the test, I've got the board all spooled up, I've got power and a clock initialized,
I've got power to the Z80, I've got the clock initialized and to show, so here I am
I'm probing the clock signal that goes into the Z80 that's being provided by the Arduino
megaboard and right now I've stopped the clock.
So let's see what we hear here.
That's a low signal and that could be lower high because when it stops, it depends on
where it's at.
It could be lower high, this time it happens to be low.
Now I'm going to start the clock and when I say I'm starting, all I'm doing is I'm typing
the word start clock at the fourth prompt and that exercises the word, that's the cool
interactive nature of fourth.
So here I am, I'm starting the clock and now I'll sample, I haven't moved the sampling
wire, sampling the same pin I did a second ago and now it's pulsing, I'll do that again,
trying to talk over it.
So the clock is running, which is what we would expect and because the clock is running
and the power has been set on the Z80, if I unplugged the wrong wire, hey not a second.
Put this over here.
So now I'm going to probe pin A0 and I will, let me do a quick, because I pulled that
clock signal out.
I'm going to do a quick reset here, let me take a second.
Alright, let's just step a couple of times, alright now I'm going to start the clock
should be started, I haven't stopped it.
So I'm going to sample on pin A0, okay and so that is the address line, the very first
least significant bit of the addresses being sampled, which is from 0 to 64000 and it'll
just, that pin will alternate the most.
So let's hear it again, alright now if I stop the clock and I sample it, we'd expect
that pin to be in some state other than pulsing, okay so it stopped at a high rate.
Now the other thing I did was I probed the M1 signal, M1 is the beginning of the machine
cycle and it's the first thing that happens, it's the first signal to the outside world
that the Z80 is fetching an op code, it's looking for instructions on the data bus.
So the, I'll do a reset here again just to get the, into a known good state and so now
I'm sampling the M1 signal, what we're going to hear is, we're going to hear the M1 signal
is initially high because it's an active low signal and for a couple of clock cycles
it'll stay high and then it'll go low and that's when the Z80 is going out to the data bus
and looking for its first instruction at memory location 0 and we're giving it the no-op
instruction. So here we go, okay so that's the beginning of the op code fetch, the Z80 is going
out, looking on the data bus and it's getting the no-op instruction and it's going to start
processing that, it takes a few cycles for it to process. Now if we go, if I'm going to move
the logic probe over to pin A0 again and what I'm going to do now is I'm just going to single-step
the clock continually here and so right now when I sample the A0 what's going to, we're going to see
is that it's low because it's looking at address 0 but after a few clock cycles it will go high
because it's looking at, it's done the first no-op and it's starting a new M1 cycle and it's
looking out at the data bus at memory location number 2 so let's, let's hear that.
Okay so it just went high and now if we step through a few more times what we're going to see
because we're going from binary 0 to binary 1 and then the next binary number is y 1 0 that's,
that pin A0 will go low again and the pin next to it will be high because it'll be sampling at,
at memory location 2 so let's listen to that.
Okay so it just went low and if I, and I'm going to move the logic probe 1 pin over to A1
and we sample that what we'll see is it'll be high because it's looking at, that's the address
of the next memory, location and memory that it's looking for an instruction and that does
it happen there it's, it's hard coded as A0 which is a no-op. So that was maybe a little bit
better understanding of what's going on with the no-op test. It kind of also gives me a framework
of maybe future to think about what programs I'll put on this initially just to see how it works,
how they can be more interesting to the listening audience and so it'll probably be sound-based
which will be a new kind of a new thing for me too. Anyway sit for today, short show,
next step in the process will be for me to start emulating some hardware on the Arduino
or Arduino mega and I'll think I have to, I'll have to emulate some memory, some kind of
ROM memory, that'll be where the program is stored and I'll have to emulate a latch which I'll
describe in the next show. So thanks for listening, Brian and the Hires signing out here and I want to
remember, remind everybody that if it's jammed, hit it, if it breaks, it needed replacing anyway.
You have been listening to Hacker Public Radio at HackerPublicRadio.org. Today's show was
contributed by a HBR listener like yourself. If you ever thought of recording a podcast,
click on our contribute link to find out how easy it really is. Hosting for HBR has been
kindly provided by an honesthost.com, the Internet Archive and our Sync.net. On this
otherwise stated, today's show is released on our Creative Commons Attribution 4.0 International
