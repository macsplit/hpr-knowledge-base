Episode: 1222
Title: HPR1222: LiTS 027: mathematical commands
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1222/hpr1222.mp3
Transcribed: 2025-10-17 21:55:25

---

Welcome to Linux in the Shell episode 27.
My name is Dan Washco, I'm your host today, and as always I'd like to thank Hacker Public
Radio for hosting the website and the audio files.
Please consider contributing to Hacker Public Radio or at the very least heading on over
to HackerPublicRadio.org and listening to one of the wonderful shows that's always
informative, put out every day by a fellow community member.
Today we're going to talk about a couple of more mathematical-based applications, three
programs we're going to talk about, Factor, Primes, and Sequence, and Arithmetic.
I'm going to throw that one a bonus in there, but we'll get to that at the end.
If you haven't listened or read the website, I suggest you head on over after this to
watch the video and see the full write-up of these applications and the links to the bibliography.
First program we're going to talk about is Factor.
Factor is part of the core utilities package and it should already be installed on your
system.
What Factor does is you give it a number and it will form prime factorization or integer
factorization upon that number and what that essentially is is it breaks a number, divides
a number down into the smallest prime positive integers that are greater than one.
For instance, if I were to do a factorization of the number two, factorization of that is
two, simple enough.
You usually omit the one in the output so it's just given, like three is three, but four
is two, two, so two times two is four.
You can't break two down any further, so you have two twos and then six would be two
times three.
You can't break it down any further.
Eight on the other hand, if you were to do it by hand you could say eight equals two times
four, four equals two times two, so three twos, two, two, two is the factor, factors of
eight.
That's three prime factors, two.
And in nine is three times three, ten is two times five and so on.
What factor does, it'll give you those values by just plugging in a number.
So for instance, if you were to type in factors, six hundred thirty two, the output would
be two, two, two, seventy nine.
So if you multiply it all three, all four of those integers together, two times two times
two times seventy nine, you get the value of six hundred thirty two.
It's just a handy little utility if you need to get the factors of a positive integer.
Now, you have to pass to it a positive integer, it won't accept floats, it won't accept
negative numbers, so it just does positive integers.
And also, there aren't any other options to the factor program, except for dash, dash
version, which shows you the version of it and dash, dash, help, which pretty much tells
you that the only option is version and gives a little info of what factor does.
So that's part of the core utils.
The other program I wanted to talk about is primes, primes does exactly what you might
think it does.
You pass it a starting number and an optional stopping number and it will give you all the
prime numbers between those two numbers.
So if you were to type in primes one to one thousand, it would go and list all the prime
numbers between one and one thousand.
Really simple.
Now, if you do not pass it a stopping number, it does have a hard coded limit.
And that limit is 4,294,9967,295.
So that's the upper limit that it will go and it will probably take a long time to get
there.
If you're just letting the number cycle through and you want to stop it, just hit Ctrl
C.
Like factor, primes doesn't have any other options to it, so you know, you're not going
to get anything else.
Starting value for primes is zero or a positive integer.
If you were to try and give a negative integer, it would fail or it doesn't work with floats
either.
So it just works with integers, just be aware of that.
Now primes may not be installed on your system.
It's part of the BSD games package.
So if you really want to mess around with primes and another one that we're going to talk
about today, arithmetic, you're going to have to get the BSD package, a BSD games package
out of your package repository.
Next one is going to have some options to it.
It's called sequence, SEQ.
Now what sequence is going to do is it's going to give you a, it's just going to output
a sequence of numbers from a starting number to an optional ending number.
So you probably do want to give an optional ending number or it's just going to give you
the last digit as, if you only provided one number, it's going to give you a count
up from one to that number that you provided.
So sequence, SEQ, by default, starts at one, count up from one to whatever number you
have passed to it.
Now you can pass an optional starting number and also an incremental number.
So for instance, if I wanted to get a list of numbers between 10 and 20, I would type
in SEQ, space 10, space 20, and it will show me all the numbers between 10 and 20, including
10 and 20.
That's what it does.
Now there's an option, there's a third option in there as a step number.
Now be careful because if you just put in one value for the sequence, that's the ending
number.
It goes from one to that ending number.
If you put in two numbers, that first number is treated as a starting number and the second
number is treated as a stopping number.
Now the starting number, if you're only providing a starting and stopping number, the starting
number has to be smaller than the stopping number, otherwise you're not going to get any
return value.
It's just going to be null, nothing will happen.
If I typed in sequence or SEQ, 2010, nothing will happen.
Now you can pass an increment value, which would be the middle number.
So that would be a third option, but be aware that when passing an increment number, it's
starting number, increment, ending number.
So starting at 10.5 and 20, those values, 10 would be the starting, 20 would be the stopping,
10.5 would be the increment.
So it would go 10, 10.5, 11, 11.5, 12, 12.5, so on.
The increment number occurs between the starting and stopping number.
So when there's three values in there, it treats the first entry as the second entry
as the increment and the third entry as the stopping point.
Now the increment could be a decrement.
So in this case, I did 10, or I'm sorry, 2010 as the start and stop.
If I were to put a negative one in there as the increment, which would actually be a decrement,
it would count down from 20 to negative or to 10, one step, negative one.
And as you noticed, I had said, as an example of the increment, 0.5, it works with floats
and negative numbers.
So you can do sequences with floats and negative numbers there.
So pretty handy.
For instance, if I were to do SEQ negative 10, 1, 10, it would count up from negative 10 all
the way through to 10, it would include 0.
Now unlike the other commands I had mentioned, this one does allow you some switches.
The first switch we could talk about is dash S or dash S separator equals, and it will
change the default separator between each number.
The default separator is a new line character.
But if you do dash S and comma, instead of a new line character, it would place a comma
in between each number.
You could put whatever you want in there.
You don't have to put it in a double close.
You could do sequence dash S, haha, 1, 10, and between each number would be, haha, be
1, haha, 2, haha, 3, haha, and so on to 10, haha.
Well, it wouldn't include haha after the 10 because that's the last number.
So you can, if you ever needed to get a quick sequence of numbers, you could use this in
the separator, and there you go, voila.
Now there is a dash W or dash dash equal dash width, and that will print all the numbers
with the same padding using zeros were necessary.
So if I were to do a sequence of five to a hundred, it would show me, it would use zeros
for padding.
So I would get 0, 0, 5, 0, 0, 6, 0, 0, 7, and so on until I got the double digits and
I get 0, 1, 0 for 10, 0, 2, 0 for 20, and then when I got to 100, it wouldn't pad.
It would just be 1, 0, 0, and so on.
And it would do padding with floats too, so whatever value you specify, or when you
do equal width, whatever you specify, that's up to you.
It would produce floats for zeros, or it would produce zeros to pad out the width of
the number so they're all equal.
Finally, there is a switch called dash f or dash dash format equals, and that allows
you to specify the print f-style floating point conversion specification, which chances
are you will never use this.
But it's an option that you have, and what that does is you have to specify in a print
f format, so by default it supports percent a, percent e, percent f, percent g.
And what those are is percent a is hexadecimal floating point lowercase.
Percent e is scientific notation lowercase, percent f is decimal floating point lowercase,
and percent g is the shortest representation of percent e, which is scientific notation
lowercase, or percent f, which is decimal floating point lowercase.
Now, percent g is the default right there.
So what that does is you're getting sequence of numbers in a decimal.
If you were to provide dash a, it would give you a sequence of numbers in hexadecimal floating
point.
And that's not the same as hexadecimal that you're accustomed to.
It's hexadecimal floating point, run it sequence dash f percent a, 1 to 100, and you'll
see what it is.
Now there's three other, or four other values there, and that's the same central values,
but instead of lowercase a, e, and f, a, e, f, and g, it's uppercase, a, e, f, and g.
And all that does is it switches them to uppercase.
So percent capital a, or uppercase a is hexadecimal floating point, uppercase, percent capital
e, scientific notation, uppercase, percent capital f, it's decimal floating point, uppercase,
percent capital g, is lower, use shortest representation, representation of whether percent
capital e, or percent capital f.
That sequence in a nutshell, right there, is, if you, you can get more in depth with
it, can print out in the print f style, that's covered in the info page a little more,
but changes are going to never use it.
So sequence allows you to print off a series of numbers.
You specify at least one number, a float, whatever, and it'll count from one to that number.
If you provide two numbers, that acts as a starting and stopping point, you provide three,
it's a start, decrement, or increment, and stopping point.
Now one other last thing I want to say, a caveat there, if you were to provide a starting
point of like one, and an ending point of five, and increment by point three, it would
not go all the way up to point five.
What you would get is, if you did sequence 1.35, it would give you a value all the way
up to 4.9, because the next entry in the sequence would actually be 5.2 and go above five.
So it'll show you all the way up to the maximum value without going above the stopping point.
So that's kind of a caveat there, be aware of that.
So that covers the last three mathematically based applications that I found that struck
my fancy that I thought I'd pass on to you.
As a bonus, since we're talking about math, there's some then BST games was included, there's
a little game in BST games called arithmetic.
And with that is, it's a little quiz, arithmetic quiz.
It presents you with math problems, addition, subtraction, division, or multiplication,
and you have to solve them.
You get graded on those for every 20 that you solve, you get graded, and it continues indefinitely.
But if you want to stop, you hit Ctrl C, and it will grade you on how well you did.
Now when you're presented with a problem, you have to get it right to continue on to the
next one.
If you get it wrong, it will ask you again until you get it right.
By default, it will use numbers 0 through 10 and only addition and subtraction.
Now there are switches to change this.
The dash O switch allows you to specify the operators, and it can be one or all of, or
any combination of the following, plus for addition, minus for subtraction, the forward
slash for division, and the asterisk for multiplication, pretty much the symbols that you should
be familiar with, that represent addition, subtraction, division, or multiplication.
Now the default range, like I said, is 10, so 0 to 10.
You can change that with the dash R option.
What that will do is if you specify dash R 1000, that would allow the integers of between
0 and 1000 to be used.
On the basic starting level, you'll be asked questions like, was 5 plus 2, 5 minus 6,
6 minus 5, all those sorts of things.
But if you specify a dash R 1000, you'll be asked stuff like, what's 500 plus 600, what's
500 plus 50, and so on, kind of like that.
You have to be aware, when you're specifying a range, that the range for addition and
the subterhand, the range for those operators, like a plus and multiplication, only addition
and multiple, it's arithmetic, the way that it works, is that a model in my words
there.
But for addition and multiplication, the range applies to the addendants, so that is,
or the terms or factors of the problem, so that is, you know, what you're adding together,
not necessarily the sum, doesn't apply to the sum, and what you're multiplying, and
not the product, okay.
So it's, it's, range for 0 to 100 is what you're going to add together, what you're going
to multiply.
Now, for subtraction and division, it's different.
That range applies to the divisor, which you're dividing with, or by, for division and
the quotient, which is the, the result of the, the division problem, and for subtraction,
it's the subterhand and the difference.
So it's, whatever you're subtracting with, not from, you have the, the number you're
subtracting from, how, what that value is, and the difference, which is the solution, or
the answer of a subtraction problem, so that's what the dash r applies to in those values,
they're a little different for multiplication and division.
It's going to take some fun little application, if you want to quiz yourself, or you have
a young child that's learning math, something to play around with, really simple.
That is it for this episode of Linux in the shell, I hope you found it fun and informative,
it's a little whimsical, fun mathematical applications, not necessarily completely practical
on a day-to-day basis, but hey, it's a mathematics, if you ever want to get factors of a program,
you have write it, or a number, you have write it, your, your fingertips there.
I thank you, my name is Dan Waschko, head on over to Linux in the shell.org to listen
to, or to read up the, on the full, write up these programs, see the links, and to listen
or watch the video of their examples.
Thank you for listening, and have a great day.
You have been listening to Hacker Public Radio at Hacker Public Radio.
We are a community podcast network that releases shows every weekday Monday through Friday.
Today's show, like all our shows, was contributed by a HPR listener like yourself.
If you ever consider recording a podcast, then visit our website to find out how easy
it really is.
Hacker Public Radio was founded by the Digital Door Pound and the Infonomicom Computer
Club.
HPR is funded by the binary revolution at binref.com, all binref projects are crowd-sponsored
by LUNAR pages.
From shared hosting to custom private clouds, go to LUNAR pages.com for all your hosting
needs.
Unless otherwise stasis, today's show is released under a creative commons, attribution,
shared like, the digital life suits the world.
