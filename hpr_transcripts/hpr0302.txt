Episode: 302
Title: HPR0302: Python Programming Part 3
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0302/hpr0302.mp3
Transcribed: 2025-10-07 15:56:05

---

.
.
Welcome to Huckabuck Radio 1, my name is Soak, Python programming 101 Part 3.
First up, I received some feedback, mostly saying good work, so thank everyone who said
that.
I'm glad people seem to have been enjoying this.
I also got a couple of things I need to mention.
RenGolfa mentioned something I need to say in that when I talked about the print command
I used quotes to surround the text, so print open brackets, quotes, hello quotes, close
brackets.
However, he correctly reminded me that you can use apostrophes to surround the text
and start quotes, e.g. print, open brackets, apostrophe, hello apostrophe, close brackets.
And that says you haven't used the escape character if you have quotes in the text.
This comes in handy when doing web programming where everything seems to need quotes around
it and using Fordslash all the time would be a pain in the rear, so thank you RG for
that.
We also mentioned that in Ubuntu, if you apt to get Python, you get a release candidate
to Python 3.0 RC1.
Now they shouldn't actually change that much, but it is something to be aware of.
I should have checked that myself and I didn't so I apologise to have them for that.
Hopefully this won't cause any major problems.
If it does, I may have to revisit some of the commands if they change, but I can't imagine
they would change them.
CK 009 also gave feedback.
He said that he had to add pound or hash or octo full, exclamation mark, Fordslash,
usl, Fordslash, bin, Fordslash, Python, by the path to Python on his machine, to the
top of the script and to change the permissions that was executable.
I think I need to clarify how to run the scripts.
I was going to come to this in a bit, but now it seems a good time to mention it.
I was running everything through Python itself by running Python 3.0 and then the script
name.
This means you can write pure Python code and you don't need to worry about this shebang
at the beginning.
If you want to make a script that can run itself, though, you do need to do this shebang,
that's the octo thought, exclamation mark.
On the first line, and then where the Python can be found, like the slash user slash bin
slash Python, I'm into earlier.
If you do that, you can then make the script executable and then you can run it like
bash script or any other script.
Because I was calling Python first, that was the execute in program, and so you didn't
need to change the script permissions.
I was going to mention this when we got to bigger programs, I didn't really see the need
to confuse everyone on the first real programming lesson, so I hadn't mentioned this.
But if anyone was wondering why they were having this issue, that is why.
Also because we are currently writing really simple programs, I thought it was easy just
to run through Python.
I will at least hopefully remember to remind you of this later once we get into bigger,
more useful programs that you may actually want to run more than once.
That's it for the feedback, so let's continue.
Loops.
If you need a program to print out the number one onto the screen, you can simply say print
one.
If you wanted it to print out one to five, you could say print one, print two, print
three, print four, and print five.
Now what if you wanted to print out the numbers from one to a hundred, or a thousand?
It would be silly to do a thousand print statements, and that's what loops are for.
You take one or more identical or nearly identical lines of code and loop around it to repeat
them without having to type tons more code.
There are three different types of loops in most languages where they Python does only
have the first two for now.
Type one, a four loop, that's F-O-R, not F-O-U-R, runs a specific number of times for some
variable, number that is, from start to finish, they run the code that many times.
Some languages do allow you to amend the variable in the middle, but this really isn't generally
a good idea because it will confuse you when reading the code if you see that it's meant
to run for ten times and it doesn't, and you're trying to figure out why.
There may be a few times when it is actually worthwhile doing, although I can't think of
any of the top may have, but generally you really don't want to if you can help it.
Not because the compiler will get confused, but because you will.
If you want to loop a specific number of times do this, if not try the second type.
Actually, I have just thought of a reason when I have done it, when you've got an error
and you just want to basically get straight out and you've said it to be passed just to finish
the loop.
There are other ways of doing error handling depending on the programming language, but that might
be the simplest way.
But like I said, if you want to loop a specific number of times to a full loop, if not try the
second type.
Type 2.
A while loop runs while something is true, while variable is under 10 do something.
A few points on this, you have to change the variable in the loop, otherwise you will
get stuck in an infinite loop.
While x is under 10, print out x.
If x never changes, if it's under 10, when it enters the loop, it will repeat forever.
This is of course bad, so always make sure you change the variable within the loop.
My tip is to make the last line of the loop, be the line that increments the variable.
That way it's easy to check when looking at the code again.
It also helps in other ways, which we'll see in a moment.
Also, a while loop may not have a run if the condition isn't true.
This can be very useful for error checking, for example, while the input is bad, keep
asking for more input.
Also, you should think about what you're checking for.
If you want to count from 1 to 10 and have a while x is not equal to 10 loop going, if
for any weird reason x never makes it to be exactly 10, then you're stuck in an infinite
loop again.
I would actually put while x is less than 10 to run until x is 10 or more, because if for
some reason x skips to 11, it doesn't matter, the loop will still exit.
This can be a problem when you write more complicated loops.
Type 3.
The final type of loop isn't actually in Python, yet.
There are discussions on the dev mailing list about it.
It is a while loop, but it checks at the end of the loop at not the start.
It is almost identical, except that a while loop may not ever run, but this type will run
once or more.
I mentioned this in case you have a look into other languages and wonder what it is.
It can be called the do while or loop while, in various languages, with the loop itself
between the two words on multiple lines, of course.
This loop checks at the end, not the start, and can be known as the do while as opposed
to a while loop, which would be the previous type, a while loop.
I'm going to stop this tutorial just for a moment and complain.
I couldn't spot any definitive documentation for Python 3.0 on the Python.org official
website mentioning this third type of loop, except for a few dev chats that I mentioned
before.
They mentioned that they wanted it a year or so ago, so I figured I could quickly go
into hash Python on free node, ask get a quick answer, and then continue.
Well, face it to say, I don't think I will ever go back into that room.
Ask the question nicely, I thought.
The response I got was basically RTFM.
In fact, the guy spent a while explaining why I should RTFM when his simple year two
types would have answered my question.
I spent more time typing I should RTFM than he would have spent answering my question.
It's this type of thing that books and new guys, I did spend time looking at the documentation.
They're still writing a lot of it for Python 3.
I couldn't see anything mentioning a do while loop, but then again, I didn't spot anything
saying they were only two types of loop.
Instead of having a section of loops with two subsections for and while, they had both
for and while loops in completely different sections.
So I wanted to make sure I didn't want to tell you anything that was wrong, and I thought
hash Python would be a good place to ask, although apparently not.
Oh, now I was also told to use Python 2.6.
All right, I'm sorry to go on about that, but that really bugged me.
This is why people say bad things about Linux users, oh, you're all smartly looking down
on other iOS, let's be nice and try to help everyone.
Say, yeah, there are two types of loops.
Actually, if you're looking in the tutorial listed at WebsiteX, it tells you more about
it.
So don't just say that question is answered in the tutorial, and then not even give a
link to it.
Apparently, there was a link in the topic at the brim, but so we're a million other
links, so I'd actually miss it, it's scrolled off the page.
All right, rant over with.
So let's make two programs that count to 10.
Of course, this can be done to higher numbers, but there's no point spamming north and terminal
with a count of numbers up to a million, counting to 10 will prove that it works.
Turn up test.py, or whichever file it was you'll be using, and enter in there for x in
range, that's just the word range, open brackets 1,10 close brackets, colon, and then on the
next line tabbed in, because it's part of the loop, print open brackets, x close brackets.
Save that and run the file by calling Python 3.0 test.py, of course, and remember to go
into the code directory before running that.
Notice that it counts up to 9.
Welcome to the wonderful confusing word of programming.
The range command counts up to, but not including the final number.
Now, computers normally start counting from 0 or up, so sometimes you do get what things
about this.
If you wanted it to create 10 objects, you'll find there number 0 to 9, in most programming
language is anyway.
In this case, the range command, it simply does not make sense to me, 1 to 10 should be
1 to 10, but it is something to remember for the future.
I'm guessing this command changed between 2.6 and 3.0, and this is why, but I don't know
for definite.
So, let's go back and amend the code to read, for x in range, open brackets 1,11 close
brackets, and then the colon on the print x as before.
From that again and now, it prints out 1 to 10 on the screen.
Rather a silly program, but hopefully it demonstrates how the 4 on the range commands work.
So, if we wanted to write a program to add the numbers from 1 to 100, we now know how
to do it.
Although, you can actually figure that one out in your head if you know the trick, as
a guy called Gauss figured that one out when he was a small boy, so the story goes.
So, for the next program, we want to count up from 1 to 100, adding in the current number
to a grand total.
The code would be y equals 0, and on the next line, the 4x in range, but say from 1 to 101,
then the colon, and then add another new line in, but y equals y plus x, that's tabbed
in again, and on the new line, we can change the print x to say print y, but remove the
tab so it takes it outside the loop.
So, here we set y to 0, and we have to do this to let Python know that y is a number, and
then we run through the numbers from 1 to 100, and add it into the grand total.
Note that we do y equals y plus x, because that says make y whatever y plus x is.
This is quite cool, you don't have to have multiple variables this way, and you say y equals
y plus x, or y equals y plus y plus x, or however we want to do it.
If we simply did y equals x, and of course we don't add up all of x, y just ends up being
100, the final number.
Before you run the program, Gauss actually figured out that 1 plus 100 is 101.
2 plus 99 is also 101.
3 plus 98 is 101, and so on until 50 plus 51.
So you have 50 pairs of 101, therefore adding up 1 to 100 is the same as 50 times 101.
We can do that in our heads, get 50, 50, 5,000 of 50.
Anyway, run the program and it should print out 50, which is quite cool.
We can do the same thing using the wild command, although as it's going to be from a fixed range,
it's probably a little overkill, but to demonstrate it, y equals 0, x equals 1,
while x is less than 101, colon, and then next 2 lines are tabbed in, y equals y plus x,
x equals x plus 1, and then the next line, without the tab is print, y, print open brackets,
y, close brackets.
This is where we're running whilst y is less than 101, not running until x is 100 or similar.
I did mention this earlier, just in case x doesn't exactly stop and 100, which is shit
with this code.
You don't get stuck in an infinite loop.
This is just getting into good practice when we have more complicated code, and x may
not go up by once.
If you save and run this code, you should also get the answer 50, again.
Okay, now let's do a simple number sequence, Fibonacci.
As you may already know, the Fibonacci series is a simple arithmetic progression, I think
will be the phrase.
Basically, you add in the two previous numbers in the sequence, and that makes the next
number.
So we start off with 1, the next number is the two previous ones, which is 0 plus 1,
1, 1, 1, and now 1 plus 1 is 2, so 1, 1, 2, 3, 5, 8, 13, 21, and so on.
So let's actually put a little bit of thought into this program.
As programs become bigger, you will need to think more and more before you actually code
them.
You can just code them straight away, but if you put more thought into it, you can figure
out better ways to do the program.
You can do the loops and things much better this way.
So we'll presumably need three variables for the current number and the sequence in
the two previous ones.
We will output the results onto the screen, and we can loop around by adding up the numbers
in the sequence.
Something like x equals 0, y equals 0, z equals 1.
That's z for all you Americans, z, z, and z in this thing.
While z is less than 100, semicolon, we want this to have a limit otherwise it will
run forever.
Next line tab then, of course, x equals y, next line tab then 1 still, y equals z, next
line still tab then 1, z equals x plus y, and the final line also still tab then print
open brackets, z, close brackets.
Save it and run it and notice the final number when printed is actually over 100, although
we told it to run while it was less than 100.
The reason for this, when you run through the loop for the final time, z is less than
100, and then we add x plus y to get a new z and print that out.
We increment z1 final time and print it out.
Also, if you noticed at the beginning, it didn't print out the first one in the sequence.
It was 1, 2, not 1, 1, 2.
Moving the print to the first command in the loop fixes both of these problems.
So x equals 0, y equals 0, z is 1, while z is less than 100, print z, and then x equals
y, y equals z, z equals x plus y.
This is an important point to make.
It is also why I like to put the increment on the last line so you don't get odd things
where you ask for a sequence up to 100 to get 1 number more than that, and it's the
first number.
Also remember that when we move the variables around, we have to go x, y, z from oldest
to newest, otherwise it would mess the sequence up.
If the x, y, and z lines were z, y, and x, the sequence would be broken because we would
calculate the new number in the sequence and then copy it back to x and y.
Now let's combine the Fibonacci program with asking the user where to start and stop.
We can get the input from the user by using the input command, strangely enough.
It is very similar to printing in that it outputs onto the screen text to tell the user
what to enter, but you do have to set a variable to grab whatever the input.
So let's modify the current Fibonacci program to ask for the starting and finishing numbers.
So we keep x is 0 and y is 0, then we add in the next two lines, z equals int at i and t,
open brackets, input, open brackets, apostrophe, what number do we want to start from?
Question mark, space, apostrophe, closed brackets, closed brackets.
And on the next line, i equals int, open brackets, input, open brackets, apostrophe,
and up to which number should we calculate, question mark, space, apostrophe, closed brackets.
We leave spaces after the end, after the question mark, so the user input doesn't actually
touch this text as we print, doesn't matter anything to the computer, but it makes it
a little easier for the user to read.
And then we have on the next line, while z is less than i, colon, so we amend the hundred
to be i, then print z, x is y, y is z, z is x plus y, as before.
The int command here converts a string input into an integer.
Else when we try to add it, it gets confused because the input hands back text and you can't
add text in as a number.
Hopefully you'll see why I like Hungarian notation, not that I'm actually using it here, of
course, because you get to mark what is text and avoiding adding strings together as
integers.
The result is where that's tr, string commands to convert to a string.
Okay, save and run the program, and it should ask you to start an employees print
hug correctly.
Probably.
I don't actually clean any of the input here, so if you put anything that isn't a number,
it errors.
This is important to do, but I won't cover it just yet for this program, but we'll
cover it later.
As I mentioned before though, we can do a quick while loop around it to run the check.
So now, hopefully, we know all about variables, inputs, and outputs, and looping.
These are actually probably the most used commands overall, so there will be a few more
I'm sure, basically string formatting, but they'll wait until another episode.
Next week, we'll be writing a game of life program.
We can wiki it from more information if you don't know, but basically imagine a field
of plants.
You pick where the plants are sewn, and then they grow following a few simple rules.
If a plant has two few neighbors, it dies out from loneliness, and if it has too many,
it dies out from overcrowding.
If it has enough it, neighbors, it will live or a new plant will grow there.
From these simple rules, some quite complicated things do happen.
I will go over these rules in more detail in the next episode.
The Hacker Public Radio Glider system, the little dots logo, is actually from the game
of life, but I'll explain this when we do it next episode.
We will want to input text from the console to begin with, and then show on screen the
life cycles.
We'll look at reading and writing the information out to a file, as it will be too easy to type
it when entering.
We should also cleanse the inputs to make sure nothing odd gets in there.
We should probably ask for how many life cycles we show as well, else the program will run
forever, and we'll require variables to handle the fields of the plants, and we'll introduce
a new sort of variable called an array.
Arrays are basically a collection of more than one variable, but we'll cover that next
episode.
Until then, if you want, you can try and play around writing a simple game of life program,
you should have all the information you require to write the game now.
Otherwise you can simply wait for my next episode, where I will show how I would write
the program.
Thank you for listening.
If you've got any questions, you can email me at gmail.com.
That's xray oscarciloecho-ciera-oscaromio-uniform at gmail.com, or you can visit me at zook.org xray-oscarciloecho-oscaromio-golf.
Thank you for your time, and you've good listening to Hacker Public Radio.
Thank you for listening to Hacker Public Radio.
HPR is sponsored by caro.net, so head on over to caryor.nc for all of those meetings.
Thank you for listening to Hacker Public Radio.
