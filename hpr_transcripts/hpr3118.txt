Episode: 3118
Title: HPR3118: Linux Inlaws S01E10 The Python Bumper Part 1
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3118/hpr3118.mp3
Transcribed: 2025-10-24 17:13:53

---

This is Hacker Public Radio Episode 3118 for Wednesday 15 July 2020. Today's show is entitled,
Linux in Laws Season 1 Episode 10, The Python Bumper Part 1
and is part of the series, Linux in Laws. It is the 10th anniversary show of Monochromech
and is about 91 minutes long and carries an explicit flag. The summary is
a discussion of Python questions and their answers. Part 1
plus news on bread and alia. This episode of HPR is brought to you by archive.org.
Support universal access to all knowledge by heading over to archive.org forward slash donate.
.
.
.
.
This is Linux in Laws. A podcast on topics around free and open source software,
any associated contraband, communism, the revolution in general, and whatever else,
fans is theoretical. Please note that this and other episodes may contain strong language,
offensive humor, and other certainly not politically correct language. You have been warned.
Our parents insisted on this disclaimer. Happy mum? That's the content is not suitable for consumption in the workplace,
especially when played back on a speaker in an open plan office or similar environments.
Any miners under the age of 35 or any pets, including fluffy little killer bunnies,
you trusted guide dog unless on speed and qt-rexes or other associated dinosaurs.
Martin, good evening. How are things? Good evening, Chris.
Things are great. How about you? Excellent. Can't complain. Beer is stocked,
so we're ready to roll for another episode of Linux in Laws. Season 1 episode,
what is it, ten, right? Ten, yes, still, then. Excellent, excellent, excellent.
So for this episode, we have the usual newsfeed in stock, then a little bit of python,
maybe some funny ramblings, and then it's feedback, and then we're done. I think.
Maybe a lot of python. Depending. Martin had the idea of doing a special on python,
as in special episode on python, so this is what we're doing today.
Martin is posing as a novice, and I try to draw as little as, what's what I'm looking for,
as few blends as possible on the questions that Martin's going to ask me.
And you don't know what these questions are either, do you? I wouldn't have a clue.
A good skill. Same thing with python, so let's see what I can come up with.
So why would you do this exactly? Because this was your idea. I don't know.
Yeah, you volunteered to be the expert on this. Well, as I said, let's see what I can measure up.
Excellent. Okay. Shall we? The news. Yes.
Die right in. Oh, no. The news. What about stackless?
That's not news. That's old news. No.
Okay. No. So what is news? News. Yes. Currently five eight.
A guy called Linus Torvolt. I don't know if that rings a bell.
I think we mentioned him last year. Yeah, probably. Yeah.
I think there's this operating system called linux that he invented more than 20 years ago.
More than 20 years ago. More than 20 years. 25 years in a bit, I think.
Linus, if you're listening, please send feedback. I think it's 92, but we might be off.
Okay. Linus has gone public with the fact that 5.8, which is just basically in the set of release candidate.
It will be the biggest release ever. He says.
Oh, well, until 5.9, surely.
No, if apparently what happened, they did a lot of new functionality in terms of core kernel functionality.
Not just kind of device, but rather scheduling amendments, file system amendments, all the rest of it as part of this release.
So I'm really looking forward to kind of put this into production and see how it measures up.
Also apparently some subsystems, some subsystems were.
How can I put this subject to some performance optimizations?
Uh-huh. Like.
Like what? Well, you just mentioned.
Performance optimizations. What are you?
You'll find the details in the show notes.
No more like five systems. I think I think they did a lot of work on the schedulers.
Both IO and process schedulers.
Sorry for the people who are not familiar with the intrinsic of the Linus kernel.
Schedules essentially take care of running things like user and processes, depending on the state of various contexts.
Like if for example, the program is waiting on IO, need to say it doesn't make much sense to run this program because the program would just be idling.
So if you're trying to read from afar, being for example, LS like list or some application, the kernel will put you on hold so to speak.
While you're waiting for the disk drive to deliver the data.
Um, similar, which in turn has a general schedule indeed. Yes.
Similar with kind of general user space and threats or rather processes.
As we, as probably we all know, Linux is so called multi tasking multi user operating system similar to something called Unix ages ago.
So the idea is being a typical time slot step.
What about next step?
Yes, that's another operating system.
Yeah, in contrast, yes, in contrast to Linux actually next step if spelled incorrectly has the power to summon planet eaters for a long time listeners of the show.
Anyway, going back to, yeah, going back to Linux.
Yes, the idea is of course to give you the illusion that you're using a mainframe or smaller size computer, basically by yourself.
So the, so the way it's done essentially each and every user using a Linux system similar to Unix gets a times a so called time slice for the execution of their programs.
And this is what you see actually if you deploy a lot of applications on the Linux system.
Um, the operating system is doing its best to maintain that illusion.
Um, sometimes slow you down, but still giving up the available process of process in power between the different users and their processes.
So these are the kind of the main approaches to scheduling tasks or processes or threats in Linux.
And other processing approaches.
But, um, there are some optimizations which are going to be revealed in the show notes.
Yeah, absolutely.
Okay.
Okay.
Oh, that's curious.
It's something that's, I mean with the, um, this subsystem, there's a lot of different schedules anyway in first place.
So curious to see.
I didn't pick up on that.
Well, Linux has about what, um, 27 years of maybe 26, um, of development, um, time incorporating it in it.
So that's a lot of time to get things right.
And this is exactly what you see in the, in the, in the, in the kernel.
Uh, because all of the, all of the various subsystems where it doesn't make sense.
Have them, for example, they're on scheduling.
Uh, that goes for networks, uh, for the whole network stack that goes for this, um, that goes for a user-land process and all the rest of it.
Okay.
As a, um, as a Linux user, how involved you get in this kind of changing of schedules?
It's straightforward.
I mean, if you want to give a process a different priority, for example, you use, you use a command called nice.
Yes, directly.
In fact, it's just like priority changing the schedule itself.
Uh, no.
Okay.
No, for this, you need good rights as an, as an, as an admin rights.
And kids don't try this at home unless you want to screw up your system.
Because if you don't, if you don't know what you're doing, you can easily, um, bring a system to its knees.
Yeah.
And this is normally why the user is heavily guarded from such attempts.
For example, nice allows you being an ordinary user, only allows you to increase the nice value that's lowering the priority of your, um, of your process.
Only the root user can actually reduce the nice value that's effectively increasing the priority of a process and, um, and the corresponding threats.
Excellent.
So what other news do we have, Martin?
Well, uh, what other news do we have?
Um, does that have to be open source?
No, it can be anything, just go ahead.
Another data breach perhaps?
No, no, no.
No, no, no, no.
Okay.
No, I do, um, one of the, the news things I, I don't know if it's news as such, but, um, in the, it is very to open source.
But, um, yeah, so, so in our, in our line of work, there are, um, uh, many companies that take an open core, um, project and monetize this, right?
Um, but that's not news.
No, it's not news, um, the, well, the news is really that this continues to happen.
With pretty much any open source project out there.
Yes.
Um, which I'd just like to, yeah, okay, fine.
It's not news, but, um, it's just something that, um, has struck me time and time again, um, over the last week.
So many people are doing this and it kind of goes against the open source, um, well, the idea, right?
Okay, yes.
They are doing features and this thing or whatever, but, um, just like to see your view on that.
Well, I mean, we're both for a work from an open core company, full disclosure.
We are both employed by company called Redis Labs.
Um, well, the money has to come from somewhere, right?
I mean, you can go down the next cloud route, as it just provides a part of, or, or, or even, or even redhead, because that's essentially what Redis is doing.
It just provides a part of professional service training around this.
And then there's the other approach where the open core, meaning that some of the IP would be close source.
And that's exactly what, what, what the likes of Confluent, Redis Labs, um, data, sex and all the rest of them are doing.
I see the merits with both approaches, because at the end of the day, somebody has to pay the bills.
Needless to say, um, companies like Next Cloud and Red have just closed at the communism, like the other ones, because all of their IP is in the open.
Yeah.
Yeah, well, this is, this is it, right?
There are many, well, there are different approaches to this.
It's just every, you know, where you get all these new ones coming up all the time, because every time someone starts a new open source program, then someone has to wait.
There's a lot of knowledge company around it.
And it's kind of, there has to be a better way to make open source, you know, a pro-referator rather than through commercial means.
I haven't, yeah, it's just something, it's not news, but it's something that struck me over the past week.
With all these, with the number of new ones coming along as well, right?
There's, you know, tons of them that are doing stuff based on Druid and stuff based on Apache, Camel, and this and all the others.
Any open source program you can find out.
There'll be a startup around it, trying to monetize it.
Yeah, a bit of a rant about it.
I mean, that's okay. I mean, if you take a look at any enterprise in this current time, as in now, you don't have to dig deep, you'll find open source left right and center.
If it's, and even if it's just the mail system, or the printing system, or, or, or the virus scanner, you'll find a piece of open source in every enterprise no matter what in terms of size, number of people revenue, and so forth.
There's a matter of fact, it's not the debate if whether, whether a company should use open source, just a matter of basically how much open source is a company willing to bet on in terms of, for example, a new product development.
Of course, that also affects the overall ecosystem that they use to develop the apps.
For example, the licensing is pretty determined, determining years, that's what I'm looking for.
It's the determined factor, yes. In terms of, for example, take the GPL, the new public license version 2, version 3, or even for the hyper scale, as the Aurora GPL, as in a more strict version of the GPL.
If you touch a piece of code that is licensed on the GPL, you are supposed.
And there have been many lawsuits on that matter to publish your changes, because that's exactly what the GPL says.
You take, you take the source code, you touch it, you modify it, and then the public has a right to access your modifications.
In contrast to more liberal licenses, like three-class BSD, MIT, Apache, and Amit, that allow you pretty much to do what you want with the source code, maybe apart from the fact that you have to credit the origin or some from others.
But it doesn't restrict the usage of that source code. So if you have this great idea of doing the next big thing, like the new Netflix, the new Amazon, the new eBay,
you don't want to write your stack completely by yourself because you rely on open source components.
That saves you time, that saves you effort, that saves you manpower.
But, and this is very important, but you want to make sure that you pick the right components in terms of the license restrictions, fit your business model,
deployment options.
If you are putting a piece of code that is especially license under A and a thorough GPL, you cannot use this basically to run in your cloud.
Same goes for example, I'm sorry, I have to cut this out because the address is slightly more complicated.
This example, Redis Labs has something called a source available license.
Being a hyperscaler, you cannot take a code based license under this and put it into your cloud.
It restricts the usage options and there has been a big debate about this in the OSI circles and so forth.
There was a first time talk by Chris Lamb and friends about contributing to Redis module code bases that make the rounds.
As I can see, I can see both sides because the money has to come from somewhere because what the lives of AWS and friends do.
And Microsoft and Google are probably accepting the exceptions that prove that rule because if you take a look at their track record, they tend to partner with these open source projects and companies behind them.
I'm confident and Redis Labs are probably being the best examples, never mind MariaDB and so forth.
Yeah, but Amazon being the old one out there.
That's exactly it and maybe even software or what's now IBM Cloud or even Oracle.
They take the code base, they put a managed wrapper around it, they charge for it, but they don't give anything back.
Yeah, exactly, but also they make their own improvement and changes.
If you are serious about this stuff, you should be doing that rather than, and it's the same with even consumers or open source in large enterprise in my opinion,
they could be instead of paying vendors for support and so on.
They could also be contributing to the projects and keeping them going that way and improving them rather than going for a pure consumer model.
How much has AWS contribute back, or sorry, Amazon, back to the Redis code base in terms of making it compatible with the HAPS data infrastructure?
I cannot see, I cannot see, I cannot recall seeing any pull requests here.
In contrast, Microsoft, of course, the being, any contribution to Linux kernel because it was under different license mode,
because since I think 94, Linux has been under the GPL, so Microsoft had to push any changes back into the code base.
So any changes that they made in order to have the kernel running on something called Azure, they had to come back from a legal perspective,
but then the problem with the fact that Linux is there to stay, whereas Windows and the server board in production, zero still out on that.
But then Microsoft is changing in a very big way.
Speaking of Python, I think they at least employ one or even two core contributors to something called C-Python,
which is standard reference implementation for Python on any platform,
but that's OSX Windows or Linux and derivatives.
And if you take a look at the open source code base, it's growing all the time.
PowerShell, probably being the best example, PowerShell Core, is free and open source.
Visual Studio Code, next thing.
Yep.
Agreed.
Good points there.
But yeah, it's all yet to be resolved in a satisfactory manner, right?
There's the two camps and, well, it's more than two, but there's a, amongst the cloud vendors,
there's a lot of the two big ones, and the enterprises out there don't really seem to care
about the ethics of these companies today.
Until we order fewer books.
Well, I think they've done quite a lot of the current situation.
Indeed.
Okay.
Martin, what was the thing cut something?
Cut.
Okay, not cut.
Anyway, I've got edit this out.
Okay.
Fair enough.
Let's start with the what this Python thing Martin.
Why don't you explain to us what Python really is and where you are in your learning curve?
What's the last question?
Okay.
Well, I can do that.
That's fine.
Right.
So where am I my learning curve?
Well, so I have a slightly different approach to yourself, I think, to many of these things.
What's my approach then?
Well, your approach is to, let's say, take everything apart into the small detail.
Is that correct?
Yes.
Yes.
Yes.
I think it's somewhat accurate description of my approach.
This is why open songs are so important because it can take the Python thing apart
and put it back together again because the song is available.
Martin, on the other hand, apparently just likes to run things and then wonder
us about why this shit doesn't work.
Is it because it's open songs?
I know.
This only applies to post audio in some way, not on this.
Oh, my God.
What were we?
So, yes.
You were describing your more user-learned focus approach to software?
Indeed.
Indeed.
User-learned focus approach.
Yes.
So, from a programming perspective, went to many iterations, many years ago, obviously.
I was interested in a kind of, yeah.
And it struck me, also, we'll come back to this later in the Python questioning section.
I've always been more on the functional programming side, personally, but there are many
and different options here.
So, anyway, go back to Python.
So, as a purpose, it's easy to deploy.
It has a large package and library available for many different things.
It has had the more you do with it, the more you kind of realize how powerful this is,
and also how much programming languages have moved on since the 1980s.
Full disclosure listeners.
If you look at Martin's LinkedIn profile, you quickly notice the fact that he has been
for most of his professional life dealing with databases.
Meaning, yes, you are listening to an SQL fanboy who coped onto the fact that SQL
does not contain a go-to statement.
This is the important thing.
As a matter of fact, Martin, what I noticed is actually that you have been
administering Oracle database for quite some time.
Yes, that is part of my working life.
This is just a kind of full disclosure thing before we enter the Python realm.
Due to the length of the original Python discussion, this session has been split into two parts
with the first part following now.
Catch the next part in the next episode of Linux and Lars.
Okay, that's fair, that's fair.
Yeah, so Python Oracle didn't really feature too much together for a long time.
Even though Python has a language, these are quite old.
How old is it Chris?
I think Gido devised around early 90s, 92 and 93 maybe.
So we're looking at 20 plus years easily.
There's a Wikipedia page basically outlining the first commit I suppose.
For Gido from Russum, if you're listening Gido, good work, well done, keep it up.
It was a summer project that he did, but it was still at university.
He was in charge of looking for a new language and he took a look at what's out there
and then came up with his new language better suiteding his needs.
And the hence, Python was developed.
And the name of course does not come from a big snake, but rather a commonly true called Monty Python,
of which Gido from Russum, at least that's common lore.
It's a big fan of, yes.
What if Frank is a fan of Monty Python?
I do not know. Let's tackle this once we go to feedback.
Sorry. Right.
How is that for an introduction? What about your own experience with Python?
We used Python during the, when we were looking for an implementation language
for some of the QA harnesses when I was doing my PhD back in the early kind of mid 90s
at a university called Trinity College Dublin in Dublin, Ireland itself.
This is also when I first encountered something called Linux, which has been...
I was going to say Guinness, but...
No, Guinness came before this.
But I've been using Linux ever since in some form of fashion afterwards.
So, actually Linux, not Unix, or is it?
No, Unix, I encountered mid 80s when I was studying computer science at various universities
and schools, so to speak.
But Linux, we used as a platform to develop and test our experimental microchannel architecture
that the research group was working on where I did my PhD.
And this is where I also basically made the choice between Perl and Python,
because Perl wasn't delivering the goods in the fashion that we require them to be.
So, we resorted to Python to write much of the QA code for the kernel.
I almost forgot about Python until I rediscovered, so to speak,
late 2000s in terms of 2008, 2009, where I was looking for a programming language
to do quick and dirty prototyping with, and I've been using it ever since.
And also kind of observing, let's put it this way,
the growth of the ecosystem around that language,
because for me, Python means similar to other programming language
with a corresponding ecosystem.
If you have a problem, you take a look at packages that are out there already
and simply write the glue code that is missing to achieve the required functionality.
Best example, a couple of years back, a friend of mine had about,
how many restaurants were it?
About a couple of 10,000, maybe 20,000, maybe 30,000 restaurants,
as in schedule routes that were stored in Excel spreadsheets.
And he wanted to convert these to Google Calendar entries
for whatever reason.
So he shopped around and a consultancy quoted him at least seven days,
FTE in terms of full-time equivalent for somebody to sit down and to develop this.
He rang me, I sat down, did some research.
I came up with something called Libra Office.
Libra Office has a Python interface that is, let's put it this way,
with some syntactic show on top of it in terms of another module,
you can simply extract data from a spreadsheet that is in commerce-operative value form.
So we simply wrote a small batch shop that simply converted the Excel spreadsheets into CSVs,
or as a matter of fact, I think we didn't do this, because Libra Office was already then able to read them
as an XLS X files.
Then the Python program extracted the values via this module, or while it's packaged rather.
And of course, the Google Calendar has a Python API.
I wrote the code within two hours, another hour of testing, and the whole job was done within the afternoon.
Because once I was able to convert one spreadsheet, there was simply a for loop around the number of files
that were stored in directory, and the whole thing, as I said, was done within the afternoon.
So it was exactly the spirit that you should use when you're writing applications of it,
because it's open source.
So you are standing over the shoulder of giants, as in code basis,
that other people have written for you, that is available on GitLab, on GitHub,
and other places where you normally would look out for these.
And of course, all of these program languages, including JavaScript, GoLang, Python, Rust,
have their own module ecosystem, and for Python, of course, it's the Python package index, also known as P, as PyPy.
So my first order of the day, what I normally do is actually to take PIP, which is the front and for PyPy,
and search for modules that I'm able to use if I want to write something.
Then I download the packages, and then as I said, simply take a look at the API specification,
and simply write the glucose that is missing.
Yeah, so, okay, let me ask you a question.
Your example is, for example, which you could do all the same functionality with Linux native tools.
But I think your argument is that it's a little easier out there to do this Python,
and there are modules available to do that for you.
Yeah, I've yet to discover a good package manager for Bash.
I think there's something out there for PowerShell, but given the fact that I wouldn't call myself a PowerShell expert at all.
I know that there's chocolatey and other package managers for Windows.
Maybe the same goes for PowerShell core, which is also, of course, also available on Linux.
But as I said, I haven't done this, but I would use Bash only for kind of smart code bases
with a limited amount of functionality, because other than that,
you're way better using a real program language.
And before we get hate mail, guys, yes, Bash is a real program language.
As other shells, don't get me wrong.
It's just the case that many people just use Bash for simple tasks.
So that's my take on the situation.
That's fair point.
I mean, as you say, for fairly limited small pieces of code,
which don't require pulling in functionality, like reading an Excel specific format,
then, yes, you wouldn't.
You can stick with Bash, right?
Good stuff.
So Martin, if I can ask you a question, given the fact that you've been learning Python for the last six months,
what was your?
I wouldn't say that.
I can recall opening up a piece of rotten fruit on a Saturday morning
and having some sort of inquiry in my inbox about a recommendable Python literature
about a year ago, make it one and a half.
Okay.
By a guy called Martin Visser.
Right.
Also known as one of the co-hosts for the first time, because it's lost.
Revisit this post.
Yeah.
So I'm still waiting for a proper note-taking facility for polynics,
but you know it's taken from the facility.
Does something called leaf pad?
Yeah.
Well, one that doesn't require signing up to some centralized services.
No, leaf pads essentially just a small text editor that stores files locally on your hard disk.
Yeah.
Okay.
Well, so let's be honest.
Okay.
If you're looking for a more distributed approach, you want to check out something called ESA pad?
Yes.
I had a quick look last time.
I mean, we'd had a good progress, but I did look at it.
But we digress.
The examples you gave me.
I haven't been impressed so far.
Okay.
Sorry.
We can cut that out.
Well, either papers are in JavaScript, yeah, that's right.
Yeah.
Right.
So now then, what did strike me about Python was that it has a paradigm for pretty much,
not once in all of them, but many different programming ones, right?
So how did that come about?
Was it just because people were all like object owners, so I'm going to put a bit of that in Python as well?
I don't know.
But it lacks a go-to, right?
So imperative only goes so far.
AC.
Okay.
I think the idea, and I cannot, of course, speak for Fogido.
As in Gidoforossum, we've been a volunteer dictator for life who invented the language almost 30 years ago.
That's a lot of work.
Could be an M in there, shouldn't it?
Yes.
But I think the idea was basically to take a look at what's out there and just to provide a better program environment.
So he took imperative paradigms.
He took optical paradigms.
And yes, it took a great deal.
And Gidoforossum, if you're listening full marks for these functional paradigms.
Lambda is probably being the prime example here and moved to the new programming language.
Interrupted based.
But we get to that in a minute.
That addressed requirements at the time.
And the language has evolved an awful lot.
For example, there's a Python version 2.
And there's a Python version 3.
But again, we come to that in a minute.
I think Python 1 is obsolete.
But there was one.
I think so, yes.
I mean, you're talking ancient times here.
Okay.
So yes, and there are difference between Python 2 and Python 3.
So Python 3 is not necessarily backwards compatible Python 2.
The other way around, to a certain extent, it is because there's something called a future package.
That you simply import and that addresses the most prominent difference between 2 and 3.
But the idea was to provide a language that is concise, functional, object oriented,
without the deficits of the prevailing programming language at the time.
Like Pearl, I'm almost tempted to say.
And other, maybe even scripting languages.
I think that is the philosophy behind Python.
You would see this as a kind of a contestant, probably being the best example.
Python is probably the people know who have used Python already.
Forms blocks by indentation.
So the more you indent, the deeper your block level is where you program.
So you don't have curly braces, you don't have do, you don't have done statements like you do in other programming languages.
Like C++, C, Rust, Pascal, modular 2 and so forth.
You simply form blocks by indentation.
And that's it.
Okay, so the argument about that is readability.
Exactly.
By looking at a constructor, you exactly see where block starts and where it ends.
You don't have to look out for curly braces, for example.
Yes, however you can do matching, can you, like you can with curly braces or your do-done so easily.
This is where proper IDE comes into place because an IDE will do that for you.
You have an IDE is not a language, right?
What do you mean?
Well, I mean, okay, the IDE.
But if you, okay, so if you, I don't take a do-done example, right?
If you, you grip for your do-use, you grip for your dons and you can see if there's one missing, right?
You couldn't do that with a piece of Python because you need to, very easily.
But I mean, you know exactly where the indentation ends because you'll see this.
Yes, but you can't grip for it, for example.
Why do you want to grip for it?
Well, if you're debugging or something, you know.
Do you know about a module called PDB?
I'm just wondering.
PDB.
No, no, no.
It comes with any Python installation and it's a debugger.
Is it something to do with debugger?
Yes.
It's a module that is part of the Senate library and you can do debugging on your command line right away.
Okay.
And that's supposed to be anyway.
Packages, modules, functions, line numbers, you name it.
Cool.
And of course, for the hipsters, among the listeners, you can use PyCharm.
You can use IntelliJ plugins.
You can use Eclipse plugins.
VS Code.
VS Code, of course.
Even I think the Python mode in Emacs has a debugger interface.
Oh.
For those of you who are tired of using them.
I'm just saying.
Okay.
That's too much complexity.
Yes.
He makes a stretch forward.
I know.
Okay.
Excellent.
So that was really the, yeah.
Why so many of those different programming paradigms was a good idea at the time.
By Gideon.
But I still think he did a very good job because only 30 years on.
The Python is, if Stack Overflow and any other service, I need to go by a very popular language.
Uh-huh.
Yes.
Similar to English, Italian, maybe even American or Spanish.
Americans that are language.
I think it is.
Yes.
Maybe I'm wrong.
Okay.
Yeah.
So that kind of brings me on to the related point, which is.
Okay.
It's popular.
Uh-huh.
But will it remain this way?
And is it necessarily a good thing?
Right.
Um.
Yeah.
Take Java, right?
Remi, Java.
It was very popular.
And now it's on the decline and so on and so on and so on.
I wonder why.
Why don't you tell me.
How much time do we have?
Yeah.
Luckily, I avoided all the Java.
No.
I mean, at the end of the day, program language are like cars, women and men.
You know, the one, you know, the fruit.
Yeah, fruit, maybe.
You know, one of them, you know, them pretty much all, but they do differ.
That's important that I'm making here before we get any hate mail.
Wow.
Yeah.
That's a bit of a bad generalization.
Yes, indeed.
Very much so.
No, they're all self that purpose goes without saying.
True.
Yes.
So, um.
The likes of Kim Kardashian is not necessarily comparable to the likes of Maggie Tatcher.
For one of the better comparison.
You get the idea.
Anyway, no jokes aside.
Um, one of the, it's a couple of traits that makes it not necessarily unique, but, uh,
definitely put it this way.
For example, it's a script based language.
So you don't have a compiler in place per se.
There are compile based implementations.
Like blipy and other stuff that deploy jits as in just in time compilers.
But, um, the standard C part implementation is a script is a scripting engine.
So it takes a source code.
It pauses it.
It constructs something called an AST and abstract syntax tree, which is then translated into an into an intermediate language,
which is then interpreted by something very similar to a JVM as a, as an a Java virtual machine.
Only because it's not Java.
It's not a virtual machine in terms of, uh, it doesn't have the complexity of a JVM.
Uh, but the interpreter that works on the generated code is in functionality very comparable to the JVM.
Um, they have been multiple other approaches to tackling this problem.
Um, because doing it that way has a certain performance issue.
Mm-hmm.
Of course.
Um, so, uh, for example, there's something called nukka, he doesn't show notes.
There's something called pi pi.
There's something called sithin.
Um, that basically take your, uh, that basically take your Python code and translate this into machine language in one shape or another using various approaches.
Um, there's also, for example, something called jithin.
I think it's called that takes your Python code and transforms it into form that the JVM can understand.
So you are able to execute Python on your J, in your JVM ecosystem, which comes in handy if you're a Java fanboy, I suppose.
Except that you're not writing a Java.
Exactly.
Yeah.
Yeah.
So, yeah, I mean, uh, and the things like garb's collection come with that as well, obviously.
Um, but, um, yeah, so if we, okay, so the scripting, it's, what's it good for?
Right?
It's good for, um, past development, uh, prototyping, blah, blah, blah.
Um, if you, however, were to write a, I don't know, say a little level driver for something he wouldn't resort to Python.
Not necessarily, no, because that for that, you would use something much more, much closer to the hardware, like, see or maybe even rust.
Yeah.
So, so if we talk about the advances of Python, what would you say they are?
Well, the comprehensive ecosystem comes, that immediately comes to mind.
I mean, there are significant code bases written in Python, um, not necessarily open source.
Do you know, company called Dropbox?
Mm-hmm.
Dropbox, if you take a very close look, both the server side, but you don't see, but the client side, even, is implemented in Python.
So, it's cross-platform, it works on your Mac, it works on your Linux system, it works on your Windows system.
But under the hood, it's still Python.
Okay.
Um, fun fact, Guido is after working for Google, Guido defected to Dropbox being the benevolent dictator for life.
I should probably, um, explain what a BDFL is.
Yeah.
A BDFL is somebody who gives a project direction.
So, Guido invented the language, Guido is still, although he stepped down as the main caretaker of Python,
Guido is still drives the direction, drives the roadmap for the project.
Although, um, like with any, like with any other large project, Python is at the end of the day a community project.
So, let's, let's, basically, let's take a look at how the language is developed.
You have something called PEPS, standing for Python enhancement proposals, uh, where simply people describe what they see as the next big step for Python.
For example, there's a very famous PEP404. Martin, does that ring a bell?
Don't know, let's say a female, I don't know.
Uh, very close, yes.
PEP404 means, uh, page not for a completely mistaken.
For Python, it describes the state of development and the timeline for something called Python 208.
Okay, cool.
Martin slowly discovers what this is all about.
PEP404 explains that there won't be a Python 208, but rather the development will stop at a point in time.
Continuous, uh, increase of positive.
Something along these lines.
And then all the code bases should be shifted or to be, or should be more rated for, uh, to use that expression to put to something called Python 3.
Because Gido and friends clearly saw the benefits of not having to maintain two different versions.
I'm exaggerating, but you get the rest of a language in parallel.
And that point in time was actually the first of general of this year.
Um, quite a few major distributions that had probably been the best example have decided to continue to maintain Python 2.
Uh, the Python 2 code base for the, for the respective distributions.
So, for example, red eyes, red had still backpots, security fixes to Python 2.7.
Yeah, when you say maintain, you mean, uh, yeah, bug fixes.
Yeah, yeah, yeah, bug fixes and security enhancements, no new functionality, of course, that goes without saying.
Um, the idea, of course, is that quite a few of, especially the larger customers have millions,
if not billions of lines of code written in Python 2.
So, so that's a significant investment.
And as you can imagine, migrating this to Python 3 is a significant effort.
So normally we do this, um, in a face approach, but given the fact that pep 404, I think dates back to 2008, 2007.
If I'm going to, if I'm completely mistaken, pep 404 to the majority of the people in 2019 was pretty much like Christmas.
Nobody told you it's going to be there, but all over sudden, all overnight, just overnight, it's there without you knowing it, right?
Because just, just because of the fact that 10 years ago, somebody told you, sorry, we won't develop this any further.
And the first of general 2020 is the absolute debt hunt for this.
Hey, you couldn't care less, right?
Sounds a bit like Brexit.
Very similar, yes.
So, so the idea is, of course, that everybody really kind of had a clear migration strategy that started to plan in 2015,
leaving them, say, five years time to meet that line, but rather discovered the fact that, oh, yeah, pep 404 was out in the open for at least 10 years,
but we couldn't care less, but now we have the shit load of a code base to maintain, so what should we do?
Especially given the fact that it's open source.
And if it's not maintained, that leaves a pretty decent attack surface, meaning that if you do not back part security fixes,
your Python code base, written for Python 2, tends to increase invulnerability all the time, especially if more and more zero days,
as in security issues where there's no bug fix yet developed before, see the lot of day.
And that's exactly the issue.
So that's the reason why, as I said, why the likes of Red Hat and so forth decided to back part security fixes on other big fixes,
so that the attack surface still can be maintained on a minimal level.
But anybody out there is strongly advised, and I'm almost tempted to name a company very close to our hearts,
probably to be the prime example here, to get their shit in order in terms of getting a migration strategy in place,
if not already executing on it, to move all that Python 2 legacy code to Python 3 immediately, if they haven't done this yet.
Yeah.
Because going forward, you will just see the security issues increasing out in the wild, especially if you're developing code that is customer facing, internet facing,
you want to have your house in order, simple as that.
As in supplying it with a product that you're selling.
Okay, sorry, before we continue on the Python 2 and 3 discussion, I want to go back to the BDFL topic,
because essentially, Gita was running a product on his own until he stepped down.
No, he didn't.
Well, okay, what did he do?
Let me take a look at the mailing list. It has been always a community effort.
Gita, of course, had the final say in matters.
Well, this is, yeah, this is the D for dictator, right?
But I mean, if you take a look at the PAPS, the PAPS have been written by the community,
and the whole approval process was done by the community, but yes, but Gita still had the final say.
And I think that was the cause for what was it?
571572?
Okay.
That caused him actually to step down as a BD.
No, yes.
Yes, so now there is a committee doing this.
There has always been a committee.
It just...
No, no, no, no, no.
It just didn't.
Gita had the last say.
Yes, yes, yes, yes.
But now the committee has the last say.
I think so, yes.
But this is the whole point of the...
Yeah, stepping down activity, sure.
There's something called the PSF, the PI and Software Foundation, which is now a formalized body.
Not to sure if the committee is now a part of the PSF, because I'm not really that involved with the general against going on at the PSF.
But the PSF is essentially in charge of maintaining the package index, as in PAPI, doing events.
So, like, for example, the PICON would be organized by the PSF or the subsidiaries.
And, of course, funding various activities around the language.
Like maintaining Python.org and all the rest of it.
So that would be the prime purpose of the PSF.
And, of course, the PSF is sponsored by the likes of the big...
The usual suspects, like the likes of Microsoft, the likes of writes hell and so forth.
It's a community body, essentially.
Tasks with promoting the language, standard lives in the language, and keeping the shit together.
Okay.
Next one.
I'm still confused, I don't know.
The listener's Martin is easily confused.
But that's okay.
Yeah. Well, either someone, Guido makes the decisions or someone else does now.
That was the point of stepping down, otherwise.
Yeah.
As I said, the community is...
I say, they had a committee before, but Guido, we're in part of the committee at the final say.
Now, it's a much...
I wouldn't say much more democratic effort, but it's more a group effort, let's put it this way, of deciding.
Because the BDFL is essentially gone.
He still works.
In the background, you'll see this with...
What is the pep for this PEG parser?
Sorry, people.
Python3.9 will have a PEG parser in contrast to...
What is it?
The existing LL1 parser.
And this is, I think, outlined in the pep, let me look it up.
596 talks about the 39 release schedule and the pep for the parser is...
Yes, 617.
So, 617 is the improvement for C Python, as part of the Python release 3.9.
Where Guido says, let's replace the LL1 parser with a PEG parser.
And this pep is written by Guido from Russell himself.
So, never mind the fact that he stepped down, he's still involved in the development of the language.
Indeed, indeed.
Because that pep, actually, I'm just looking at the pep page, was created.
No less are the 24th of March this year.
So, more than a year, after he stepped down, it's from the completely mistaken.
Okay, good stuff.
Yeah, so, I mean, I'm not disputing the fact that he's not no longer involved.
He is not still involved, but more the final approval of pep's render is now a different process.
Yes.
It's much more community oriented, that's correct, yes.
Yeah, okay, cool.
Alright, so, going back, where were we?
Yeah, so, Python 2-3, we touched on reasonably.
So, I believe there's also utility out there.
Have you had any experience with that?
Yes.
2-3, it's called.
Essentially, it's a pluggable framework of helping you, or for helping with migrating your 2-3 code base on a more or less automated fashion.
It takes care of the most prominent suspects for you automatically.
For example, the main difference between 2 and 2 and 3 is depending on your level of knowledge and your background, of course.
Print is a statement in Python 2, and it's a function in Python 3.
So, in Python 3, you have to decorate this with braces, because it's not a statement anymore, otherwise Python will bark at you.
This is the level of automation that Python can take care of.
As with any other automation tool, it has to be taken with grain of salt.
Yes, it will take care of the most prominent differences for you automatically, but you're strongly advised to do a proper code base review afterwards.
Making sure that not only the syntax, but all the semantics are changed.
Another big thing is, of course, for example, between Python 2 and Python 3 is string handling.
Python 2 treats strings as a sequence of characters, pretty much like C, whereas in Python 3, strings are UTF-8 collection of characters.
Because sequences of single 8-bit characters would be represented by bytes, like a byte array, or a byte sequence.
So, it's that level of detail that you have to watch out for, and of course, as usual, the devil lies in the details.
So, 2 to 3, yes, can help you in awful lot, especially in the fact that you just give it a directory, and it simply takes a look at the Python files in that directory, and then converts them one by one.
But it won't help you with doing a full system duration test, never mind user acceptance, before you deploy this in production.
So, tools only go so far, people. As usual, human intelligence has to be applied afterwards.
Yeah, no, that's very sensible. I mean, as you say, it's the same with any automation tool.
It kind of comes down to how have you built your pipeline of development?
Absolutely, yes. How you automated that?
So, do we think that you will ever die as such?
Yep, it's penciled in for the 24th of March, 2020-24, and I think that's a Sunday, if I'm not completely mistaken.
I might be wrong on the particular weekday, but that's the point in time when Python 2 definitely will die.
As part of C-Python, as in the standard implementation, the reference implementation will cease to function on that date if I'm not completely mistaken.
And of course, that's my attempt at humor for those people who missed it.
No, it basically wants down to the fact that how many companies are willing to maintain a dying codebase in terms of the Python 2?
C-Python reference implementation, because C-Python, and that comes with any operating system that Python supports, is your standard implementation.
You find this on Windows, you find this on OSX, you find this actually on Linux, and other unique derivatives.
This is your reference implementation that will work on any platform.
And it's just a matter of how willing are people to put effort into this codebase for Python 2 because it's dying.
There won't be any functional improvements, only security fixes and bug fixes will enter the codebase based on your distribution vendor.
Yeah, okay.
So we're saying, well, let's say C-Python being the reference implementation.
C-Python is out there.
Oh, yeah, I think I touched on them already.
You have something called Sighton.
First, of course, you have the just down compilers.
And then you have other language ecosystems aimed at different execution environments like, for example, Gython.
There's also something called Iron Python using a similar approach.
I mean, they all have their advantages and disadvantages.
For example, there's something out there called...
What's it called, Martin?
What do we talk about?
Is it right? You mentioned something called Stack.
Stackless.
Yes, sorry, yes.
Stackless.
Stackless, Martin discovered the fact that Stackless is just another Python implementation.
But in contrast to C-Python and similar to other Python implementations, it only maintains a certain version of Python.
So the trouble, of course, with the other language ecosystems is that, in contrast to C-Python, they may only support Python 3.1.2.3.4.5.
But only C-Python, because its reference implementation has the news language standard implemented.
So what were the subject of Stack Exchange, Martin?
Why is that important for you?
Stackless.
Stackless.
Sorry, yes, not Stack Exchange.
Stack Exchange is something different.
It's something...
Why is it important to me?
Okay, so, yeah, three ways of doing panel processing, multi-processing, whatever you want to call it, making use of CPU cores in Python, right?
Threading, multi-processing, not potentially async.
Async, I would really help you with paralleling jobs so much.
Does it not?
Okay.
Are you a mute?
Well, I was asking the question.
Hey guys!
It doesn't necessarily mean that I can't ask back, right?
Yeah, that's my third thought.
Okay, okay.
Why doesn't async go with parallelism?
Why doesn't async go?
What's the...
Why doesn't async go with parallelizing your application?
Well, okay.
We are...
Okay, well, in my view, it's purely about whether you wait for the response or not, right?
So, how is this actually parallelizing something on multiple cores?
This is a very important differentiation, people.
Okay, let's take a quick step back and let's take a look at the difference between processes, threats, user-demo-threats,
and something called core routines.
Okay.
You want to give it a shot, Martin?
Or should I take it from here?
I'm the expert.
I'm the expert.
Okay.
I will come in.
Yes, exactly.
Please do correct my biggest mistakes in the following explanations by all means.
Okay.
You have something.
The term operating system brings about.
You've probably heard about this before.
The next step is...
Yes, yes, yes.
But so, like Linux and other operating systems, exactly.
And operating systems tend to have something called kernel.
The kernel is in charge of driving the lower levels of the system, like talking to the hardware,
also very important, allocating CPU slices to something called the user-land.
The user-land, of course, is where applications live, like the shelves, like the IDEs of the world,
like your Python code that is executed by the CPU.
Okay.
Yes.
Right.
I mean, these are just processes.
Very important.
Yes.
Okay.
Martin, what is the process going back to your uni days?
A process consists of what?
Well, it depends, yeah.
No, it doesn't depend.
No, no, no.
It doesn't depend.
A process is an abstract concept.
Let me rephrase the question.
Not necessary.
It's the same.
It's a minute's process.
Let me rephrase a question.
What does Linux, a process and tail?
Well, it's basically an executable that runs on a...
That's part of the CPU allocation for running, right?
Almost correct.
It Linux, like other operating systems, especially the ones that are able to do with
virtualized memory, consists of something called an address space, a set of registers,
especially an instruction pointer, a stack, and what did I miss?
Yeah, we forget about the likes of our...
Yeah, I was talking about the internals of a process.
Yes, and now the important bit, one or more so-called threats.
Okay.
And this is the important bit, people.
This is all you need, because a process in Linux and other operating systems is an execution
context.
So, typically in the olden days, before the invention of threats you had in a typical
Unix process, you had a virtualized rest base, you had a set of memory pages, and the rest
was essentially residing on disk in something called a swap space, and you had a program counter
and set of registers.
This process could be interrupted at any time by the kernel.
Going back to my earlier description about slices, that's exactly how you implement a multi-user
operating system.
And then OS2 and other hipster operating systems came along and invented something or brought
something with them called threats.
Now, you did have more than one execution context per process.
And Windows NT being the copycat, essentially took this from OS2 and implemented this in Windows.
But then, POSIX came along and implemented this for other operating systems as well.
So, any other, sorry, before they hit us an email, POSIX of course being a standard, people wrote
the standard so as implemented, implementers could implement POSIX compliant interfaces for this
functionality, just to be correct here.
So, essentially the white works is basically a process, and that goes for Linux, that goes for
OSX, that goes for Windows, and any other new or modern operating systems.
A process has still a virtualized or an address space in general, has still a set of registers,
but now has at least one threat.
You can have more than one threat, meaning that you have to synchronize them accordingly,
because they all run in the same address space.
And if they want to do concurrent accessing of, for example, of one particular address,
that access has to be synchronized, because otherwise you will have race conditions and other fun stuff.
For those of you who have ever used threats, you know what I'm talking about,
so that introduces the whole notion of concurrent programming, including locks, semaphores, signals, you name it.
They're all present in Linux, and they're all present in Windows, they're all present in OSX.
But the important thing is that a threat at the end of the day is still a kernel entity.
The kernel knows how to create them, the kernel knows how to schedule threats,
even running in the same address space, and the kernel knows also how to end threats if the application doesn't do it.
Similar to the way a kernel knows how to create processes.
This is the important distinction.
So if you want to, for example, if you have a blocking threat,
just imagine the situation where a user length threat blocks.
On a system called in your application, the kernel takes away the processing time
while this threat is blocking and allocates the CPU's lives to a different threat,
maybe even in a different application.
And now the main distinction between something called tasklets, green threats, or even core routines is,
that these entities are purely driven by the user length.
The kernel doesn't know about them.
This is the main difference between moving it up a level.
The main benefit of the letter approaches, of course, you do not have the expensive context switch.
Because if you want to reschedule a threat, the CPU has to enter the kernel context,
the kernel has to make an important decision of whether to suspend the current threat
and resume a different one, and then to resume execution of that threat or a different one.
That means, always, you basically enter the kernel address space.
That always means a context switch, and from a CPU, the scaling perspective,
that's a very expensive operation in terms of microseconds that you're spending with it on this.
In contrast to this, user-level entities, like green threats, like core routines,
like tasklets, you name them, or what's the abstraction goal I can't even remember.
It's not channels, but something similar.
These are purely user-land entities.
The kernel doesn't get involved.
The language environment, as in the Python case, takes a decision of how to schedule them.
That makes these entities, in comparison to operating system threats, pretty damn fast.
Because you don't have to enter the kernel, you don't have to do that context switch
into the kernel address space.
This is the main benefit.
And core routines in the shape of async.io, in the shape of tasklets,
as in interviews, pastectlists, and all the rest of them, are just the sample for this.
So, if you do an A-weight in Python, if you're prone to async.io programming,
this A-weight is actually handled by C-Python itself.
The kernel doesn't see it.
This is important.
Yeah.
That's very well explained.
Excellent.
Okay.
Now it's time, I think, for the feedback.
Okay.
Do we have feedback?
I think we do.
Yeah.
Marketing got in touch.
And essentially, yeah, the listener survey is back.
Sales wasn't too impressed with the whole New York debacle.
I'm sure you heard about this.
Do tell.
Yes.
Somebody from...
You see, this is the problem Martin, right?
If you set up shop,
that north of Central Park, as in Harlem, the Bronx isn't too far away.
Okay.
There's a bigger picture of all people here.
About a year ago, Martin had this grand idea of,
we need an outlet in New York City.
So, we got the...
We got the board involved.
We ran the numbers, checks out.
We go there.
Martin is under the impression we need some sort of outfit in Williamsburg
as in Brooklyn because this is where the hipsters are fair enough
or even lower Manhattan.
And I says, no, Martin, this is going to be pretty expensive.
We need a mortgage and we need a credit card for this.
This is the important bit, right?
So, we visit a couple of banks.
And this is basically where the real shit starts.
We are facing this lady about late 30s, maybe early 40s,
about 200 pounds, but all in the right places.
We get...
Well, I got her down to about 9% annual.
And right from the point when we walk into the room,
she gives Martin the look.
She eyes up Martin.
I mean, I wasn't even in the picture.
So, we sat down and constantly she's trying to connect with my beloved co-host.
Only to hear and listen to this people.
This is great.
Only to hear these famous words, I do not do overweight middle-aged women.
Let this sink in.
Martin at the meeting, I trust these famous words, you're not my type.
Rather than saying, I'm happily married or the wife wouldn't approve,
but in brackets, I would.
So, Martin, this is what is known as taking one for the team, right?
Which you didn't do.
Isn't that your...
Sorry.
No, Martin, I had to do this.
As a matter of fact, I had to take three for the team.
Only to get a decent mortgage out of her.
Good job, that man.
Okay, because of this mishap for one of a better expression.
Of course, quite a success.
We ended up with an outfit in upper Harlem.
And of course, the Bronx isn't too far away.
So, you get all these blown-ins and they wreck your outfit.
So, sales wasn't impressed.
But how did it end up here?
Yes, Lisa survey, exactly.
Yeah, sales complained about it.
But anyway, feedback.
Yes.
According to the marketing department, we have about six and a half listeners these days.
And Claude, you being one of them.
I think.
Well, he was until last night.
Well, actually, no, he sent a mail saying, good job.
I really like the review of the review.
I don't know whether it's a threat or a promise.
I could be so honest.
I see.
Okay.
Oh, are we expecting the review of the review?
Yes.
Also, the focus groups apparently are doing pretty good job.
Yeah, they came up with Haskell as the next language review other than Python.
How good are your Haskell's skills, Martin?
I heard it mentioned you're the same.
Okay.
So, we got it.
Nice.
So, one goes, that can't let's take turns.
So, I'm going to ask you what Haskell next time runs.
That's only fair, right?
You never know what these focus groups are good for, right?
No, I mean.
Okay.
And all joking is highly.
No, seriously.
I mean, yeah.
I did come across someone who mentioned Haskell for better.
No, I mean, seriously, I mean, marketing came up with these grand proposal focus groups.
And I think they worked out quite well so far.
Sales may have a different opinion on this, but sales also is on the opinion we could libate lots of money
in places like New York, which if you take a look at the numbers,
are not that great at the moment?
No.
Of course, if you had taken at least one for the team, we could have set up shop in Williamsburg
because you would have been able to afford that mortgage.
But then you had to offer these famous words.
I don't do overweight, middle-aged women.
Nice.
You're welcome.
Yeah, I think the next time I will do this by myself.
Anyway.
Fancy's or not.
Anyway, it doesn't matter.
Okay.
Feedback.
Feedback.
Yes.
Yes.
Yes.
Feedback.
Frank.
Yeah, Frank Roach.
Frank.
So who's Frank?
Frank is somebody wrote up comment upon your connection.
No, he's not.
No, Frank Roach.
On Hacker Public Radio.
The following words, the sketch, sorry to say,
but I found the sketch rollback cut.
He posted on the 15th of June the sketch, sorry to say,
but I found the sketch not to be funny at all.
No, sorry.
The sketch, sorry to say, I found the sketch not funny at all.
Not because I'm a Trump supporter from it, but it was just not funny
on a, in a comical sense.
It gave me a sense of frame shame, which is a peculiar German word.
My interpretation.
And I had to skip over it after listening to the first minute or so.
Please also work on your audio, on your audio balancing.
Yes, Frank, that is appreciated because you are still trying to get things right.
I think we have to talk to the post-production people, Martin.
Yes.
The Polish gang that, I think, the Polish gang, the Polish gang.
The Polish gang.
Martin, that says was so fond of doesn't cut the G's.
No.
I think I have to go back to do it myself again, I don't know,
but, let me have a word with post productions or with the general
operational department to my I might
Yes, operations haven't been
Yeah, there was another operation issue wasn't there
Recently, let's put it this way. So I think a serious automation problem. Yeah, I think a serious reork is actually
That's real role
So marketing saves operations comes to my
Yes, and Frank continues to write first. I was a
No, no, no, no, no, no, no, no, no, no, the presenters will stay there because they make the numbers right so you can't find them
Okay, Frank continues to write first. There was a low volume talk
Then suddenly a much lower technology
Jingle right before the sketch. Yes, you're right. As I said, let me have the word. Let me let us have to let us have to a word
with a Polish crowd
So that we can make some improvements in this area
Okay
We have to do a box. Oh, yeah, actually there is another bit of news that I almost forgot to mention
It's not exactly
open source, but I'm not sure Brad picked back Brad Pitt rings well
It's definitely not open source correct
But Brad Pitt recently moved in with somebody called Ali a shortcut
Oh
Not with your favorite actress
Pamela, no
No, no, no, no, no, no, no, no, the answer
Ah, no. Oh, sure.
Shocker, yes.
Well, are we talking about S-H-A-W-O-S-H-O-R-E?
S-H-A-W.
Right.
Okay. No, her name is Elliot Shockert.
Right.
Okay. Never heard of her. Fine.
Eh, the...
The TV sitcom arrest the development doesn't ring a bell.
No.
And I thought Martin was contemporary.
Oh, I was.
Eh, the listeners, ehm, it might...
It might on might not be a pox.
The development of this news, actually.
No. No, they just moved in.
And that's shocking.
Yeah, all people moving all the time.
It's Brad. It's for God's sake.
No, no news.
Well, so...
I mean, his...
My name is moved in as well as some news.
I mean, that means that Brad Pitt is off the grid, Martin.
Wait, what?
What's he doing on the grid?
Oh, Jesus.
Eh, your wife got in touch.
I'm just looking at an email of her
and she says that actually you have
cancered your hello subscription.
Yes, it does show.
No, not good.
Because otherwise you would be...
You would be able to encompass the gravity of the situation,
which apparently clearly...
You are not.
Why don't you tell me what the gravity is?
I already mentioned that, Brad.
That Brad.
Maybe I'm not thickest.
I already mentioned the fact that this moving in
has entails...
implies whatever, whatever, whatever.
What?
implies that Brad Pitt is off the grid.
Meaning...
Okay.
Sorry for the more simple-mindedness.
But someone around the farm won't let me out here.
The Brad Pitt supports us.
No, and that means that he's not available at Pitt fanboys.
Essentially, that means that he's not available anymore.
And your point is...
For romantic encounters with a female variety.
Although apparently Aliya Sharkat is bisexual...
Hang on, how is this news?
It happened.
What are we talking about here?
It happened recently.
Hence the name news.
I'm very confused here.
Markness is easily confused.
Because otherwise we would have got that really superb Williamsburg outfit
and a lower mortgage rate.
Is this a podcast number two?
Hello, magazine.
The sequel of something.
No, it's still loose and lost.
I mentioned the fact that they have moved in together.
And now that entails that Brad Pitt is off the grid.
Apart from the fact that you can read that...
That news website also on your Android phone.
Which, of course, runs at the end at the very end of the day
and opens for a platform.
Of course, but not saying.
Okay.
And you find actually the link in the show notes.
It's in German, so let me translate this.
Essentially...
Ah, see.
The sad news that it's official.
One of the most wanted singles of Hollywood is in a relationship again.
Aliya Sharkat, age 31, is apparently the lucky one.
Yes.
At Brad Pitt's site.
Is that the way to correct it?
There was a long speculation about an affair between the two of them.
And the reason for this that they have been sat in public recently.
Especially at a concert of the show musician called Thundercat
at the beginning of March.
Of course, that also leaves...
What's your name again?
Jennifer Aniston in somewhat of a tatter because there was some news
during February and March time for the people who follow that sort of thing.
As in, who have not canceled the Hello subscription?
That apparently Jennifer and Brad were getting together again
after Brad publicly split from Angelina Jolie last year.
I think it was or something.
Right.
Now Martin is really confused what the hell this has to do with open source.
And of course the long and short of it, Martin, nothing.
Okay, that's fine.
Right.
I'm sure it will be very much appreciated by our listeners.
These facts.
And that ends episode 10 of something called the yellow press tabloid podcast.
Happy to have you.
Happy as our solid listener mates.
Do come back for more information on Brad Pitt, Martin Visser,
Alia Shortkart and of course Jennifer Aniston.
Don't forget to have Pamela Adnan here.
Oh, of course, Pamela Adnan.
What's the other one's name? Pamela of California 190825 fame?
Yes, Pamela Adnan.
That's it. The one with the big...
No.
Exactly. Yes.
Pamela Adnan. That's the one. Yes.
So guys and gals you heard here first.
Well.
Let's see that little magazine.
And yes, the listeners do not forget, unlike Martin,
to renew your latest subscription.
If you are looking for that sort of information,
or of course you simply subscribe to the RSS feed on Hacker Public Radio.
Yes, we have one by ourselves these days.
Because we are now looking at the 10th episode.
Hacker Public Radio is the place to be for catching up on new episodes.
Of Linux in lost.eu, which is of course our website.
Feedback as usual is appreciated at feedback at Linux in lost.eu.
Yes.
And as I said before, as we said before,
anything goes.
So if you have any suggestions like Frank did and your feedback,
of course, is appreciated.
Never mind how much fun we make on it.
Do send us an either send us an email to feedback at Linux in lost.eu
or simply leave a comment on the Hacker Public Radio website.
This podcast is licensed under the latest version of the creative
commons license type attribution share like credits for the intro music
go to blue zeroesters for the songs of the market to twin flames
for their piece called the flow used for the second intros.
And finally to select your ground for the songs we just use by the dark side.
You find these and other details licensed under cc achamando.
A website dedicated to liberate the music industry from choking copyright legislation
and other crap concepts.
Thanks for watching.
So as a child, did you have many ways?
Oh, very much so yes.
You didn't?
Did they involve much taking apart?
More often than not they did, yes.
Okay.
Cut, cut, cut.
Oh yes.
Let's, let me turn this off.
You still have this?
Yes I do.
Why?
It goes hand in hand with a with a with a
Yeah, giving a man yes.
It's one of the many phone lines.
And for sure, I cannot go into the details right now.
Okay.
Okay.
Yeah, sorry.
Rolling, rolling again.
Yes.
You were talking about that.
You asked me if I had toys and trials.
Yes.
Yes, sorry.
Okay, right.
I think it's part great stuff.
I kind of had things work.
And then for a lot of people, kind of,
life takes over at a certain point.
What's life?
I heard about the concept, but...
At some point it will stop.
There's the, there's the light.
Guess you haven't caught one.
I see.
It starts and then you know, it's got a bit in the middle.
Anyway.
You've been listening to Hacker Public Radio at HackerPublicRadio.org.
We are a community podcast network that releases shows every weekday,
Monday through Friday.
Today's show, like all our shows,
was contributed by an HBR listener like yourself.
If you ever thought of recording a podcast,
then click on our contributing to find out how easy it really is.
Hacker Public Radio was founded by the digital dog pound
and the Infonomicon Computer Club.
And it's part of the binary revolution at binrev.com.
If you have comments on today's show,
please email the host directly.
Leave a comment on the website or record a follow-up episode yourself.
Unless otherwise status,
today's show is released on the creative comments,
attribution, share a light, 3.0 license.
