Episode: 3142
Title: HPR3142: tcsh
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3142/hpr3142.mp3
Transcribed: 2025-10-24 17:45:13

---

This is Hacker Public Radio episode 3142 for Tuesday the 18th of August 2020.
Today's show is entitled TCSH. It is the 240th anniversary show of Clartu and is about 29 minutes long
and carries a clean flag. The summary is, Clartu talks about TCSH.
This episode of HBR is brought to you by AnanasThost.com.
Get 15% discount on all shared hosting with the offer code HBR15. That's HBR15.
Better web hosting that's honest and fair at AnanasThost.com.
You're listening to Hacker Public Radio. My name is Clartu. I want to talk about TCSH.
Otherwise known as the C-shell. The C-shell is a Linux or I should say a UNIX shell that was
developed back at Bell Labs. Not long after the Born Shell was developed. The Born Shell, of course,
is the early, early shell for UNIX that was developed as an alternative, I guess, to just having
to program everything and see, I imagine. I'm not really sure. I mean, I know that the Born
Shell was a big deal when it was a thing when they created it and it was well loved by people,
I guess, but the C-shell came out because a lot of the programmers working on UNIX at Bell Labs
were programming in C and the C-shell had, as one of its big selling points, a C-like syntax.
And that's kind of the only good thing you'll ever hear about the C-shell. And I'm not here
to convince you otherwise to be honest and in fact, I can't even do a hard sell on the C-shell
for its C-syntax because I find that even its C-syntax is inconsistent. It's a little bit
blown out of proportion. So I'm not here to talk about why C-shell is better than any other shell.
And in fact, if I were only allowed one shell in my life, I would absolutely not take C-shell,
I would take Bash, well, or Z-shell, but I mean Z-shell is almost indistinguishable from Bash,
so one of those two, right? Not not C-shell. And yet, I've found over the years that I have a fondness
for C-shell and I'll tell you why. It's not a, it's not for a good reason, it is not something
that I can defend or anything, you know, it doesn't stand up to criticism, it's purely an emotional
thing. It, or even less than that, it's more habitual and a little bit of emotion, also some
habit. So back when I was learning Unix in a book called Visual Quick Start to Unix, I think it
was by Peach Pit Press, which may also be owned by O'Reilly now, or maybe even then, either way,
learning Unix, and the book, as I recall, was relatively shell indifferent. And I'm pretty sure
that I used C-shell for that T-C-S-H. So C-shell was developed, it kind of faded, but T-C-S-H
carried the C-shell mantle on. So when I say C-shell, I'm actually talking about T-C-S-H. They're
basically, we'll sort of treat them as the same, even though strictly speaking, I don't think
the C-shell is really maintained anymore. It's, it's T-C-S-H is where all the development is.
As far as I know, I haven't really looked into proper C-shell. So I was using T-C-S-H when I
started learning Unix, the point to that little story. And so I kind of grew accustomed to some of
the idiosyncrasies of T-C-S-H. Didn't miss them when I switched to Bash, apparently, because I just,
quite possibly, I hadn't used one enough to then be confused when I switched to the other.
That's quite likely. Although I do think that probably some of the weirdness, like with the set,
set set set on and set, probably kind of confused me when I first started on Bash, but not enough
to slow me down. It was, I think I just chalked it up to just general not knowing what I was doing.
So I was on T-C-S-H for a brief moment. Switched to Bash never looked back until I started working
in post-production. And specifically in post-production at a big effects house, went back to the,
you know, this effects house had been around since the late 90s. And I assume they were using SGI
boxes back then. And I'm assuming that either SGI shipped with T-C-S-H or someone, you know,
whoever was in charge of that stuff at that time. Actually, I think I know who it was, too.
Just probably liked T-C-S-H. And so he used T-C-S-H when he was developing all of their custom
in-house scripts. And so when I started working at this place in the early 2000s, well, what's the,
I guess, early 2010s, then I sort of, I found that a lot of their stuff was written in T-C-S-H.
Didn't matter, right? I mean, the thing about scripts that are written in a different shell than
what you're running is that they have the shebang line at the top and will invoke whatever shell
specified. So you could be running bash and launch a T-C-S-H script. And you'll never know.
It'll run perfectly. And that's not because it runs, quote, unquote, in bash. It's because it's
launching a shell, a T-C-S-H shell, a sub-shell, and running the script using that as its engine.
So it really, it doesn't matter that it was T-C-S-H because T-C-S-H was installed on the systems
and it would just run as expected no matter what shell the user was actually using to trigger it.
That said, there was a lot of T-C-S-H sort of in the company. And I thought, well, I'm not completely
new to T-C-S-H. I've never minded T-C-S-H. I think I'll start using that here at work. And so for
several years, I was a T-C-S-H user for, you know, every day, Monday through Friday. And I think,
I think I also had it on one of my home computers as well just to keep me in practice over the weekends.
So T-C-S-H, it's something that I'm fond of because I've used it and it's just something that,
I guess, the thing is that I didn't develop a sort of distrust or a fear for it. The way,
for instance, I developed kind of a fear of the unknown for, for instance, corn shell. Nothing's
wrong with the corn shell. It's just that K-S-H. It's just that I never really had used it and I thought,
well, what if I start using it? And I get busy one day and I forget that I'm using corn shell. And I
go to do something that I hadn't done before and it doesn't work. It'll slow me down for possibly
three hours or three seconds, one of the two. But either way, I don't want to, I don't, that's a
cost that is too high. But T-C-S-H, I just kind of, I was familiar with it. I knew what it was
possible to do with T-C-S-H and I knew what was not possible. And so it was something that I was
comfortable with. So I guess that's what I'm saying in this episode is that I am comfortable
with T-C-S-H. I'm not saying it's better than bash. I'm not saying there's any good reason to
use it over bash, but I am saying I'm comfortable with it. And here's why. Or rather, here's possibly,
some reasons, some ways that I'm comfortable with it, and maybe some reasons that you may or
may not want to use it yourself. So the first thing is the C-Like syntax, which as I've already
said, a little bit overblown, I think in my, in my opinion, but there are some, there are some subtleties
to it that are interesting. So first of all, let's take the simple if statement. In bash, of course,
you would do something like if square bracket, dollar sign, var, dash, gt, zero, close square bracket,
next line, then next line, echo, blah. And then you close that with an fi, the word if spelled
backwards. Now, I have to say that's a weird, that's weird syntax. I don't care what your
experience level is with any language. That's a weird syntax. If square bracket, variable dash gt,
what what's dash gt? Well, obviously it is greater than, but there's already, there are already
math operators invented, right? We have things like greater than symbols and less than symbols and
pluses and minuses and so on. So what's the deal with the dash gt? Well, what's actually happening
here is that bash is not utilizing any kind of built-in mathematical system. It is using a,
it's using the test, I think the binary executable test as far as I know. Let's just double check,
I guess, at least that part. No, test is a built-in. Okay. So it's using a built-in test to sort of
as a call out to to to analyze this statement and part of the syntax of test is this weird sort of
dash gt thing. So that's that's odd. And then the the closing the if statement with the backwards
if that seems a little bit strange to me. I mean, it's efficient, but it is strange. I mean,
I'm not saying strange doesn't equal bad. I am simply saying it's strange, whereas certainly
if you were a C programmer back in the 70s and 80s or today and you were used to something a little
bit more like if parentheses dollar sign var is greater than with the symbol one close parentheses
then echo blah end if that feels a little bit more normal. Now strangely to no credit of tcsh I guess,
strangely that's not that's not actual c syntax. If you've ever written c, you know that that's not
what c would actually look like either. So it is a little bit odd that that everyone says oh c
c shell is cool because of the c like syntax. And I guess what they really mean is yeah, it's
c like, but it is not c syntax. So I don't I don't know what the qualifiers are for when something is
c like and when something is not c like if by c like we don't mean exactly like c. So that's odd,
but there you go. That's that's that's the if statement in in c shell the the c parentheses then
and then closing it with end if another thing about the c shell that I find mildly comforting or
or again just I guess comfortable is the the way that you can feel as if though you are declaring
variables when you set them. So you know how in a in a programming language in in many programming
languages you are required to specify well to declare a variable before you go throwing the variables
around. And in some programming languages you even have to tell the you have to write it in the
code so that the compiler will know what to expect in such you have to tell it what kind of
variable you are creating you have to give it a type. So you might have to say int var equals
one or or string var equals word some some word example word or car var equals you know the letter
a and like that. So you don't really have to do that in a lot of modern languages a lot of
them just kind of figure that out for you and think about Python but also bash they don't require
you to type your variables you just you you create a variable and you throw some data into it
and it figures out what kind of data it you've you've given it. And some programming languages are
smart enough to almost do that on the fly like it doesn't care the type of variable until you set
about using the variable at which point it it analyzes the way that you are trying to that data
and and responds accordingly. It's a great convenience and yet there's something about it when
when going for structure. I find there's something comforting about the regimented nature of
having to say of having to set a variable you type in the word s-e-t space var equals h or or
one or whatever. So it's it's the word set. Now actually once again in c shell there are strangely
several different ways you can set variables and and the keyword set is is merely one of them which
I think that can be a little bit confusing and it's a little bit puzzling and it's one of those
quirks about c shell that I've never quite understood why the why they have at least three different
ways to set variables that I can think of off the top of my head possibly more. But the one that I
latched on to eventually was the keyword set simply because it felt right to I have to declare
to something that I am creating a variable here and I think I like that not just because it
quote unquote feels right but but because when you go into the code three years later or or you know
in my case one week later to fix something and you've completely forgotten everything about the
the script that you're fixing the language that you're writing and you're just everything's gone
seeing the name of the variable preceded by the word set identifies that that string that that word
as yes that is a variable it kind of confirms that for you I don't know if you've ever read a lot
of source code many of you probably have but sometimes when you're reading there are just
there's so many words there and they all look basically the same they're all strange and cryptic
and and and and none of them it all sort of starts to meld together especially if there's a bunch
of libraries or modules or whatever thrown into the mix then you have all of these unfamiliar words
that normally wouldn't be in this programming language anyway but there's this library that they're
using that you're not really used to seeing so now you have these words thrown into the code
along with the the keywords of the language along with your variables that's a lot of different
words strings of letters that you have to kind of categorize in your mind and I always liked in
in like I don't know I think cobalt or Fortran or or or algal some of those and even basic where the
commands seemed to be well heck even my SQL a lot of times people do it this way the commands are
all in capital as you've got these really sort of loud shouty command words and and then everything
else after that you know you know if it's not in all caps and you know that's not part of the
language it's something else and I very frequently in for instance python I'll very frequently make
my my variables all capitals and I'm sure that's making some python devotee out there
shutter because I'm sure there's a pep out there where it says that variables should not be all
capitals or something but I don't care I think it separates it really really nicely if not for me
right now then for me later and and that's kind of in a way what set var or or set example variable
name does for me it gives me that reference point in the code to to to confirm that that one word
that could be anything is indeed a variable name something you know like page set page equals true
I don't know whatever right now if I see the word page throughout the thing I know that there
it's a variable called page and not some fancy library some some function out of some fancy
library that I'm just not that I don't remember it has is involved in this in this thing so I like
that I like the that sort of earmarking of yes this is this is the type of word this is and you
should remember that from then on of course set the function or the the command itself has a
bunch of other uses is in C shell as in bash you could you can get a listing of your variables
in C shell and and in bash you can type in set and it'll give you a bunch of it'll give you all
the variables that have been defined in C shell you can do I'm going to switch over to TCSH here
you can do set and get all the variables that are that have been set and then you can also do set
ENV set on and get all the environment variables that have been set I don't know if that exists does
that in this exist in bash I've never no it doesn't but just ENV it exists in bash so yeah there are
some some little no extra functions there of set and there's unset of course as well if you want
to ditch a variable decide you no longer need var which you have set previously to one then you
could unset var and then look for var in in your set list and you will not find here's another
thing that I kind of like about TCSH and this is this is silly and and really you know every other
day this is something that I don't like about TCSH but every other day I do like it and that is
that bash can sometimes get a little bit too fancy pants for its own good and it kind of encourages
people to be a little bit too fancy now this honestly normally is a feature for me like I'm a KDE
fan right that's my primary environment because everything is customizable on KDE a common
criticism this will come back to TCSH trust common criticism of KDE plasma desktop is that there
are too many options people say oh you know you right click on on you can right click on everything
and everything has 20 different options and you can go into any of those 20 options and get 40 more
you know a window of 40 different knobs that you can tweak and change and that's to a lot of
people a criticism that's a problem and that to me never made sense like why would you criticize
something for being for having too many possible ways to control it like that sounds fantastic
that sounds like what a computer should be so in real life like at the core of my being I like that
because I know that there's always the option to ignore all of those options you don't like a
feature pretend like it doesn't exist as simple as that that gets a little bit more complicated
when you start dealing with other people though and I have many times opened up bash scripts
and I've seen things like var equals a hacker public grade camel casing right dollar sign curly brace
hacker public radio no var sorry dollar sign curly race var comma comma close curly cool what
unearthed that just do nobody knows is it is a secret bash function it's shorthand it's super handy
like someone out there right now probably listening to my voice I'm talking to you you know what
that and you love that feature and like I say at the core of my being so do I like I want that
feature to exist I want you to like that feature I want you to have access to that feature but in
practice secretly when I'm not recording hacker poke radio episodes secretly I don't like that sort
of function because it it slows me down for three seconds but when I open up a bash script and
look at that I think what does that mean what's happening there I can't be bothered to look it up
maybe if I ignore it it won't matter and then I spend the next hour trying to achieve something
that isn't working and I can't figure out why and then finally I remember there was that one line
I for I ignored and I go back and I finally do an info bash or man bash and I look through it and
I find this comma comma curly brace thing and I realize oh that's like a shortcut in bash to take
a variable in this case var and make it all lowercase and now you know what the function does
but you didn't know it before it's not intuitive it it it's not very easy to figure out what's
happening there it doesn't even necessarily look like string manipulation right I mean like it
not really like if you look at that dollar sign curly brace var comma comma curly brace what does
that do I surely it just removes an extension a file extension or or something like that or it
delimits something no it's it it makes everything lower that sort of thing like I say if you
know what it is and you use it regularly it is brilliant to and if you if it doesn't then you
don't like it or it messes you up and then you grow to resent it and I guess I guess that's sort
of in a way what happens to me pretty regularly I grow to resent little shorthand little almost
I'm going to call them perlesque but that's p-e-r-l not b-e-u-r-l-e-s-u-e is perlesque
shorthand because it's just not very intuitive but it's super efficient in handy tcsh doesn't mess
around with that they just don't even give you that option which again normally in real life I hate
I think that's that's horrible it means that tcsh is essentially gnome 3 to the the kde of bash
and why would I ever want to remove option from the from the universe of possibilities that I have
or that I expect when I have a programming language or a scripting language well the answer is
simply just for that future self again or for that other user who might be opening up a script I
find that if you know if there's that smaller set of vocabulary then it's kind of easier for
everyone to get on to the same on to the same level and with tcsh that it ensures that I don't get
overly clever and that the future me or ideally someone else trying to contribute to a project that
I've that I'm maintaining they'll be able to to read the code understand what's going on and then
conform to it without too much sort of reverse engineering or study now of course the the catch
there is that really realistically bash is the lingua franca of shell scripting and so
if I throw tcsh into the world then the the possibilities of people using bash some kind of illegal
bash syntax or rather legal bash syntax that tcsh doesn't understand is is actually pretty great
and that could slow them down just as much as dollar sign curly brace bar comma comma curly brace
so the bar being an example by the way that it could be anything it could be penguin dollar
sign curly brace penguin whatever your variables called yeah point being I like the restrictions
that tcsh imposes upon me because it keeps me from being too clever in places that really probably
don't need they didn't need to have that cleverness involved it was just one of those things where
honestly the thing and a good a quick little tweak in awk would have done the same result
and it would have been visually a lot more intuitive so that's that's one of those weird backward
features that I actually quite appreciate about tcsh another cool little short short cut in tcs
to tcsh that I like is the at symbol for for math this seems kind of silly and and it is but it is
kind of nice as well you can in tcsh type the character at you know just like the thing in between
emails and then do for instance in and then the equal sign and then parentheses one plus one
let's do divided by two closed parentheses if I echo in I get as would as we would expect from
that equation one now that that is different from for instance set in equals parentheses I don't
know let's just do one plus one to keep it simple and then echoing in that gives me one plus one
but if I do that at symbol it actually resolves the math within that variable is that any different
functionally from in bash doing let in equals parentheses one plus one divided by two closed
parentheses no not really the I guess the main one of the main differences is that it is one
character instead of three like I say it's it's kind of silly but I do I do appreciate that sort
of illusion of of of speed I just I like that the simplicity of just the at symbol I don't know
why it's the at symbol it could probably have been really anything else other than at really
because that doesn't that doesn't quite connect with me in terms of here's a mathematical looking
thing at never really said that to me but it does work it's quick and for for whatever reason it's
easier for me to remember than syntax for for math in other shells and that's it that's those
are the the reasons I can point to for sort of enjoying tcsh there are other strange mildly perverse
reasons for liking tcsh for instance tcsh doesn't do functions it doesn't have an ability to define
your own functions in tcsh again kind of odd for a thing that's often praised for being for for
for sort of calling back to c right I mean that's all you do in c well it's not all you do but I
mean functions that's that's a thing in c you don't really have that ability in the c shell at all
so what that means is that you get to invent like clever sort of new ways to code such that you're
emulating functions you know that weird stuff like that it gets a little bit strange and
you know honestly if you're if you're doing this at home and and you're you're looking at the time
and you just think I got to get through this script so I can move on to something more important
messing around with tcsh might not be the the most pleasant of avenues towards getting a job done
but you know when you're sitting at work and you're getting paid for every moment that you work
on a script anyway and you think if I write this in tcsh then I will be compliant with all of the
other scripts in this environment wouldn't that then yeah it's kind of worth it it's kind of fun
so that's um that's the c shell or or the remnants thereof and uh I'm not recommending it
but I'm not recommending against it either I know that there have been um rather old historical
documents about why you should never script you should never script with c shell and and so on
and that may have been true at one point I don't know if it's still true like I don't know if any
of the reasons in those sorts of flame war posts are actually valid all I know is that um that
that shells are fun to mess around with and c shell is is a shell and it is fun to mess around with
so if you're curious about it try it out sometime it might be fun it might be it might at least
make you see the difference between sort of whatever you it is you're taking for granted
whether it's bash or zed shell or even corn shell all of which kind of act mostly the same
most in most ways try out c shell see see see what's different see what um see how frustrating it
is see how much fun it is to learn to learn a different syntax it might just make you see things
a little bit differently you know kind of the way that the first time you sat down in front of
a unix that wasn't Linux and and you realized oh the commands that I take for granted aren't the
only ways of accomplishing this or that task I have to learn new unix command you know dedicated
to this system that's kind of what c shell is a lot of times it's it's there there are lots of
valid ways to talk to your computer as it turns out and it's not only through bash and sometimes
that can be very enlightening that can be that can be sort of transformative and make you a little
bit more agile and flexible when approaching any problem really but certainly one of syntax check
it out or I should say take the plunge see shell plunging into the sea nah that's not really funny
anyway you've been listening to hecka public radio at hecka public radio dot org we are a community
podcast network that releases shows every weekday Monday through Friday today's show like all our
shows was contributed by an hbr listener like yourself if you ever thought of recording a podcast
and click on our contributing to find out how easy it really is hecka public radio was found
by the digital dog pound and the infonomican computer club and it's part of the binary revolution
at bnw.com if you have comments on today's show please email the host directly leave a comment on
the website or record a follow up episode yourself unless otherwise stated today's show is released
on the creative comments attribution share a light 3.0 license
