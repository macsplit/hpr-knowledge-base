Episode: 4096
Title: HPR4096: Powers of two
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr4096/hpr4096.mp3
Transcribed: 2025-10-25 19:33:57

---

This is Hacker Public Radio Episode 4196 from Monday the 15th of April 2024.
Today's show is entitled Powers of Two.
It is the 10th show of Delta Ray and is about 17 minutes long.
It carries a clean flag.
The summary is, a story and discussion around how knowing powers of two can be useful.
Welcome to episode number 4196.
Back when I was in college and taking a calculus class, I was sitting in the front of the room
and the professor wrote up on the board log to a 4,096 and he asked if anybody can answer
it.
Within just a couple of seconds without a calculator and from me or anything, I said 12.
I guess it was shocking to everybody because they erupted in applause and clapped for me.
They might have wrote off as me being a genius or something, was simply related to the
fact that I knew my powers of two and 4,096 for me at the time this was in the late 90s.
Was the number of colors on an Amiga in Ham mode and I knew that the Amiga had 12-bit
color space divided into three channels, so four bits for red, four bits for green
and blue and so on combined into 12-bit.
At that time, I realized I got a deeper appreciation for what logarithm meant.
It wasn't just the reverse of exponentiation.
I started to feel more of a connection with it and realized how powerful it is to actually
know your powers of two.
In my career, I've come across several times where knowing my powers of two has been very
useful anywhere from down in the lower range all the way up into 2 to the 64th power or
even 2 to the herndtway 8th power.
You start out with 2,4, 8, 16, 32, 64 and you start to see those numbers pop up again,
but of course those are the lowest of the powers.
When you get to 128, you start to encounter a lot of places where computing has been defined
by these numbers, you know, a herndt 28 being 2 to the 7th power.
Well, this is how we get 7-bit text and how we have the ASCII character set is based
on 7 bits of character space and that's 128 different possibilities.
It's also the upper boundary on 8-bit integers, so if you have a signed 8-bit integer, then
it's going to have a range from negative a herndt 27 to a herndt 28.
I remember seeing a temperature sign on a bank that said 127 on it, although that's
not a herndt 28, of course, it was one away from that number and I can only assume that
there was probably some error that had happened on the bank because this was in Indiana, not
in Death Valley, so it didn't make sense that it said a herndt 27, but I imagine that
it was in error and probably, you know, all the bits were high or something like that.
And so that cost it to display a herndt 27.
And then you get to 256, which is 2 to the 8th, which is the boundary for unsigned integers
8 of 8 bits, you know, 0 to 256.
And of course, you know, in IPv6 internet addresses, you have ranges in each of the octets
that go from 0 to 255, you know, so 0-based and so on, but still a range of 256 values.
And you know, 8-bit computing is very much defined by the range of 0 to 256.
And 8-bit variables like a tinient and so on, but I remember back when I used to play
this game called Pool of Radiance on the Commodore, well, I had a Commodore 128, other
people had a Commodore 64, but I was mostly in Commodore 64 mode.
And of course, those numbers are 2 to the 6th and 2 to the 7th.
So there's two more powers of 2 for you, but on this game, Pool of Radiance, which
is based on Dungeons and Dragons, it was one of those Goldbox series.
And one of the, you know, early games to use like a decoder wheel for doing copy protection
and stuff like that, side note, one of the copy protection words on that wheel is Google
spelled G-O-O-G-L-E, and this game was released in 1989, so that's a little bit of interesting
trivia for you.
But anyways, getting back to 256, so one of the enemies that you'd fight in this game
was a race, and it could drain you a level.
And so there was a special case where if you were like a first level player and you were
in a party that had like a cleric or something, and you let one of the characters get their
level drained by this race, like from level 1 to level 0, and then get drained again, it
was actually possible to end up being level 255, because of course you get a wraparound
problem where the bits, you know, wraparound and you end up with a value of 255 in the
integer in the variable bucket.
And so, you know, that's one case where you can kind of hack the game, or at least they
didn't catch that, right?
They didn't have a, they didn't expect it to happen, but if you knew how to do it, you
could kind of trick the game.
512, I'm sure shows up in a lot of places.
To the 10th is 1024, this is often used in like 10-bit values, analog to digital converters
and digital analog converters have frequently used 10-bit buffers in order to 10-bit resolution
in whatever it's reading in analog form, so you'd have 1024 different possibilities.
It's also the, in the internet protocol, it's the start of the unprivileged port or unreserved
port space.
So anything below 1024, as far as TCP or UDP ports go, represent ports that have to be
reserved with IANA or the internet engineering group.
Basically you have to send off an application to reserve a certain port if you've created
a protocol of your own and you want to get a reserve port that would be something below
1024.
And on most operating systems, any port below 1024 can't be opened by a normal user,
so you have to be a super user or get some kind of special privilege to be able to open
that port.
And that's to prevent like, you know, on a non-web server, a user starting a web server
that then could, you know, be on the browser could go to by default without specifying
a different port number or maybe a male server or something like that.
Basically, somebody doing something semi-malicious, you know.
2048, of course, you know, a popular game on mobile phones, but that game is based on
powers of two, right?
So of course, we're going to run into 2048.
But this is the low key size for RSA encryption, you know, so there's an R2048 issue.
But as we go through these numbers, one thing to keep in mind is that as you're working
with computers and working with software, you may encounter numbers around these in
errors or in file sizes or something like that.
And if you happen to notice that those numbers are close to a power of two, that could be
a good indicator that something has gone wrong.
Many of us have probably run to the case of files not being able to be over two gigabytes.
Well, that is 2048 megabytes or in actuality, it's, you know, two to the 31st, which,
you know, represents $2 billion, $47 million, $4 billion, $83,648.
But this is a common file system limit that you encounter, because they only allowed
for 31 bits of file allocation space.
So you'd wind up with files that would end up maxing out at two gigabytes, and that
was a good sign that you actually hit that limit, and that your file system wasn't allowed
you to write anything more to a single file.
4,096, here we come back kind of full circle, and not only is this the number of colors
on an amiga and hold modify mode, but it's also the page size for virtual memory on an
Intel X86 architecture.
In other words, the kind of the default page size that it uses.
And one thing that this, where you can take advantage of this is if you're using a program
like DD, you can actually set your block size to 4,096, and get kind of a speed increase
over some of the other sizes, because it won't be wasting any space, basically.
So having something that's a multiple of 4,096 will be more efficient.
The next one, two to the 13th is 81.92, and when you start getting up to numbers in
this range, one of the things that you run into is the buffer size limits of certain
protocols or implementations of those protocols.
So 81.92, for instance, is at least by default the maximum header size for an HTTP request
on Apache and Engine X. So if you end up getting some kind of error when you're making
a request from maybe a web application, and that, you know, the size that's transferred
is 81.92.
There's a good chance that you're running into this limit, maybe, and you need to increase
the size of something.
The next one, 16,000, 3 RNA 4, this is the maximum record size for SSL and TLS connections
up to TLS 1.2.
So this, you know, is another example of a protocol that has like a limit on a record size,
and you have to keep an eye out for it, and you might run into this and, you know, very
large request, or if you have some kind of daisy chain going on of TLS connections or
something like that, you might run to this kind of issue.
It's also the default page size that's used in mySQL NODB engine.
So you know, this can be tuned, but this is what you get by default.
So then we come to 32768, which is 2 to the 15th power, and this is the upper max on signed
16-bit numbers, and also is the, if you've ever used the dollar random internal variable
and bash that can give you a random value, this is the upper bound on that number, so it
goes between 0 and 32768, something to keep in mind, you know, you're not getting like
a very large range of random values, you're only getting 2 to the 15th.
And then 65535, which is 2 to the 16th, so 16-bit numbers, this is the upper range of unsigned
16-bit numbers, so 0 to 65535 is the range that you'd get from 0 for 16-bit, unsigned 16-bit
numbers, and this is the upper bound on the range of TCP and UDP port numbers.
So you're never going to get a port number above 65535, but of course 2 to the 16th is
65536, so that's the number to remember, a lot of these, you know, when you're translating
them into something related to computers, you're going to subtract one, right, because stuff
is zero based.
And of course, 65536 is the number of bytes of memory on a Commodore 64, and that's
where the 64 comes from, because we often say just say 64 kilobytes, not 65536 bytes,
so that's where that comes from.
One of the more significant ones here is 2 to the 16th, you know, 2 to the 20th power
gives you the 1 megabyte boundary, so that's, you know, 1,048,576, maybe the next big
one that you run into is 16,777,216, which is 24-bit color, you know, this comes up a
lot, you hear about this, you know, 16.777 million colors, or whatever, then after that, you
start having to make bigger jumps, 2 to the 31st power gives you the 2.1 billion number,
which is 214748, 3648, and you'll often, you know, like I mentioned before, you might
run to file size limits here, but also several other types of values can end up hitting
this boundary number, so this is a really good one to memorize, at least memorize the
first four digits of it or so, because if you recognize those four digits of this one
and the next one, which is 2 to the 32nd, then you'll start to recognize when certain
errors are happening due to those boundaries, and so the next one is 2 to the 32nd, which
is 4 billion, 294 million, 967,296, and that also is the number of possible IP addresses
in IPB4 space, but of course, there's realistically much, many fewer than that due to like multicast
and also routing and stuff like that, so, but that's the theoretical maximum, and then,
you know, you get up into the really high numbers, but one that you're likely to run into,
maybe in an error or some kind of output, would be 2 to the 63rd or 2 to the 64th, these
being relatively 9 quintillion, 223 quadrillion, 372 trillion, 36 billion, 854 million, 758,
188, but if you just remember the first four digits, like 9223, you'll at least say, hey,
that seems familiar or something like that, the next one is, it starts with 1844,
but it's basically, you know, twice as much as the previous one, and so on, so yeah, those are
your powers of two, you know, there's lots of numbers that are useful to remember, one that I've
run into a lot, a series that I've run into a lot is, of course, the number of seconds in various
units of time, of human readable time, like hours and days, you know, 30 minutes, we all know that
3,600 is the number of seconds and hour, but it's also useful to remember that, you know, 7,200
and is two hours and so on, onto 86,400, which is the number of seconds and day, and so, you know,
you'll encounter this often in DNS, where people will set the time to live values of various
records to be multiples of like 1,800 or 300 or 3,600 or 86,400 or something like that,
so you can kind of get an idea of how much time that is, or if you see something happening,
you know, on an interval that's like that, then you'll know, oh, that's probably set to happen
every day or every hour or something, okay, well, I'm curious to know if you have your own stories
about 4,096 or any of these numbers that you'd like to share, I'd love to see those in the comments,
take care, bye.
You have been listening to Hacker Public Radio, at Hacker Public Radio, does work. Today's show
was contributed by a HBR listener like yourself, if you ever thought of recording podcasts,
and click on our contribute link to find out how easy it leads. Hosting for HBR has been kindly
provided by an honesthost.com, the internet archive, and our syncs.net. On this address status,
today's show is released under Creative Commons, Attribution 4.0 International License.
