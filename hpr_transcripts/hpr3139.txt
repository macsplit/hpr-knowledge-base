Episode: 3139
Title: HPR3139: MIDI Sysex
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3139/hpr3139.mp3
Transcribed: 2025-10-24 17:39:09

---

This is Hacker Public Radio Episode 3139 for Thursday the 13th of August 2020.
Today's show is entitled, Midi Sissex. It is hosted by Klaatu and is about 21 minutes long
and carries a clean flag. The summary is, Klaatu talks about Sissex functions in Midi.
This episode of HPR is brought to you by archive.org. Support universal access to all knowledge
by heading over to archive.org forward slash donate.
Everyone, this is Klaatu and you're listening to Hacker Public Radio.
And in this episode, I want to talk about Sissex. Sissex is a sub-system. Maybe you would call it
or maybe a language. I don't know a specification or actually it's part of the Midi specification.
Midi, in case you are not familiar with it, is the musical instrument digital interface
that arose for synthesizers back in probably the 80s, let's say. I'm kind of being fuzzy
about the date because I don't know when the research actually started and so on. But we could
say the 80s, generally speaking. And the reason they came up with Midi was not really for computers
as such originally. It was to hook synthesizers to one another. And so you would have, for instance,
maybe you might have a synthesizer doing a bass line. And you want that bass line to synchronize
perfectly with the synthesizer playing the melody. And you want the melody to sync up perfectly
with the drum line and so on. So in order to make that happen to ensure that there was no drift
in the time of each note being triggered, they needed some way to coordinate that mechanically
or rather, well, yeah, mechanically. You don't want a person having at each keyboard having to
play the part. You want the keyboards to be able to be sequenced and to respond to a central authority
for both the notes that it's going to play and the tempo at which it's going to play those notes.
So Midi came about as a way to daisy chain synthesizers together. And it was a daisy chain. You
didn't have as far as I know like a Y splitter or a hub for midi routing. It wasn't like that. You
would plug a midi cable, which is sort of a glorified XLR cable. If you've ever seen an XLR cable,
big round plug, plug that into the midi out of one of your controller device, whatever that might be.
It might be a sequencer, might be a sampler sequencer, might be a just a dedicated,
like a drum machine type thing as just a sequencer. It could be the sequencer of a of a keyboard
of something that can also play notes. Whatever it is, plug that from your controlling device
or from one synthesizer anyway to another to the midi input of another synthesizer.
And then you have them synchronized. And you can even control the sounds coming out of that
tethered device by switching to a different midi channel. So if you've got one controller and,
let's say, 16 synthesizers, then you can broadcast different sequences to each synthesizer.
Plug each of those synthesizers into an audio mixing board in the output of their sound,
or you mic them. The output of their sound that they are making can be recorded
together all at once in perfect synchronization. That was midi. That was what midi made possible.
And it did this with a relatively simple set of instructions. And if you go to midi.org,
you can go to the midi association and look at the specification for midi 1.0, 2.0, whatever you
want to look at. You can see what kind of signals they send. You can analyze that as well.
In your own terminal, if you want, you can plug in a midi controller, a midi USB controller
into your Linux computer. And just do a cat of slash dev slash midi whatever device number it is.
And pipe that to something like hex dump dash dash or dash capital C. I think it's dash dash
canonical is what that stands for. And you'll see all the output the output of each note that you
press on your USB controller. You'll see what kind of signals it's sending out. I don't know what
good that'll do you, but I mean you can in other words you can see that and you can also look at
this specification and kind of get a feel for what kind of data midi is sending across those little
wires. Now when midi got integrated or started to be able to interface with modern computers,
like with an operating system and so on, I mean the term computer is getting a little bit difficult
to nail down now or then because I mean you had these digital scents that were talking in midi to
one another sending kind of all kinds of little signals. And it wasn't just notes that they would
send. They would send velocity. They would send tempo changes. They would send volume, cues,
all kinds of signals. They could send to one another. So when they started hooking into modern
computers, it started to get a little bit interesting because now we have the legacy midi system
interfacing with really a system that's robust enough not to really require all of that legacy midi
stuff. But the point of this episode actually is to praise midi and to talk about how great it is
that it exists and what it gets us for our continued support. Namely, it gives us a universal language,
a non-vinder non-exclusive language that we can use to talk between musical instruments
on the computer and controllers in the physical world. So I've got this midi tech controller,
is the brand name. It's a really good little controller. I'm a big fan of it. I think it's
German made. It's metal. A lot of it is metal, which I really, really like. There are sideboards
made out of plastic, which I keep thinking I should pry those off and replace them with some
nice really some really nicely fine grain wood and polish the wood. I think that would just look
absolutely amazing. I just haven't gotten brave enough to pry this thing apart yet because I
really do like it and I don't have that much confidence in my deconstruction or construction
skills yet. But we might get there. Anyway, I've got this nice little controller. It hooks up
through USB and midi. It's got both. It's got an actual midi out and USB out. The nice thing about
it is that it just like many midi controllers, it just works on Linux. There's no, you don't need
to install drivers or anything like that. This is kind of like that. You can kind of almost take
for granted at this point. You know, you can just kind of assume that a midi controller,
USB midi controller is probably going to hook up to any computer and send midi signals across
whatever cable it provides you. That is more or less a safe assumption. I mean as safe as anything
in this crazy weird tech world where vendors up and decide to do strange things, you know, as
much as that is a safe assumption at all, it's a relatively safe assumption in general.
The interesting thing is that in some cases I gather and I don't know, I can't confirm this,
but in some cases I'm assuming that sometimes the vendors provide drivers for a computer so that
the computer knows I guess to look out for those midi signals maybe. I'm not really sure. And
possibly even to help you program the midi device and that's where SysX comes in. This is going
to be different depending on what kind of device you have because again, vendors kind of
get to do whatever they want to do so it can be difficult to anticipate what they're going to
provide. But just kind of in general, there is a system within midi called SysX which is system
exclusive signals. Despite the name system exclusive that's not talking about like operating system
or a vendor or anything like that, it is system exclusive meaning that it is a segment of the
midi specification that is reserved for the user to be able to program or to alter the program
of their midi device. And this could be a number of different functions. I haven't had physical
actual hardware devices and so long that I don't exactly remember all of the functions, but for
instance, there is a SysX signal for dumping the memory of a device. So if you've got a bunch of
custom patches installed in a little triggering device and you want to dump that configuration,
then you could do a SysX command to dump all of that information to something. I don't exactly
remember what it was to. You could change the velocity profile of what would happen when you
pressed a key. Does the note come on strong and then fade out or does it come on soft and then
ramp up? That sort of thing. You can you could adjust that sort of thing through SysX.
Not all USB midi devices have SysX accounted for. They should, if they're USB midi devices,
then in order to fulfill the midi specification, they should have that range of SysX signals
so that you can tell it what you want to do aside from producing notes. And that's again,
that's kind of the idea of SysX system exclusive, meaning these numbers, these signals are reserved
for producing notes. These numbers, the SysX was SysX ones, those are reserved for other stuff,
for system related activities understood. Okay, so it'll it'll depend on what your controller says.
My midi tech makes it really pretty simple. You press the shift key, which is a button on the
actual device. I guess I'll try to post pictures of this along with the show, but you press the
shift key and then you're now escaped. You're in your in command mode or whatever, you know, you're
in the you're in SysX mode essentially. You could think of it maybe like the escape key in VIM.
It kind of gets you out of normal input if normal input is producing notes and it places you into
this floaty detached kind of SysX mode where you're able to give your device some commands.
So for instance, we might say shift and then we could say change the actually here's one,
a sign slider. And I'm looking above the keys on my keyboard, on the musical keyboard,
they're handy, they're handily labeled above them and you'll see that this is pretty common
on a lot of MIDI devices. You'll see the labels above the keys. So I'll assign the slider
to seven and then I'll press enter. The shift key blinks lots of times and sets itself or and
records the command that I've just provided it. And so now my assign my my slider, which is assignable
and it's even labeled assignable slider. Now controls the volume of
of whatever I'm of the channel that it's currently broadcasting on.
And that's very useful as you can imagine. I could assign the slider to several other things too
and there are in the documentation for this there's a list of all of the standard MIDI
controller signals that I could use as an assignable value for my my slider. So for instance,
I could assign it to pan pots and pans by by assigning the slider to 10 and then I would just press
okay, so shift to get into mode to the shift mode the sysx mode assign slider to one
zero enter. And now it adjusts pots and pans what you won't hear because I mix down all of my HPR
to to mono. So you wouldn't you wouldn't hear the difference but you can believe me that's what
signal 10 in this in this sysx mode means. Now the the sysx modes themselves are standardized in
the MIDI spec. So I would have to look up what they're using for for the assign assignable slider
a signal. But there are lots of sysx commands that are not or the codes that are not assigned they're
not designated for anything. So vendors can use them for whatever they need to use them. But the
control change codes are in addition to being in the documentation for the device. They are also
part of the MIDI spec and you can find them on on MIDI.org. So you'll see things like
zero is a bank select code zero one is modulation wheel or lever two is breath controller three
undefined four foot controller five portamento time and so on. There's seven is channel volume
formally main volume and there's tin pan and so on. So a lot of this is standardized and then
some of it is just what other whatever applies to the vendors use case. Sysx also provides a method
of defining what channel your device is actually broadcasting over. So this doesn't come into play
much with computers with modern computers because they're big and powerful and they're emulating
your synthesizer and the recording unit that you would use to record the synthesizer and the sequencer
and it's probably playing samples and your drum machine you know it's got all that stuff going on
and it's not even it's not even breaking a sweat. So of all things routing a synth plug-in
within a digital audio workstation application you don't need MIDI channels for that in truth.
However you could you could use them you could have for instance one track in your digital
audio workstation broadcasting MIDI channel one to a specific synthesizer and another track
broadcasting over MIDI channel two to a synthesizer and in real life in physical hardware space you
would you would have had your daisy chain of synthesizers and you would have told you would have
played some notes into your controller or rather into your sequencer and you would have set that
as MIDI channel one and maybe you would have known okay well that's that's the Juno over there
and then this one over here is the corg over there and that's on channel two and and then I'll
play channel three and that'll trigger some stuff on the elesis and then on channel four that'll
trigger some stuff on the emu and suddenly you have a little band going but none of them are
receiving each other's signals so you've got channel one playing your bass line channel two playing
your melody channel three doing your drum track but anyway you get the idea so you you've got
different channels that you can you can sort of assign different devices to in the computer you
don't really need to do that so much but you can with sysx and again that would just be whatever
trigger key to get into sysx and then whatever musical note key to get to to select your channel so
in my case it's E and then there are numbers one through zero on this on this scale from from G
up to B type in whatever channel I want to assign my controller or set my controller to hit the
interkey and then I'm then I'm broadcasting over a different channel and not one now that would be
if if my computer wasn't listening to anything but one that that could be problematic for me but
if as long as I know what I'm doing that would be fine so that is more or less all I know about
sysx it's a really handy little built-in system it is very useful for for for the way that your
controller behaves especially if you are performing alive and you don't want to be leaning over you
know your laptop adjusting a bunch of little settings just because you feel like the keyboard
itself is too soft to the touch or to to sensitive to the touch and all you want to do is change
the sensitivity but you don't go in there to your synth and like adjust the sound that you're
that you're making you don't want to have to fiddle with your the envelope and the attack and
stuff like that so it's it's a it's a controller concern so you dip into sysx you tell it to change
the velocity curve you know the velocity curves that are built into your into your controller which
I think this particular device has four different profiles yeah four different profiles one two three
and four there's a s curve and a sort of a converse and a convex and a completely linear curve
and so you could set that and then suddenly you're you're sounding different or maybe you want to
assign that slider to something something different or or you want to assign it to volume and it
wasn't assigned before and there is even a what's called the registration mode on this particular
one as there is usually in sysx you can basically save your data to something now this happens to have
internal memory so that your settings can persist across unplugging and plugging it back in you
know powering it off and powering it on which is quite nice so yeah it's really useful it it makes
your it makes your MIDI controller all that much more independent and self-standing which I really
like doesn't rely on the OS at all you don't have to fiddle around with the GUIs and stuff like
that it's just all self-contained and if you use it a little bit you'll get used to it and you'll
you'll grow to love it so if you're doing a bunch of MIDI stuff and if you find yourself needing to
customize your environment a little bit look look to see if your controller provides for the sysx
signals and try them out I think you'll like them thanks for listening talk to you next time
you've been listening to Hacker Public Radio at Hacker Public Radio dot org we are a community
podcast network that releases shows every weekday Monday through Friday today show like all our
shows was contributed by an HBR listener like yourself if you ever thought of recording a podcast
and click on our contributing to find out how easy it really is Hacker Public Radio was found
by the digital dog pound and the infonomican computer club and it's part of the binary revolution
at binrev.com if you have comments on today's show please email the host directly leave a comment
on the website or record a follow-up episode yourself unless otherwise stated today's show is
released on the creative comments attribution share a live 3.0 license
