Episode: 2553
Title: HPR2553: Get ahead with git HEAD
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr2553/hpr2553.mp3
Transcribed: 2025-10-19 05:27:51

---

This in HPR episode 2,553 entitled Get a Head with Get Head and in part on the series
Introduction to Get. It is hosted by Klaatu and in about 47 minutes long and Karimaklin flag.
The summary is Klaatu helps you understand Get Head.
This episode of HPR is brought to you by an honesthost.com.
Get 15% discount on all shared hosting with the offer code
HPR15. That's HPR15.
Better web hosting that's honest and fair at An Honesthost.com.
Hi everyone, this is Klaatu. You're listening to Hacker Public Radio. This is a continuation of my Get Basics series.
The previous episode on the 26th of March. I spoke about Get Branching and we played around with Get Branch
and found out how to do Dev Branch and all these other operations.
We did a couple of merges and dealt with some merge conflicts.
You're kind of familiar with some of the basic concepts that I wanted to cover in this episode.
Specifically, I want to talk about the concept of Get Head.
Now, Get Head is a weird kind of meta concept that a lot of people get very confused about and that's because in a weird way head seems to move around a lot.
But actually, I like to think of it as this sort of framework where head doesn't move.
The stuff underneath head moves. Let me explain myself and then tell you why you care.
No, actually I'll tell you why you care first and then I'll explain.
So, in order to keep track of where you are in Get, you want to get very comfortable with the idea of the Get Head.
And this means that you have to be okay with your reality changing, not really.
But I mean, the reality of your working directory completely shifting out from under you.
So, here's an example and there are lots of different ways to think of this concept.
But here's one way you can do it and you can follow along at home if you want.
This is an interactive exercise again.
So, if you have a mobile phone on you right now and you're not driving, launch a camera app.
Like just your normal camera application.
And put your mobile phone about six inches above your desk.
Now, don't look at the desk except through the camera.
Take a piece of paper and place it under the camera and write something on it.
For instance, the phrase Hello World.
Okay, so you've just created a branch and in that branch you've created a file
and in that file you've put the text Hello World.
Now, if you move that piece of paper out from under your camera, now you remember you're not looking at your desk
except through the camera and then take another piece of paper and put that under your camera
and you write some different text such as Goodbye World.
Now, you've created a new branch with different text in it.
So, now you can move that sheet of paper away and get that first one back.
Oh, now my camera says Hello World to me again.
Okay, and I could swap them out again.
Now, it says Goodbye World.
So, what you're doing is you're switching between two branches of your paper get repository.
And you are viewing the branches through your camera with this live feed of everything that's
happening on your desktop.
So, if you haven't guessed it already, then your camera in this exercise has been playing the role
of the head of Get Head.
And through that camera, that stationary camera, your world has been moving around underneath you.
It hasn't really affected you because you're only looking through the camera,
but everything under the camera has changed.
So, maybe that illustrates it, maybe that doesn't.
Here's a different way to look at it.
Well, first of all, I guess the same way to look at it would be like a microscope, right?
If you're looking through a microscope, that would be Get Head and the slide that you're,
are they called slides?
Is that what they're called on a microscope?
I don't know.
Those little things, the glass strips of like germs and stuff that you put under a microscope,
those are your branches, and so you could look at malaria, and then you could take that slide out
and put in streptococci.
Is that a germ?
I don't know.
And then you could move that out and put underneath the microscope by dinosaurs
cell from a dinosaur, for instance.
Do we have those?
So, there you go.
That would be Get Head, and those would be your branches, and you could swap them out.
I don't know how you would merge them.
Genetics, I guess, and your Get Head has never moved.
It is completely stationary, and everything's kind of moved around underneath it.
Here's another example, or another way to think of it, if it helps.
So, maybe if you are familiar with audio equipment, old school audio equipment,
you'll be familiar with a cassette tape.
It's a magnetic strip of flexible material upon which people used to record sound.
So, if you put a cassette tape into a cassette recorder, then there's this thing,
and it's called a playhead.
Now, the playhead itself does not move.
It sort of, well, it does move, but it doesn't move around horizontally.
It lowers itself down onto the tape itself, that flexible tape inside the shell of the cassette tape.
So, it lowers itself down onto that, and when the tape moves across it,
you can hear sound.
Or, or, if you put it into record mode, you'll be recording sound onto the cassette.
So, if you think of that playhead as your Get Head, then that's fairly similar.
It's the stationary thing, which you can sort of smack down onto something,
and say, yep, that is where I am right now.
And then, at some point, you can lift the head, you can swap out cassette tapes,
you can lower the head down again, and you'll hear the different sounds.
And if you really think about it, like how traditionally, like garage bands would record stuff,
and in principle, you know, studio musicians record stuff this way,
but they would record drums on one tape, and then they would swap out tapes,
and they would record guitar on the next tape, and then they would take those two tapes together,
and they would merge them together into one track with drums and guitars.
And all of this is done under this playback and record head that itself doesn't really move
around the project. It's the media that you're moving underneath the head.
Okay, so I'm just, I'm trying to draw analogies that aren't as scary as what I'm about to say.
So what really Get Head is is a ref. It is a reference to some thing in your Get,
let's call it a database. And the reason that you care about all of this is that the Get Head
starts to be very important when you're trying to figure out among all these branches and all
of the different data, all the the merges that you've got, or that you're thinking of doing,
or the merge conflicts that occur, all of these different places. It starts to really create kind
of a crazy looking world map around you, and at some point you have to stop, look around,
and figure out where you are within Get. I mean, look, not all the time. If you're just using Get,
and you're just one user, this will probably never happen to you, or maybe it'll happen like once,
because you'll forget that you're on one branch, and then you want to merge into another that you
that you meant to be on. So maybe there's some special case where it will happen to you,
but generally speaking, one user, this isn't going to happen to you. You're not going to care.
You'll never really need to get familiar with this concept. But once you start using it with lots
of other people, and then they start changing files out from under you, and they forget to do
something correctly, or you just happened to both be editing the same file.
Whatever happens, or maybe you're just a highly experimental developer. You like to work on one
project, and then you like to go out and fix a bug in another area of that project, and then you
have another working branch of some crazy new ideas that you have that are independent of either
of those two things. So you've got all these different branches, forks in the road all over the
place. You need to figure out where you are right now, and where you came from, and where you
want to go next. And a lot of that has to do with this concept of a get head, and get branches.
And the more you have a solid grasp on that, I think the easier it becomes when you do start
using get very, very seriously, because you want to kind of have some mental image of how all of
this is happening. I'm going to try to provide that mental image through the sound of my voice.
Okay, so let's look at get head in detail together. Now in the past couple of episodes, we've created
a working project space, which I think I just called HPR get in my home directory. I did.
And in HPR get, I've got Alice, I've got Bob, and I've got fake remote. So I'll just go into Alice
Alice's directory right now. And if I do an LAS, there's one file, 01.txt. And if I recall,
we left this in a healthy state, yet we did. And it says hello world, and it says welcome to get.
This is a version control system of indeterminate intelligence to use get effectively listen to
class use introduction on get to get on HPR. Oh, thanks, Alice. So it's not a very exciting
project to look at, but it'll do. So now if I type in get branch, we should see the remnants of
all of our past experimentations. Yeah, we do. So I'm on currently, I'm on get branch, I'm on master.
But in the past, there have been branches, or if there are branches now called dev, Bob dev, and Alice
revision. So that's four branches total, right? Master dev, Bob dev, and Alice revision. Now,
if you'll recall, when we first created all of this, all of these repositories, we kind of,
we saw this secret directory called dot get. So if I do an LAS dash a, we see that there is indeed
still a dot get directory. And I told you not to ever go into dot get and not to really mess
around with it. And I'm still telling you that, but we might as well take a look. I mean, we're
curious beasts. So let's do a cat of dot get. No, let's not do a cat yet. Let's just do an LS on
dot get. And you'll see in there that there is this this file called head. All capital letters.
So let's do a cat on dot get capital H E A D. So if I do a cat of dot get head, then it's a
single line. And currently it says ref colon refs slash heads slash master. That's interesting.
So I wonder what that's referring to. Well, if we look back up at our list of dot get,
we'll see that in addition to this one file called head, there was also a directory called
refs, which is exactly what this string starts with head refs. So let's do an LAS on dot get slash
refs. And sure enough, we see that in in that directory, there's a directory called heads
plural now. And if you look in slash heads, you see that there's Alice revision. There's Bob Dev
and there's Dev and there's master to do those sounds familiar to you at all. Of course,
they do. They are our current branches. They're the branches that we created so long ago.
They're still there. Their references of them are here. So as an experiment, just wacky experiment,
let's do a get branch dash D as in delete. And that is what it means. That is what we are going to do.
And let's get rid of Bob Dev. Bob underscore Dev. I'm just going to delete that branch.
And it tells me as feedback deleted branch, Bob Dev was B6C8F2. So now let's do an LAS in dot get
slash refs slash heads again. And sure enough, our total number of heads have been reduced to
three. Alice revision, Dev and master. So the reference to Bob Dev is gone. So when you're creating
branches, that's what these things are. That's what's happening behind the scenes. It is creating,
I guess what we could call a bookmark or a, yeah, kind of a bookmark, really, to a specific
point in your get repository, a certain version of your get repository. But don't worry about that
too much right now. But that is exactly what branches are. Like if you think, well, when I create a
get branch, how is that happening? That this is what's happening? That this is exactly what's
happening. So if you do an LAS-L on dot get slash refs slash heads plural, you see that each branch
is exactly 41 bytes of information. And we can even, if we're really curious, we can do a cat
of dot get slash refs slash heads. And let's do, let's cat master. And this returns a
shawesome, which is too long to memorize, but we can remember the first three in the last three.
So it's C9C and EC0 is the hash that we have here in master. So what do you suppose that's
referring to? Well, if we do a get log, then you'll see that that refer or that in this message,
in the message that is returned to us from get log. I think like I've mentioned get log before,
right? This is kind of the history of everything that we've done in this get repository.
And you see that the very top result of get log. And actually, if you don't want to see all
that information, we can do a get log dash dash one line. That's all one string, just one line.
And that gives you just kind of the highlights of your get log. So it gives you the first,
the first part of the hash and a brief description of what that commit was. So we see the top one,
the top result on this one is C9C D11F. And if we do that cat again on dot get slash ref slash head
slash master, we'll see that oh, there it is C9C D11F. So yeah, that's the same one. So in other words,
this head entity called master is currently, currently matches our latest commit. So that's
kind of interesting. Now let's do a cat of dot get slash head, all capitals. If you'll recall,
that referred to ref slash heads slash master. So in other word, head, the magic word head with
all capital letters, HEAD is a sort of a simlink or a pointer or a reference to a specific branch,
which is called master. So now if I create, I'm going to just create, I'm going to say echo,
this is my new file into a new file called zero two dot txt. Okay, so now I've just changed my
current state, my current working directory has now changed, right? Before I had zero one dot txt
with a bunch of stuff about about get. And now I've got this new file, which did not exist before,
called zero two dot txt with something inane dumped into it. So has that changed anything? Well,
yeah, it's changed my working directory. It is my workspace is now different. It is no longer
the same as it was before as of my last commit. It has it has it has moved forward, right? I committed
this, what we'll call C9c. I committed that. It took sort of a photograph of it and gave it a
hash or a little shawesome so that we can we can identify it. So it's I'll just call it C9c because
that's easy. And that's what returned when I said get log that was the latest commit. And now I
have changed the contents of this directory. So if we were to somehow take a snapshot of what we
have right now, that would be different, right? That would result in a different shawesome
than what our latest commit had. We have moved forward in time from our latest commit.
Okay, so let's do another cat of of dot get slash ref slash heads slash master. And now if you
look at the result, it is still for me C9c d1 1f, meaning that the head reference is still on
the latest commit, meaning that I have gone forward in relation to where head is pointing
in my work. So if you think of, for instance, that tape technology, then I've kind of I'm
I'm now I've recorded content on the tape that the playhead has not yet experienced. So if we're
if we're playing back a cassette tape, we're on the part that we're on the part of the song that
has not happened yet. We're at the bridge playheads way back here on the first verse.
If we're thinking of it more along the lines of my physical demonstration with the camera
pointing at your table top and you've written things on paper, then what's what's basically
happened is that your camera is looking down at your hello world paper and you've taken a pen
and you've written some stuff on that other piece of paper that your camera is not pointing at yet.
Okay so that is what is happening. So head is still pointing to the current commit to the
current branch even. Now if we did something crazy like we did a get checkout of actually I don't
remember what branches are. So get branch. Okay so now we'll do a get checkout of Alice underscore
revision. We've switched to the branch Alice underscore revision and we're all up to date with
origin slash Alice revision. And now if I do an LS I see that I've got my original file hello world.
Oh but I've still got my my zero two dot TXT. That new file that I dumped in is still here in my workspace.
And that's fine and that is to be expected because uncommitted changes travel with you. They
haven't been. Remember I said in I think two episodes ago maybe one. I was talking about sort of
I was making the analogy of of using Gimp where you get you you cut something out of a picture
but before you haven't anchored it yet. So it's kind of this floating layer and that's what all
of my new changes are. They're still there still in the future as far as the playhead is concerned.
So what is our head then has that changed still or yet or is that still the same? Well let's check
it out. So we'll do a cat if you remember where the the head information is is kept it's get a cat
on dot get slash all capital head. And now it says that it's rep of reference it's it's ref refs slash
heads slash Alice revision. So I'm imagining that if I do a cat of dot get slash refs slash heads
slash Alice revision I should get a different show sum back. I should not see C9C 11F or whatever it
was. And indeed that is correct. So the new show sum of my head is E3A0493CC. So this head is
referencing a different commit. It's a different version of well reality. So watch what what happens
if you do a get log dash dash one line. You'll see that history itself has changed. So the top the
top entry in your get log is this E3A0493. We've never seen that before or maybe we have but it
what certainly wasn't at the top of our get log. And then there's seven E6 and DF1 and D262.
There's this whole sort of history in this branch that doesn't really exist in our master branch.
So if I do a get checkout of master and I do the same command get log one line. Then I will I
could kind of compare the two. I could say okay well the top one on Alice revision was E3A.
The top one in my in my in my master branch is C9C. Okay well that's different. Ah but the
second one in my master is E3A. So the second one down from my master is the first one down from
Alice revision. Why would they be the same? Well that's because we at some point in the previous
episodes we took Alice's revisions and merged them into master. So we we brought at least some
portion of her history into our into our master branch. Now interestingly it diverges a little
bit at some points. There are some things that appear in Alice's history that do not appear in
the master branch. And there might be some things certainly in the master branch that do not
appear in the in Alice's branch. And the same would be true if we switched over to the dev branch
or if we hadn't deleted Bob's branch. We would we would see a completely different history
sometimes and then some similarities other times. It just kind of depends. Okay so we've still
got this weird file hanging out with us this zero two dot TXT. And and that's okay. It's not
committed yet. It's not staged for being committed. It's just hanging out. In fact if we do a
get status we'll see that there is an untracked file called zero two dot TXT. So get basically
doesn't know what to do with this thing. It has no idea what it should do is zero two dot TXT.
Now we'd be foolish to work on our master branch because if we checked in bad code we could break
things. So we wouldn't want to do that even though I do it in real life all the time which is not
a good idea. So I'm trying to get away from that because it's really a it's poor practice. So I
guess I don't actually do it all that much anymore. I work at least in a ranch and then merge to
master and then push to master although I should probably to be fair maintain a more active dev branch.
Anyway as I'm as I'm getting distracted here. So we're going to we're going to get we're just
going to make a new branch for ourselves because branches as we have seen are cheap they're free
and they're cheap. So you can do a get branch we'll just do new file is what we'll call the branch
all one string. And now if I do a get status it'll tell me that I'm on branch. Oh I want to get
check out new file. There we go. And now if I do get status I'll see that I'm on on branch new
file and there's still that untracked file of zero two dot TXT. So what I'm going to do on this
branch. This branch is completely safe. I can do whatever I want to. So I could do something like
echo here is more text in the file and I'll redirect redirect into zero two dot TXT.
And then I guess I'll go ahead and just I guess I might as well just commit that. So I'll get add zero two dot TXT
and then I'll get commit dash m for message added a second file. There now I'm done. I haven't pushed
that to my remote yet but so I should probably do that right because this is if my computer dies
today then I'll want to know that it's it's backed up somewhere. So I'll do a get
origin nope sorry get push dash u right the dash u means send my branch to the remote
origin and then again head. So just to remind ourselves what where is head right now? Well
okay so we're not going to get push yet we're going to backup. So let's do a cat of dot get slash
capital head and it's telling me that it's pointing to ref's heads new file that makes sense. So
then if I do a cat of dot get slash ref slash heads slash new file it gives me a new shawesome
EF3 8806 okay so where does that come from? Well that's my latest that's my latest commit right
the one that I just made added a second file EF3 8806 blah blah blah so it knows that I have now
into my into the view of my camera I have moved that piece of paper that was kind of off screen
for a while I've moved that under under the head of my working of my of my get repository.
So now if I get checkout master and I do an ls 0 2 dot txt is gone it's missing where did it go?
Well that 0 2 dot txt file we've just changed what our camera is looking at again right we had
that new text that 0 2 dot txt file under our camera in our view and then we swapped it out for master.
So anything that we wrote on that one piece of paper is now out of view it's out of sight is it
gone? No we're not infants we know that when something moves out of view it doesn't necessarily
cease to exist it simply is not in view right now so if we do a get checkout again back to new file
we do an ls there's 0 1 dot txt and there's 1 and there's 0 2 dot txt so as you can see it's
it's really actually quite difficult to lose work in a get repository
because you can always just kind of switch branches right you can you can bookmark any iteration of
your your world of your workspace and leave it behind just go wandering off onto some other
tangent and get won't it doesn't it's not like you've thrown the file away it's not like you're
abandoning it you've you've just bookmarked it you've said you know what keep that little snapshot
of what of what this looked like and and don't ever show it to me until I ask for it hide it away
from me in a branch all its own and then I will I will come back later and and and I'll be sure to
grab it so now if we do a get log dash dash one line for on my current branch which I think is
a new file yep it is so I'm going to do one line looking at the shaw sums I've got a pretty
straight pretty straight mimic of my master branch I've got the EF 388 and then it goes to C9c
and then E3a and then the rest of of master history so this is a branch that has been forked off
of master it's been branched off of the master branch so it's really really similar to the master
branch which means that it's really easy to merge those two together and we've done this before
so I'm going to check out I'm going to do it get check out master and then I'm going to get merge
and if you'll recall the default is to merge into whatever branch you're currently in we know that
we're in master because we just checked it out so get merge new file now this is interesting so
watch look look what it says here it says get merge new file updating C9c to EF 38806 and then
it says the word fast forward so remember how I was trying to give you this picture of like a
playhead and a cassette recorder and I said oh what we've just added this new file this zero two
.txt and we've done that in the future it's it's it's a head of the playhead the playhead is not
experienced that music on that cassette tape yet it's the bridge the playhead is way back at the
first verse well that's what this is that's that's what it's why it's calling this a fast forward
merge it is taking the playhead and it's sort of playing back the tape ahead of it so all those
new things that you wrote on the tape the playhead is now experiencing it is adding that to your
reality to your your workspace and now if we do an LS we see that there are indeed on the master
branch is your one .txt and zero two .txt we have fast forwarded our workspace we are now
current with our playhead and our head has been updated right so if we do a cat on slat or
.get slash ref slash head slash master we see that the the reference or the shawesome rather is
EF388 and if we do a get log you see that the latest commit is indeed shawesome EF38 added a second file
so that's exactly what we would expect now if we did something crazy
like rm zero two .txt that's that this is my least favorite command in all of you next
them is rm I think it's a stupid command and I'm I'm using it I'm blowing this file away just like
the creators of rm intended for it to be destructive and absolute so rm zero .txt now in real life
maybe you didn't do that maybe you wouldn't remove a file or maybe you would you would but you'd
know that you just pushed it to get so you wouldn't really care but but in in in real life you tend
to do stupid things right you you you think you have this great idea for a new function in a program
and it requires a little bit of refactoring and so you go through and you start making changes and
and by the end of the the hour you realize you've completely borked your program like all of your
ideas were bad and you have completely scrambled the code and it will not even pretend to launch
anymore so you start to panic and you think oh gosh now I've really messed things up and I never
created a branch and really bad things are happening well the cool thing about this and it
depends on the situation but but let's assume that you had not committed anything and we'll we'll
get to the cases where maybe you have committed stuff before but the the easy fix to that would
simply be to return to the last known good state which as you and I now know is called head
the way to return to head is you do a get so so I'm going to just do an LS so I've only got
zero one dot TXT now that's all I've got I've got no zero two dot TXT more if removed it it's gone
everyone knows that if you do that on Unix it's gone so now we'll do a get reset head all capital
A G A D and hit return now this doesn't work the way that you think it works so it says it's telling
me hey there are unstaged changes after your reset and the unstaged changes are the the the
deletion or the capital D of zero two dot TXT so what does that mean well if we do an LS it basically
boils down to the the fact that those zero two dot TXT is still gone it's still it's still missing
so now you're really starting to panic well fear not so get reset is a fairly friendly command and in
this case it doesn't seem friendly it seems like it's conspiring against you but what it's doing is
it's looking at your at your at the state of your workspace and it's saying well I don't think
you really want to reset because you've got changes here and if I reset you're going to lose all
of your changes so that's a really really useful safeguard in the event that maybe you are trying
to do something that would result in in major loss of data like stuff that you've got sort of
in the works and you do an accidental get reset for some reason and suddenly you know your
your your unique data has has gone missing so you don't want that to ever happen and that's why
it defaults to not doing what you think it's going to do so get reset dash dash hard head so dash
dash hard in the space head all capitals that's like a force it forces the reset so head is now at
EF3888 added a second file well that sounds familiar we do an LS and there's zero one dot TXT and zero
two dot TXT sure enough they're back so there you go that's that's how you can leverage
the the last known state of head as something that you can always return to now there's more to this
because you can also fetch things from from other from other last known good states and this
is kind of an important one because everyone not everyone a lot of people need to do this at some
point in their lives and that is to rescue a specific version of a file from some other commit
from some previous commit that they've done so what we are going to do is we're going to try to
rescue the really old version of zero one dot TXT now to find out what that would be we can do a
get log dash dash one line I guess and it looks like we first added that file back in D52 that's
probably a pretty basic version of that file so let's do it so what if we didn't know all of that
information well we we know the commit hash right because we see it here in our get log one
really handy command or or option for get log is get log dash dash stat STAT and on a really
basic silly little project like this one you don't really you you might not even see the difference
at first but if you look carefully at each commit at the log at the bottom of each commit like so
before the next hash it tells you what file got changed and or added at that commit point so for
instance this this most recent one EF388 has added a second file and then below that O2 dot TXT and
then tells me how many changes were made to that file one file changed to insertions and then if
you scroll down down down down down you see D52 E37 delta added a text files 0 1 dot TXT one file
changed one insertion so it kind of gives you an overview of of the activity of each commit
which is really really handy if you're working with lots of other people sometimes you just you
want to see what exactly all the changes in compass so you can just do a get log dash dash stat
another way you can do it if you don't need all of that information is get log dash dash name
dash only you see the file that got changed so on the first one it's 0 2 dot TXT 0 1 dot TXT
which changed so it just tells you the name it doesn't tell you how many files were added or
anything like that so it's a little bit shorter so that's how you could find out both the commit
hash and the the files that are available in that commit so it's a little bit like looking at
you know at those old versions now you can even do it differently you can do get this so I'm
going to do a get log again but I'm going to do it on one line because I want to see them all on
one screen so let's do this let's do a get checkout of D52 E37 delta so that's the very first when
we first started this project and added our very first file we're actually going back in time
get checkout D52 and it gives me a big scary message and it says things like checking out D52
that's not scary but it says you are in detached head state you can look around make experimental
changes and commit them and you can discard any commits you make in the state without impacting any
branches by performing another checkout if you want to create a new branch to retain commits you
create you may do so now or later by using the dash B with the checkout command again example get
checkout dash B and then some name of a branch head is now at D52 E37 delta added a text file
so if I do an LS I see one zero one dot TXT if I cat zero one dot TXT I get the old old old version
that just said hello world okay so but but notice now that that we are in what they call a detached
head state so what does that mean exactly oh it's not that big of a deal it's not as as frightening
as it might sound no if I've detached the head was that supposed to come off is it supposed to
come off like that yeah it's fine you can do that it's just kind of an implication that time
should only typically move forward you should be any work that you're doing in your get repository
should be done to the right of the head the the right hand side of the head you know kind of like
symbolically the future state of your of your repository and now if you are detaching the head
and moving back along the tape you are now well in a what they call a detached head state and it's
just to represent that you're no longer in linear the linear path of your of your data necessarily
you're just looking at whatever branch in whatever state that you want to see it you're not
necessarily moving between current branches I don't know if detached is the best term for that
but that's what they call it so anyway here we are we're in a detached state we're at d five
two e three seven delta so we can do a cat of zero one dot txt which is the only file here and yep
there it is it is just the old hello world that's all that that's all it contains super simple
version of that file so now I'll do a get checkout of master again yep there we go on master
head is undoubtedly the latest commit so that's that's okay and now we can do a get checkout d five
two e three seven d and then just to break out of gets normal flow we're going to do a dash dash
so that's d five two e three seven d space dash dash space and then the name of the file you want
to restore so that's we know that is zero one dot txt and now if I do return there I should be
able to now do a cat zero one dot txt and sure enough it has been changed it's been overwritten
with the copy from way back when from seven five two e three seven d so we've just pulled
one file from a previous commit and overwrote data into what in our current workspace with that
file so has that changed the state of our head this is a little bit of a tough question has it
changed the state of our head no it has not now if you got that wrong don't worry you will get
it eventually but if you do a cat dot get slash refs and I'm going to explain why we haven't if
you've got that wrong master e five three eight eight right so it's it's that it's that top
entry on our get log remember head always points to some commit on some branch head is never
pointing to a workspace that is what a branch is for you can create branches and that's a little
sandbox for you to do whatever you want you can pull in files from the past and paste them back
in you can change files you can delete them you can do whatever you want in a branch head always
points to something that has been committed it's a fixed point in time everything else in branches
and stuff that's a little bit looser that you can create branches you can delete them you can
mess them up you can do whatever you want in a branch it's free for all okay so now that what
state are we in now well we know where our head is we it's on master it's on the latest
commit of master that's cool but what what is our workspace look like so we do a get status
and it tells us that we are on branch master that's good and it tells us your branch is a head
of origin master by one commit it also tells us that the get the that the that the that the file
is modified zero one dot txt is a modified file so if we wanted to make this change permanent like
if we really liked the first version of a one dot txt then we can just do a get add just like normal
dot zero one dot txt get commit actually we liked our first version better and then get push
origin head so now we've got c9c has been advanced to ec15b30 so in other words our head has
moved to the latest commit of master and if we do a get log we'll see that the latest commit on
master is ec15b3 and it says actually we liked our first version better and if we do a get log
dash dash stat or name only then we'll see that yep zero one dot txt had a bunch of deletions
one file changed one insertion six deletions and of course if we do a cat on dot get slash
ref slash head slash master we see that it is pointing to ec15b now if we do a get status
it tells us that we are on branch master our branch is up to date with origin master
and there's nothing to commit and the working directory is clean i hope this has been somewhat
informative i think the concept of what the get head is frequently confused as people and
and it's one of those things that you can go for years and not have to understand
and then slowly as you continue to do more and more complex get operations
you realize you really do need to kind of understand that thing so if you don't understand it right
now i honestly wouldn't worry about it i would keep living your life the way that you live it
do whatever you want respect no authority just go crazy but at some point if you start doing
weird things like oh i've got to do these get rebases and these get merges and these get
these get checkouts from the past and all these other things and i don't understand why it keeps
warning me that my head is here but my head is there and and that my working director is
in such a state and my detached head and all these other things if that starts to confuse you then
come back to this episode and relisten to it and try to wrap your my try to wrap your head around
get head i think we have a title thank you very much for listening i will continue the get series
at some point in the future and you will fast forward your get head to experience those changes
you've been listening to hecka public radio at hecka public radio dot org
we are a community podcast network that releases shows every weekday Monday through Friday
today's show like all our shows was contributed by an hbr listener like yourself if you ever
thought of recording a podcast then click on our contributing to find out how easy it really is
hecka public radio was founded by the digital dog pound and the infonomicon computer club
and it's part of the binary revolution at binrev.com if you have comments on today's show
please email the host directly leave a comment on the website or record a follow-up episode yourself
unless otherwise stated today's show is released on the creative comments
attribution share a light 3.0 license
