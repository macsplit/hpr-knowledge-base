Episode: 4332
Title: HPR4332: Top 5 mistakes every new terminal user makes
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr4332/hpr4332.mp3
Transcribed: 2025-10-25 23:12:01

---

This is Hacker Public Radio Episode 4332 for Tuesday the 11th of March 2025.
Today's show is entitled, Top 5 Mistakes Every New Terminal User Makes.
It is hosted by Claw 2 and is about 24 minutes long.
It carries a clean flag, the summary is, and how to avoid them.
Top 5 Mistakes Every New Linux Terminal User Makes and How To Avoid Them.
That's what I'm talking about on today's episode, my name is Claw 2.
So learning to use the terminal is an important step in becoming a true power user of Linux
or BSD.
But it's easy, and honestly very normal, and I'm going to cover some of the most common
mistakes we all make, whether we're just learning the terminal or just because it's an off-day.
So the first one, one, current working directory.
When you first open a terminal, your current working directory is usually your home folder.
I mean, there are exceptions, there might be some, you might have it set differently,
but generally speaking, that's your default current working directory.
It's your home directory.
You have access to all the directories you see in your home directory, like desktop
and documents and downloads, music pictures and videos, and so on.
And you can verify your location with the PWD command.
PWD, from what I recall, means print working directory.
And print in this context is to display, doesn't literally mean to print on paper.
It just means it's going to print it to the screen.
So PWD type that in, it gives you your current working directory, which in this case is
slash home slash class 2.
Well, you can list the files and folders within your current directory with either LS or
DR or tree, whatever command you prefer, and then you see all of those directories.
But you don't usually stay in one place while using the terminal.
You usually, I think by, it's just sort of common because you don't want to type in all
the paths, you usually move from folder to folder so you can open or modify or edit files.
And it can be easy to get lost for getting what directory you're in.
So for instance, if I'm in my home directory right now, slash home slash class 2, and then
I want to look at some text in a file in my documents.
I can type in cat documents, my file, these are just, I'm just making stuff up right now.
My file.txt, and it shows me the text that's, that's in that file.
Where am I?
My documents?
Or am I in my home directory?
Well, I'm in my home directory, even though I've looked at a file in documents, so that's
pretty easy.
But like I say, you don't normally just sit around in your home folder going out to other
directories.
A lot of times you just go to the directory, so you do CD documents, and then once you're
in documents, now you can just do cat my file.txt, and you'll see all the contents for that file.
So in one case, I said cat documents, my file.txt, and then in the other case, I said cat my file.txt.
The difference is your current working directory.
One of those commands I was in my home directory, the other I had changed to the documents directory
and looked at the file.
It is very easy to forget where you are, whether you're in your home or in documents or
in slash ETC or, or who knows where else.
So whenever you're not sure, just use pwd, just type in pwd, and it will tell you exactly
where you are, and that will help your brain sort of frame what kind of commands you
need to do then.
Because then you know, well, if you're in home slash class 2, first of all, what are you
doing in my home directory?
If you're in your home directory, then in order to see a file in your documents directory,
you have to tell your computer that you want to operate on documents slash my file.txt.
But if you're in the documents folder already, then you can just do things with my file.txt
because you are in documents.
It's very similar, if you think about it, to just how you operate in your own home.
If someone says, hey, bring me that book.
If you're in a room with a book, you're going to naturally assume, oh, they mean this book
here on the table.
But if they say, bring me that book from your office, then you know, oh, I need to change
room to my office and grab that book that I have there and I'll bring it back out.
Same thing with the computer.
So lesson here, when you're working in the terminal, regularly verify your current working
directory with pwd so that you don't accidentally issue a command that you meant to run in some
other location.
Two, use interactive options when using wild cards.
Wild cards are a great short hand for making command entry at the terminal faster and
to perform bulk actions on lots of files that's useful for both of those things.
But they can be dangerous when you get them wrong.
It's easy to process hundreds of the wrong files by using a wild card in, again, the
wrong directory or by using a wild card that's like too broad.
For example, suppose you want to run, let's say, a said command to sort of do a find
and replace on all HTML files in a directory.
It doesn't matter which one, let's just assume it's a directory with a bunch of HTML in
it.
So you run said dash dash in dash place, quote, s to search slash day slash night slash
G closed quote, just doing this as an example space.
And then you think, okay, I'm going to just, I want to do it on all my HTML files.
So I'll just do asterisk ml that'll catch all the HTML files for sure.
You do that.
It works job done except then you realize that you've run all of that, you've run that
command on all of your XML files as well.
Maybe you didn't mean that.
You just wanted to do HTML.
And now you've, because you said asterisk ml, you've caught a bunch of, of, of other files
that you didn't intend in that net.
So the lesson here, run a safe test command on the wild card.
You think you want to target before making a change.
Some commands have a literal dash dash, dry dash run option.
Those are great.
Others have a dash dash interactive option.
That's useful as well that forces like the command to prompt you to confirm that you're
about to do an, an, an action on a specific file.
And sometimes the logic is reversed.
The command refuses to make a major change unless you use a command.
For example, said, um, said doesn't write changes to a file unless you use dash, dash
in, dash place or, or dash i.
So when in doubt you can kind of improvise around those concepts, dry runs and interactive
mode and in place mode, that sort of stuff, but you can always basically expand.
That's the important thing.
You want to expand a wild card before using your command and you can do that just by
using the echo statement, just if you want to operate on all asterisk ml files, just
do echo dot slash asterisk ml and it will, it will repeat the names of the files that
exist for you in that directory.
And you might see things like a one dot XML to dot HTML, three dot HTML, four dot XML.
And then that's when you realize, oh, oh, yeah, that's not good.
I, I really wanted to target all HTML.
So I'll do echo dot slash asterisk, TML or just HTML and then you would just get the
results.
What was it?
Two and three, I think, for the HTML files in my example.
So that's an important principle to keep in mind, no matter how long you've been using
a terminal, you think you've got wild cards down, just test your expression before executing
a command you cannot easily change back from three file paths.
This I've already touched on this earlier on, on sort of my example of handing a book
to someone when the book is in another room versus a book in the same room, but a lot of
new terminal users just it, it takes a lot of reinforcement and takes a lot of practice
to understand where files actually are.
So if you're very new to a terminal, you might open up a terminal and you, you will be
forgiven by for, for thinking that that terminal just has access to all of the files everywhere
on your system all at once.
I've definitely seen new users open a terminal and then run some command, you know, Cp myfile.txt,
yourfile.txt and there is no myfile.txt is just that's not where you're, you've just opened
a terminal, you haven't even looked around yet and you're already inventing like files
or, or, or supplanting files that exist somewhere else, like in documents or var, slash,
www slash HTML, you know, wherever they might exist, just because you've opened up a terminal
doesn't mean you suddenly, instantly have access to that file.
It may not be located in your terminal, I've already, as I said, I've already said like
you need to, first of all, figure out where you are and you know how to do that now.
You do the pwd command, but, but also you need to figure out where that, where the file
that you want to use is located in relationship to where you are.
There are two kinds of file paths.
This is where it, what confuses a lot of people.
There are absolute file paths and there are relative file paths.
So we'll, we'll back up.
So when you open a terminal again, your default location is your home directory generally speaking,
whether you're, whether you stay there or not is, is anybody's guess, but that's where
you generally are when you open up a terminal.
So you're in slash home slash, uh, tux, say your username is tux.
So slash home slash tux, and you want to operate on a file that's located on an image file,
a, a, a graphic, a photo that you've taken on your, on your phone, you put it on your
computer.
Now you want to do something with it.
You want to shrink it down or something or convert it to some other format.
So you know, you remember that you put that file into your pictures folder.
You are in your home directory right now.
So if you do a PWD, you'll get home tux.
You knew LS, you get desktop documents, downloads, uh, MNOP music, pictures, videos, some
other stuff probably.
Okay.
So that file is in pictures.
The absolute file path of your file starts at the very beginning of your hard drive slash
and then it continues from there.
So an absolute file path always includes as far back on your computer as you can possibly
go slash home slash tux slash pictures slash, I don't know, image zero zero one dot JPEG.
That's the absolute file path to that file.
Now the problem with absolute file paths is that they can be a little bit unwieldy.
They're long.
They always start at the very beginning of your hard drive.
It's as if though some, if someone was to ask you, Hey, what did you do today?
You always started exactly the moment you woke up.
Well, I woke up.
I got up at a glass of water.
I made some coffee.
I had some breakfast, you know, and you just go on and go on and go on until you get to
what they were actually asking, which is like, you know, what did you do during the past
two hours?
So absolute file paths are very all inclusive and sometimes arguably too all inclusive.
If you just want to do something quickly and without typing in a bunch of letters, that's
why there are relative file paths.
A relative file path is always based on your current location in your terminal.
So if you are in the pictures folder, then the the path to an image in the pictures folder
would be image underscore 0 0 1 dot JPEG or whatever I said it was.
Or you can do dot slash image zero zero one dot JPEG.
The dot slash means don't it means here, it means don't move from here and then find
this next place, this next location.
Or if you want to think of it as a as a short hand for everything I didn't bother typing
and then the file, that's that dot.
The single dot just means I'm here.
I'm exactly where I need to be for this file to to be accessible by me.
In other words, the absolute path of home slash home slash tux slash pictures slash image
dot JPEG could be the same as a relative path of dot slash pictures slash image 0 0 1 dot
JPEG if you are in your home directory.
It could also be the same as dot slash image 0 0 1 dot JPEG if you are in the pictures directory.
So the relative file path always depends on where you are and that that can be very
confusing.
That's the like absolute file paths essentially never fail like those are always hard coded
that is telling you exactly where on your system, the file exists.
It doesn't matter where you're looking from.
It's a full description of where that file exists.
It'll always start with a slash it'll always include every single step you have to take
to get to that other location.
The relative file path is based on where you are right now in your terminal.
It is based entirely on the output of PWD and so it can change practice those two.
Those are two really important things to really internalize.
You need to understand how to find a file with an absolute file path and you need and you
want to understand how to find a file with a relative file path.
Relative file paths are essentially intermediate tools.
It's a thing that can be complex but it can greatly speed up the way that you use your
terminal.
But it does take practice.
The absolute file path that's the one that you absolutely need to understand first.
It's longer to type, it's longer on the terminal, everything about it's horrible except
that it's super, super precise and it's really, really great.
Once you understand the absolute file paths and you're understanding that if you type
in two dots you go back a directory, if you type one dot you don't move, once you understand
sort of how to use relative file paths you'll be doing things a lot faster.
But practice both learn absolute first and then practice with relative four executable
permissions.
By default, most files are not executable.
You can't run them like an application because most files aren't meant to be run as
applications.
They're meant probably to be opened in an application.
But there are some files that are meant to be run as an application.
It's one of the really most powerful things about Linux.
Shell scripts are the most, maybe one of the most obvious forms of sort of files that
also masquerade as applications.
Shell scripts are really just text files, but they contain a list of commands.
And they're meant to be run like an application.
It's a scripted version of what you would have done anyway in the terminal instead of
doing it manually.
You just script it into a file and then run that file.
But a shell script starts out as a regular file.
And so it's not seen by your system as an executable entity to execute a file as an
application.
You must grant it executable permission with the Chamod that stands for change mode command.
So for instance, let's say we've written a shell script called example dot s h.
Oh, you can make that executable with Chamod space plus x space slash home slash tux slash
example dot s h wherever that file is located.
In this example, it would just be in your home directory.
But maybe you put it into your into a folder called bin or or apps.
Then it might be Chamod plus x slash home slash tux slash apps slash example dot s h again.
You kind of need to know where things are located in order to operate on them.
So keep that in mind.
But alternatively, you can run a file in a in a sub shell.
You can do for instance, instead of Chamod plus x, you can just do bash dot slash example dot
s h, assuming you're in the same directory as example dot s h.
This essentially launches a new terminal that you don't see.
It's not really launching a terminal.
It's launching a shell that you don't see and running the contents of example dot s h in
that shell.
So those are two ways of executing files on your system that aren't really like they're
not binary executable files.
They're not really applications, but they can look at the contents of a file.
Well, one makes that file executable so that your system just accepts.
Yep, I can I can run the contents of this file as if though they were commands.
And the other launches a shell that then reads the contents of that file and runs them
as commands five typing mistakes is like a law of, you know, probability or something.
The more the more you type, the more likely you are to make a mistake.
I mean, that that it makes sense, right?
If you type just a couple of letters, the opportunity to get that wrong is less than
when you type a bunch of letters.
And so it's, it's no joke that a lot of terminal users of people who use terminals a lot try
to type not much like the, the less you type, the more accurate you are.
And this is so true that there are a bunch of little hacks around having to actually
press the letters on your keyboard.
And a lot of people joke about this and say, you know, oh, your term, people using the
terminal are really lazy, cis admins are lazy, programmers are lazy.
You just don't like to type too much.
You, you want really short obscure names because you just want things to be obscure or whatever.
Like it's all good and fun, but, but there's, there's an actual like reason behind it all.
Like literally just typing LS, it is easier than typing list.
And you can test this out for yourself by making an alias sometime if you want.
I wouldn't do this, but you could, you could do this.
You could make an alias for like LS and just like export list equals, how do you do alias
is just list equals LS, is that how you do that?
List.
No, that's not how you do that.
Export, I don't, I forget how to make alias is, oh, no, you don't do export alias alias
list equals LS, that's how you do it.
Now I type in LIST and it runs the LS command for me.
Great.
Live like that for a day and you will, you will see very quickly that instead of typing
LIST, half the time you're typing LSIT or LITS or ILST, you know, it's a, it's just like,
you know how often you type the in real life, right?
How many, think of how many times you've, you've typed t instead, t-e-h, that's three letters.
It's just three letters.
And yet one of the most common spelling errors we as typists make is t instead of the,
the same is true for everything you are doing in the terminal.
Okay.
So lots of different ways around this, the classic one is tab, the tab key.
You can type part of a command or a file path and then you press tab on your keyboard.
And it'll autocomplete what it can or it'll suggest valid completions that it can find.
It's not, it's not like using a dictionary for this.
It's looking, it's looking at where you are, where you're typing and, and looking at the
files and folders that exist there and suggesting to you that maybe you want to just auto fill
the name of this file because the first three letters are the same and nothing else matches
so it must be this file.
So you hit tab and that just autocomplete it.
Again, if it's not, if it's not autocompleteing it, like if there's two files that start out
the same, then it'll, it'll echo, it'll print those two files on your terminal so that
you know how to kind of continue, like image underscore zero one or zero two zero one or
zero two.
Oh, okay.
I guess I have to type in zero two and then it auto fills the rest of the name for me.
So that's a really useful one and it's frankly vital and it saved me several times from
stupid mistakes and that's because sometimes you're typing and you press tab and it doesn't
auto complete.
And so you press tab a bunch of other times really angrily and you think I hate Linux so much
it's so stupid.
It's not, it's not auto completing the stupidest and then you look and you're like, oh, it's
not auto completing because I'm not in the folder that I thought I was in.
Right.
Okay.
Yeah, let me just back out of that.
I love Linux.
I'll get back to the directory that I thought I was in and then I'll start typing and press
tab.
And then I'm going to use several times like I always second guest tab.
I always think that it's tabs fault for not auto completing and then inevitably I look
and I realize no, tabs not auto completing because there's nothing there to auto complete.
I'm an idiot.
I need to go to the right place or or use the right capitalization or whatever the problem
is.
Tab is huge.
Use tab a lot.
Okay.
Another little hack around this.
Dragging and dropping.
It is the 21st century, officially at the time of recording.
You're listening to this in like 75 years from now.
You may find that it's the 22nd century, but for now it's the 21st century.
You can drag and drop files and folders from anywhere on your computer into a terminal
and it'll just get replaced by the text version of that file.
Like I can open a terminal.
I can click on this on this random file or not click out drag click and drag that file into
my terminal.
And there it is.
Tom slash clatu slash ram disk slash chapter dash 12 dash blah blah blah.
So yeah, there's it just it gives you the it resolves it for you.
You don't have to type in everything yourself.
So dragging and dropping in most term, most modern terminal applications will let you just
drag and drop files straight into it and it'll quote it for you correctly.
It'll escape all the special characters.
It is just so easy.
Okay.
And it does that with absolute file paths as well.
So so that's a great way to sort of reinforce.
Well, where where is this file on my so on my system?
We'll drag it and drop it into terminal.
You'll see exactly the full path to where that is.
Okay.
And then finally, there's copying and pasting again, 21st century for a modern terminal.
You can just type control shift V to paste something in.
So if you if you go out again, just to a file manager, right click on a file and then
hit copy and then go to the terminal, control shift V, there it is.
There's the file.
The full again, the full path of that file just gets pasted in correctly, correctly escaped
and everything so that you don't have to worry about typing the whole path and you
don't have to worry about special characters.
It just does it for you.
So those are three really, really reasonable ways of getting around typing.
There is a fourth way and that's wild carding, but I've already kind of talked about wild
cards and how they can be dangerous.
So sometimes I don't really, I don't know when I use them.
I have rules in my own head for how often I use wild cards and it's like three times a
day.
No, it's not it's not based on on that, but like it's like just, is it, do I know that
the file?
I don't know.
I don't know the rule, but I have a rule and that is that I guess I use it for bulk
op operations a lot.
But my point is that if if a wild card can save you from typing a bunch, then quite often
that is very useful, although I guess what I'm also saying is in practice, the tab key
kind of does all the work of wild carding for you with a lot more certainty.
So I think I probably, yeah, I think I default the tab far more often than I resort to a wild
card.
Finally, that's that's five.
So I'm done, but practice makes perfect.
That's the key.
If you're learning the terminal, just keep learning it, but in order to learn it, keep
using it.
You don't have to use it as often as you possibly can.
That is the only way to learn that how to get around in the terminal, how to be comfortable
in the terminal, how to be good in the terminal.
It's just literally using it very frequently, very often, just use the terminal.
So I hope this has helped anyone who is new to the terminal or who doesn't use it often
enough, maybe to sort of get used to all of the different things that you might run into.
You can be frustrating, but hopefully these tips have helped you maybe circumvent some
frustration.
Keep using it.
Keep learning it.
You'll get really good at it.
Thanks for listening.
You have been listening to Hecker Public Radio at Hecker Public Radio does work.
Today's show was contributed by a HPR listener like yourself.
If you ever thought of recording podcasts, you click on our contribute link to find out
how easy it really is.
HPR has been kindly provided by an honesthost.com, the internet archive and our syncs.net.
On the Sadois status, today's show is released under Creative Commons, Attribution 4.0 International
License.
