Episode: 2942
Title: HPR2942: Why I love lisps
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr2942/hpr2942.mp3
Transcribed: 2025-10-24 13:38:25

---

This is HPR Episode 2942 for Tuesday the 12th of November 2019.
Today's show is entitled Why I Love Lips.
This is the first show of our new host, Nielazo,
and it's about 8 minutes long and carries a clean flag.
The summary is, a very wooden scripted episode about why I love the Lisp programming language family.
This episode of HPR is brought to you by Ananasthost.com.
Get 15% discount on all shared hosting with the offer code HPR15.
That's HPR15.
Better web hosting that's AnastomFair at Ananasthost.com.
Hi, I'm Nielazo.
I'm new to recording for HPR, and I decided to do my first episode on something I think
it's certainly of interest to hackers, but somewhat overlooked, Lisp's.
I'm going to explain what Lisp's are, introduce some cool things they can do, and hopefully
explain well enough that you can maybe check out using a Lisp for your next project.
Before I start, I want to say I have no formal qualifications in computer science whatsoever.
I've never worked as a software developer, and I've never worked on any large projects.
So take everything I say with a grain or two of salt.
I'm also slightly ill when I'm recording this, so forgive my voice for sounding weird.
Now that's out of the way, let's talk about Lisp's.
And to start, I guess I'll explain what a Lisp is for those who don't know.
This is a simplified definition, and it's certainly narrower than it maybe should be.
Lisp's are a family of programming languages that all shares some interesting traits.
The one that is most obvious is their syntax.
Lisp's all use a syntax called S expressions, which are far simpler than the syntax of any
other language.
Also, all support first-class functions and tail calls, making them ideal functional
programming languages.
They also all support rappel-driven development, which I'll talk more about later.
The most interesting feature of Lisp's to me, though, is their support for meta-programming,
which I'll also go into more detail about soon.
The three most popular Lisp's are common Lisp, Scheme, and Closure.
Let's start with the most obvious feature of Lisp's, S expressions.
S expressions make up the basic syntax of all Lisp's, and they're incredibly simple.
The only significant symbols are the open and close parentheses.
That's it.
S expressions are also written in prefix notation, so 1 plus 1 would be plus 1 1 in Lisp.
This confuses a lot of people at first, but it leads to an overall more consistent language,
and they are also incredibly easy to pass for developers of interpreters.
It's very difficult to describe syntax in audio, so I'll put some examples in the
show notes.
To some programmers, this is scary, and they find it difficult to read.
I omit there is a learning curve, but once you get more used to it, you wonder why the
syntax of other languages seem so clumsy and inconsistent.
The simplicity and regularity of Lisp's expressions means Lisp can be edited not just as
text, but structurally.
Addit to plugins like PowerEddit and PowerInfer allow you to directly edit the structure of
your program, which leads to far quicker development.
Speaking of quicker development, people sometimes speak about how much quicker they can develop
software in Lisp's.
This is mostly down to another key feature, Ripple Driven Development.
Ripple is a short term for a redeveloped print loop.
This basically does what it says on the tin.
It reads in some code, evaluates it, prints out the result, and then loops around.
Now, you might be thinking, so what?
Python has a Ripple, JS has a Ripple, what's new?
But the difference is Lisp Ripples tend to do more than just that.
A traditional development workflow with a language like C is write, compile, execute.
You write your code, compile it, and execute it.
Languages like Python remove the second step, so it becomes write, execute.
Python also has a Ripple, but it's disconnected from the rest of a Python development environment.
It's useful for quick prototyping, but you won't be using it while you write your actual
application.
Lisp Ripples are very different.
They usually have error handling.
You can customize how they run, and they're very tightly integrated into the development
environment.
When I'm writing closure and I want to test a function, I can just select it to my editor
and it will make that function available in my Ripple session so I can test it.
And within the editor, I can access the Ripple and modify parts as it runs to have incredibly
quick iterations.
This integration of the Ripple with the development environment changes programs from being something
written and then run to a completely live and interactive environment.
The speed at which I could update and iterate on my closure programs blew my mind the
first time I used it, and I cannot overstate how great of a tool it is to have.
I won't go into the functional programming stuff here, that would be better suited to
its own episode, but Lisp's were the original functional programming languages, and in my
opinion, still some of the best.
You can expect tail recursion, proper anonymous functions, minimize state, and all that neat
stuff.
So this is great.
We have a functional programming language, with a simple syntax.
We have added tools to make writing get quicker than any other language, and we can very
quickly iterate on changes we make to our program.
We still haven't actually got the most powerful feature of Lisp's, home of Iconicity and
Macros.
Home of Iconicity is the fact that Lisp code and Lisp data are the same thing.
Your program is an S expression tree, which is also the way data is commonly represented
in Lisp's.
This allows for powerful meta programming, Lisp sub macros which work similarly to functions,
but instead of returning a value, they return S expressions.
And these aren't like C's text substitutions, they are insanely powerful.
You can do anything in a macro, you can do in the rest of your programs, which leads
to insane extensibility.
For example, closure has libraries that add features like pattern matching, or even prolog
esch logic programming, and these are nothing more than libraries that contain macros.
I have no chance of being able to properly explain all of meta programming in this episode,
but I encourage you to check it out.
Using macros and meta programming, you can also modify and build the language around
what you want to do.
For example, overtone, which is a closure library to create computer music, contains macros
which add new constructs to closure specifically for music, like constructs for defining instruments
and a global metronome and timing system.
So, why do I like Lisp's?
Because I can program a whole lot quicker than in other languages, and I can program functionally,
which I prefer over other paradigms.
I can modify the language as I see fit to make doing exactly what I want to do easier,
and I can have edited tools that mean I have to do a whole lot less typing.
Hopefully, after this episode, you want to give Lisp's a shot, and if you do, I recommend
learning scheme with the schema box, the little schema, and the season schema.
However, those are quite academic rather than real world.
If you want a more practical approach, idlo enclosure, it's the most practical real world
Lisp, and it has plenty of great resources.
I learned using a book called Closure for the Brave and True.
I heard this episode has been informative, interesting, or at least some good background
noise for whatever you're doing, and I would like to thank HPR for providing a platform
for podcasts like this.
Hey, this is Neil Arzo, when I'm editing this, I'm sorry that this was so wooden.
Like, I really do care about Lisp, but it's hard for that to come across when I'm reading
off a script.
You've been listening to Hecker Public Radio at Hecker Public Radio dot org.
We are a community podcast network that releases shows every weekday, Monday through Friday.
Today's show, like all our shows, was contributed by an HPR listener like yourself.
If you ever thought of recording a podcast, then click on our contributing to find out
how easy it really is.
Hecker Public Radio was founded by the Digital Dove Pound and the Infonomicon Computer Club,
and is part of the binary revolution at binwreff.com.
If you have comments on today's show, please email the host directly, leave a comment on
the website, or record a follow-up episode yourself.
Unless otherwise status, today's show is released on the creative commons, attribution,
share a like, 3.0 license.
