Episode: 3447
Title: HPR3447: BlacKernel's Journey Into Technology: Episode 2
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3447/hpr3447.mp3
Transcribed: 2025-10-24 23:36:43

---

This is Hacker Public Radio Episode 3447 Fortunity, the 19th of October 2021.
Today's show is entitled, Black Hernell's Journey into Technology, Episode 2.
It is hosted by Black Hernell and is about 21 minutes long and carries an explicit flag.
The summary is in which Black Hernell struggles to talk about Windows.
This episode of HBR is brought to you by an honesthost.com.
Get 15% discount on all shared hosting with the offer code HBR15.
That's HBR15.
Better web hosting that's honest and fair at An Honesthost.com.
Hello and welcome to Hacker Public Radio.
My name is Black Hernell or is he Lee Boots?
This is the second episode of my Journey into Technology series.
I really didn't want to record this episode because it's about when I used Windows and I hate it,
but you know, this has to go in chronological order and so that's where we're at.
Where we left off last time was that I had just gotten my very first computer and it was a
desktop computer. I got a monitor for it. It was one of those plasma monitors VGA and all that
and it had on it Windows XP. I was really excited because even though it ran like
barely at all, it was mine and I was able to do whatever I wanted with it and that meant that I
could customize it in whatever way I chose. I could just sort of mess with the computer.
So before this, as you might know from the last episode, I was introduced to a lot of the concepts
of sort of low level programming like with assembly code and that sort of thing and so I knew a lot
that like the computer is supposed to do what you're told to and you can customize, you can really get
sort of into the weeds as far as the computer is concerned. I mean, one of the stories
that my dad told me about when he was using a mini computer which was the ones that were the size
of like a wardrobe or a closet was that they would have these big cassette cartridges that they
would put into it and one of his colleagues at the college that he was at made a computer program
that made the physical wardrobe-sized computer sound like a washing machine where I would go
through the rinse cycle, the spin cycle and all of that stuff. It would like actually make the
computer physically move and shake because of it was basically operating the reels at a certain
frequency. It was basically running code in order to do that and that sort of thing has always been
really interesting to me. But being able to sort of customizing it into like the computer will do
what you tell it to do if you tell it to do the thing was the thing that really interested me about
computers. Now, Windows wasn't the worst for this, so I'm told, although now that I'm thinking about
a kind of, I mean, it's kind of a tie between Windows and Mac really, but the thing that it was
was that on Windows there's a lot of these freeware apps or these sort of hacky buggy code that
people write for Windows and then they released onto the internet. Stuff like stuff like auto-hacky,
that's what I was trying to think of. Auto-hacky is a, I mean, it's a necessary and very
featureful application, but if you've ever used Auto-hacky, it looks like it came, it does not
work terribly well. It is not integrated at all with Windows, the Windows operating system,
et cetera, et cetera. I need to get back into the mindset of where I was at the time because this
wasn't what I was thinking about at the time. What I was thinking about at the time was that all
of these applications were really cool because I let me customize my computer and I downloaded a
bunch of them and I was able to use the command line on Windows, the command prompt as it's called,
which was based on DOS and not UNIX, so you had like DIR for directory instead of LS for
list directory, et cetera, et cetera. I used a lot of that sort of command line interface because
that's what my dad was used to, that's kind of how I understood was the direct feed into the
computer as it were, and so I wanted to sort of get into that. I did a very light foray into batch
scripting that's a Bravo, Alpha, Tango, Charlie Hotel. That's how you spell batch, right? Yeah,
I think so. But batch scripting unlike batch scripting. Well, they're sort of similar, but it's
batch scripting was a lot. I'm getting back into my modern mindset. At the time, I thought it was
really cool because it let me write all of the commands that you could do on the command line without
having to write them out every time in much the same way as you would do on a batch script on Linux.
I can feel my soul slowly draining out of my body as I talk about the software writing system. I
really, really don't like Windows because a lot of it has to do with the reason why I switched away,
but I need to go through it because it's what happened. So what I was getting on this was I wanted to,
I was really inspired by the movie Independence Day. There was a scene in that movie where the sort of
the scientist had a computer that when he booted it up, said, good morning, Dave, and I had a
hal 9000 from 2001 Space Odyssey. It has had the glowing eye on there. I thought that was really
cool. I wanted to sort of get that sort of aesthetic on my computer. So I got, there was a
freeware app that I was able to get that would modify your boot logo. And I got that on it. I was
able to modify my start menu. I was able to move around a lot of the theming for Windows and I was
messing around with batch scripting and all that kind of stuff on the command line. And I was really
getting into sort of like the nitty gritty of it. Like in order to do the boot logo, one of the
things that you needed to do was you needed to put the path for the boot logo into the Windows
registry file, which is all of the sort of kernel level configuration files for Windows.
But this is sort of where we get into the problems that I was having. Now there's a big difference
between modularity and integration. This is something that's very sort of key to this whole
reason why I hate Windows. Modularity is where you have a lot of different pieces that are all
independent and can feed into one another. That's modularity. That is the Unix philosophy as it
were. That's sort of the stuff that I like. Integration is where you have things to which
interdepend on one another. And you end up in this tree of dependencies where
it's only as strong as the weakest link. Like with a modular system, if one of the links breaks,
you can replace it with an equivalent link and be fine because the rest of it works.
In an integrated system, if one of the links breaks, you have to throw out the entire system
because all of the rest of the system depends on everything else being what it expects it to be.
Windows is a highly integrated system in that all of the pieces are very closely woven together.
And a lot of that has to do with the way that the int kernel is designed. A lot of that has to do
with the way that sort of the DOS structure works. It's one of the reasons why I'm not really
thrilled about KDE as a desktop environment as well is because it also has that kind of integration
where I mean, the GNOME does the same thing. So I generally use XFCE or Flexbox, or Tiling Window Manager,
like DWM or something like that because I genuinely get very annoyed at integration or at least
nervous about integration because when things start interdepending on one another,
things start getting a little bit messy. I know that a lot of that, that interdependence is important
for programming because you don't want to have to rewrite the code all the time. You don't want
to have the statically linked files which are gigantic and stuff like that. But a happy medium
is sort of what I'm trying to strike. And as far as windows is concerned, it does not exist.
So that was sort of the first thing that I noticed was that because of the highly integrated
nature of windows, whenever the boot logo script or the startup sound script that I had,
whenever those would fail, which they would do fairly often because all of these are sort of
freeware apps that have to reverse engineer the way that the windows boot sequence works and it's
not really, it's not really a foolproof plan because a windows update could just totally ruin
how it works because it's closed source and they don't know how it works. They're just kind of
guessing and at this and checking their work, reverse engineering it. But when that would happen,
sometimes it would crash my computer because it couldn't find the boot image and it didn't know how
to proceed with the boot sequence after that point. I would into a boot loop, after we booted
safe mode, all of that kind of stuff. After change the windows registry in order to be
pointing back to the default boot image, all of that kind of nonsense and then yeah.
So that was sort of the first inkling of like maybe this operating system isn't as good as you
wanted to be. But I had no idea about other operating systems at all. I honestly don't even think
I'd heard of Mac at this point. At all, I only knew that there were windows computers. So we've
put the operating system out. I knew about DOS. I knew about computers without operating systems,
but I didn't know about other operating systems really. And I wasn't really into, I mean, I guess
I'll get into that because the next stage of this whole debacle was I wanted to learn how to
program because I wanted to be able to tell my computer what to do.
And I feel like that's sort of the main thing that you need to be able to have a computer do is
just like what you tell it. You want to be able to put input into the computer and get output out
of the computer. And I could have done that like batch scripting is kind of that.
If it not really, I wanted to compile things. I wanted to do programming. And on windows,
it is a pain to get working like visual basic exists. And I know that there's some way there's
some kind of C compiler that you can get. But all these were talking about having to cost money.
And because I already knew about assembly, I knew that it was just like essentially a text file.
I mean, I mean, it kind of is it's just a text file of some description. I mean, even a
machine code file or binary executable, it's just at the end of the day, it's just ones and zeros.
It can be represented with text. So there was no way that it was, I could cost money. It's all
just information, right? I mean, I wasn't really into free software or anything at this point.
I would just was the programming languages. I could not comprehend why I would have to pay
for a compiler that just didn't compute for me at all because the languages are it's just
text. It's like saying that you would have to pay the academy for all says, for example,
to learn French. That was kind of what it would feel like to me. And it just did not make any
sense. At this time, out by the way, I wasn't even into free software. I wasn't even into
the concept of open source. I was a staunch hobsy. So I thought that like human nature was evil and
that humans required authoritarian government in order to keep them from murdering each other.
That sort of hobsy and idea. So I was very status and very not free in open source anything
really at this time. Or at least I thought I was. I was only like what nine or something
less than nine at the time because nine is sort of when I got into Linux. I must have been like eight
or seven. But I found this project called SIGWIN online. And SIGWIN was sort of what let me
find a compiler that worked on Windows. I mean, I tried to install interpreted languages like
Python and Ruby. But those were really weird and very complicated to get set up because on Ruby,
I don't need you to install the MSI, the Microsoft installation thing. And you had to go through
the wizard to install the program like you do on Windows. But then in addition to that, you had to
edit some registry files to point to basically to what you would do to edit your path in Linux.
But it's very much more complicated process on Windows to do something like that. So that it
knows that the program actually exists. And then you can start programming in Ruby. And it was just
was a weird system. I mean, this was I'm pretty sure it's gotten a lot better since then
as far as the I mean, I know it has because you have the Windows subsystem for Linux, which
why would you use anything else? But anyway, the SIGWIN project let you have a now it's not Linux
on Windows and makes that very clear. Although that's I'll get into that in a second. But what it does
is it allows you to utilize the DLL shared libraries and the Windows environment in order to
create sort of a Unix sub environment like you have a Unix sub shell within your Windows
shells. It's basically the Windows subsystem for Linux except not really because you on the
Windows subsystem for Linux you have an actual Linux kernel and you're sure of booting it into a
what is essentially I understand that it is not actually but it is essentially a container
that you are running inside of Windows. Or a SIGWIN isn't even any of that. It's running on Windows.
It's a Windows application and you're using Windows libraries to do Windows things just in a Unix
way. And this was I was able to get GCSE. This was how I was able to get started learning
about C and C++ and all of this. But it was a very weird experience because you can't
have this window into another world but you didn't get to actually like live in it.
And it was one of those things where I had all this customization and configurability and
compile ability within this SIGWIN environment. But I couldn't get my boot logo to
be what I wanted it to be without crashing my computer. And that seemed very weird to me and I
didn't like it very much. And that was sort of because on SIGWIN it makes such a big deal about it
not being Linux. That kind of made me think okay well what is this Linux thing? And that's sort of
what got me down the road into learning about what Linux was and sort of wanting to actually get
into Linux. And that's what I'm going to talk about next times. This is going to be around when
I was about nine years old and the first Linux distribution that I ever used because I'd heard
around at the time on the I was not on IRC yet but I think I was on AOL Instant Messenger and a
couple of other places trying to find out like some webmaster forms, those types of things,
trying to find out information about programming. And a lot of people were well not actually a lot
of people, not in the forms I was at. No one was really super suggesting Linux but when I was
looking up stuff about Linux on Linux based forms and all that kind of stuff. People were talking
about how Ubuntu was sort of the beginner friendly one but that at the time which is around 2005,
2006 it was getting loaded was a big thing that people were talking about and they was being
overly complicated and not ideal for new users and that then there was this new project that
people were talking about called Linux Mint that was coming out and that's going to be sort of
the thing to introduce to new users. And I decided in my infinite wisdom to install it
the very first day that I could find an actual release ISO like beta, beta software type stuff.
I didn't know what any of that meant. I just knew that the instruction said
burn it on to a CD, put the CD into your computer, hold down the get into the BIOS, change the
boot or order. I knew I'd do all of that stuff just because I looked around in the BIOS before this
and I understood what the BIOS was because the base again put output system. It was something that my
daddy got over when we were talking about when we were talking about assembly because it's the
thing that happens before your operating system happens and all that kind of stuff. So all that
was pretty easy for me to do and then I would be able to boot into Linux Mint and run the installer
and et cetera. So because it was based on Ubuntu I didn't install everything and I didn't
really see anything wrong with it at the time but I'm getting away. It's funny when I was
talking about Windows I couldn't wait to stop but now that I'm talking about Linux I just want
to keep going but I don't want to make this go into the next episode so I'm going to cut it off
here. Next time I'm going to be talking more about Linux Mint and sort of my experience with using
beta, beta operating system and all of the fun that comes with hardware compatibility and all of that.
But I'll talk to you next time.
You've been listening to Heka Public Radio at HekaPublicRadio.org. We are a community podcast
network that releases shows every weekday Monday through Friday. Today's show, like all our shows,
was contributed by an HBR listener like yourself. If you ever thought of recording a podcast
then click on our contributing to find out how easy it really is. Heka Public Radio was found
by the digital dog pound and the infonomican computer club and is part of the binary revolution
at binrev.com. If you have comments on today's show, please email the host directly, leave a comment
on the website or record a follow-up episode yourself. Unless otherwise stated, today's show is
released on the Creative Commons Attribution ShareLive 3.0 license.
