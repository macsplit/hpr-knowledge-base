Episode: 2634
Title: HPR2634: Git tag and metadata
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr2634/hpr2634.mp3
Transcribed: 2025-10-19 06:50:51

---

This is HBR episode 2634 entitled Good Tag and Metamator and is part of the series Introduction
to Good.
It is hosted by Klaatu and is about 19 minutes long and carrying a clean flag.
The summary is an Intro to Good Tags and how to new Metamator about your good repository.
This episode of HBR is brought to you by archive.org.
Arch-Universal Access to All Knowledge by heading over to archive.org forward-slash-donate.
Everyone, thanks for listening to Hacker Public Radio.
This is Klaatu and in this episode I'm going to continue with my get discussion or series
and talk about get tagging.
Now I don't know if it's just because I wasn't using all of the features yet or whether
this is actually true but my impression historically of get tagging is that it didn't
really become fully into its own space until sites like Getorious and GetLab and GetHub
and so on started using get tags to denote official releases.
So get tag, today I think I feel like a very popular and almost the default purpose
for this command, for the sub-command tag is as a release mechanism.
So when your software has reached a certain point in its development and you want to put
a stamp on it and say okay this is an official release, you get tag it and when you sync
it back up to your code hosting site of choice, interprets any tag that you have applied
to your get repository as hey this is an official release, let's put it off in some special
place so people can find it.
So if you want an example of this you could go to for instance getlab.freedesktop.org slash
not klaatu slash trashy, that's getlab.freedesktop.org slash not klaatu slash trashy and in the middle
of the page there you'll see some hyper links to what we call them on the internet and
among those is well there's files, commits, branch, tags, read me in license.
So if you click on the tags you see a new page called tags and it shows well in its own
words tags give the ability to mark specific points in history as being important and the
effect in the user interface of getlab and other hosting sites is that they are that
they offer an archive of a download containing all the code at that time in that moment in
that commit.
So if you for instance want to know that you are going to download and install the 2.3
version of trashy then you would go to the website here and you would go to the tags page
and you'd find the 2.3 tag here at the top and then you would click on the download link
and it gives you an option to download the source or the zip tar dot gz tar dot bz2 or
just a tar file and and you'll be sure that you are downloading trashy as of commit c13acda7
and that's that's what a tag is.
Now that's the as I say that's kind of what tagging has functionally become but traditionally
or at least to my memory traditionally in git tagging was just really an arbitrary way
to bookmark a certain commit.
So you might remember in a previous episode when I was talking about get head and I I
mentioned that the get head is just a designator for some location within your git repository.
It wasn't anything special other than just being a reference point of saying here's
the a place in my git history and we're going to call it head and you can move the head
around you can you have head and you can move the or as I said in the episode you can move
the the get repository underneath sort of the lens that is your that is the head.
So with a get tag you're just putting I guess you could say a sticky note at some point.
So for lack of multiple heads you have tags you're just marking something as significant.
It doesn't necessarily mean that it is a release but that is as I say what what I think
what it's kind of become to represent but technically speaking it is purely a mechanism
to mark a point in your in your get repository.
So we can try this in our demo get repository.
So I'm going to do a CD into a HPR git which is my example repository or my example folder
full of different repositories and I'm going to go into Alice's repository I'll do a
git status and it looks like I'm on branch experiment nothing to commit working on a clean
tree so I'm going to probably switch back to master so I'm going to do a git branch
or rather get check out master so now I've switched to branch master and get status
everything's clean so this is a great place to start I guess so we'll do a git log
dash dash one line and I get an abbreviated sense of of what my history has been.
So right now my git head is nine four C five seven one five now I can tag this that
point in history which is of course it's my head so that's where where I am right
now and I can tag that by by issuing the command git tag and I can tag it anything like
I say it seems like traditionally right now a lot of people are just using this as straight
up releases so I could do one point or rather zero point one and now if I do a if I issue
the command just git tag without any arguments it lists the existing tags and the the current
tag is zero point one so if I do a git log dash dash one line again then I see that my
head is nine four C five seven one five which is what it was before but then in the description
of what head is it says head master comma tag zero point one so it's been it's been given
a tag it has been given some metadata that this is a thing that has been tagged now once
again that doesn't actually mean anything to anybody it's just it's it's metadata without
really anything with it's not suggesting anything necessarily it is purely it is just something
that exists now I could for instance do a git checkout of a previous commit so here's
the the one before that was b seven f a eight eight b so I'll get checkout fast and it says
okay head is now at b seven f a eight eight b and I could do a git tag let's do zero dot zero
five and get log dash dash one line and now I have as the head b seven f a eight eight b head
I'm not on a branch because I've checked out something in history so it's just head comma tag
zero point zero five so now I'm going to check out the actual master branch again I'm just
to check out get checkout master so we should be back at that the old the old place and I'll do a
git log dash dash one line and sure enough I've got that the top of my stack I've got nine four c
fifty seven fifteen which of course is that old master head so head master tag zero point one okay
that's good next one down is b seven five eight eight b oh look at that it says tag zero point
zero five so nothing special about b seven f but I've tagged it as zero point zero five retroactively
even and then I've got my head master which I've tagged at zero point as zero point one and tags
don't have to be numbers like I say it's it's a convention I think at this point that tags are
numbers but you could also just do a git tag draft we're draft and then I'll do a git log dash
dash one line and we see now that head master tag draft tag zero point one there you go so if you
if you have keywords that you for some reason want to integrate into your git tagging you can do
that they don't have to be numbers now they do have to be they cannot have several they don't
they can't have spaces in them so we could do a you know a git tag rough underscore draft
and then that's a valid tag but if I do a git tag quote rough space draft close quote then it
tells me that's not a valid name that's fine but there's a little bit of a little bit of a
freedom there you can you can do whatever you want whatever convention you need so you can
delete tags by git tag dash d for delete and then whatever tag you want to delete so I'm going to
get rid of rough underscore draft it tells me that the tag has been deleted again if I do a
git log dash dash one line I see that you know the head is still there 9 4 c 57 15 the commit
hasn't been hasn't been changed the commit itself is is fine but now it says head master tag zero
point one so it's removed of the tag rough underscore draft and I could do that with anything I
could do git delete or get tag delete zero dot one or zero dot zero five whatever now interestingly
these tags have not been have not been pushed to to get repository so I mean if I do a git commit
playing around with tags and then I could do a git push origin head it pushes whatever it needs to
push to my fake repository do git log everything's the same but if I went over to my fake repository
which I think is called fake remote yep it is and then do a git status I can't because it's a
yep it's not a forgot that's a bear repository so I could do a cd and a bob and I could do git pull
git log dash dash one line I see no well actually I'm on the wrong branch get check out master
now if I'll do a git log dash dash one line I see no tags here is was what I'm what I'm getting
I see all the new commits that I've made since the previous episode but I don't see any any tags
so how do I get those tags well we'll get out of here we'll go back over to Alice
and we'll do a git push dash dash tags origin head and it very very verbosely
or very explicitly tells you what's happening so it says total zero delta zero reuse zero delta zero
okay so nothing no commit data has been pushed because I'm all up to date but then it says two
slash home slash class two slash hpr git slash fake remote new tags 0.05 to 0.05 new tags 0.1 to 0.1 so
I've pushed now my tags in along with anything else that would need to be pushed or just the tags
by themselves now I'll cd back over into bobs bobs repository here and I'll do a git
a git pull again and again kind of verbosely it confirms yeah there are new tags here so it
actually spits out some some feedback for you and then I'll just just to confirm or just to see
them I'll do a git log dash dash one line and now I've got nine four c five seven 15 head master
tag zero point one and b seven f as the second commit with a tag zero point zero five so those were
the commits were there but the tags weren't now the tags are so the tags are a little bit separate
from the rest of your data which I guess is a good reason to call it metadata it's it's something
that you have to deal with separately and that's important to remember because if you don't explicitly
get pushed dash dash tags then the tags aren't aren't pushed they're not they don't leave your
computer they're just reference points for you until you send those up to the server now I've
worked in a couple of different places one place we never use tags outside of our local machines
the other place you know so we never did a git push dash dot tags another place I've worked
in it can it depended on development group to development group but but there were a couple of
groups that used tags to to earmark both peoples sort of private branches or not private branches but
they're their work in progress type branches they would they would they would write in a tag what
that branch was meant for and then it was also used for releases for the official releases
whatever you use them for you may eventually need to sort of introspect on your git repository
and and see what tags have been applied or we're just kind of look at at the history of your
repository and there are a couple of different mechanisms for that which I'm kind of lumping in
because it's we're dealing with metadata in this episode I guess so since there are tags and you
know that they they kind of exist in a sense separately from the the normal data of your git
repository couple of different ways to look at more information about a repository so one is git
rev list and that's git and then space rev as in revision dash list rev list now if you if you
just type that in it just kind of spits out a bunch of different options for you to be confused by
and I mean it's it's probably worth talking about each option but I'm not going to
so the the way that I use it is frequently is git rev dash list and then space dash dash branches
and then dash dash tags and then dash dash pretty so that's branches tags pretty and pipe that
to less maybe and you see the what what looks an awful lot like a git log the like the verbose
git log not the git log dash dash one line but the full on git log and that's pretty much what
you're looking at it's a list of revisions and it shows you the commit hashes shows you the author
of the commits the date that they were made and whatever commit message was made with with that commit
and it shows you all of them for the history of your of your of your project so the reason I'm
showing you that is because now you kind of have an idea of of the kind of information that you can
get programmatically from git so for instance if I do git rev list dash dash tags dash dash max dash
count equals one then I can get the the most recent hash in in in all branches the most recent one
I can I can pull that out from from from from git so if I have that value 9 4c 57 15 and then a
bunch more numbers then I can also do what's called a git describe and git describe then looks at
all of the data around a specific a specific commit so I'm just going to paste that in so now I'm
doing a git describe dash dash tags and then the output of the previous command the rev list which
is 94 c 57 15 of course and I'll hit return and then I get a 0.1 so it is just described that
commit by tag for me and of course if I did the the previous commit the commit the penultimate commit
which I know was b 7 f a 8 8 b I do a git describe dash dash tags for that hash I get 0.05 so you're
getting you're you're looking at a specific hash commit and getting pulling out information about
that commit with with commands with with sub commands which is important for when you're trying
to script stuff such as maybe automated releases or or nightly builds and you want to you know you
want to tag them with the the date that they were built on or something like that this is one way
that you can do that you can write into a shell script to get the most recent commit hash and then
to describe that hash in tags and to use that tag in you know in in your release or in your
release notes or or whatever so it's it's it's handy to know that you can look at this information
with with commands with git commands because that way you can use them when you're scripting or whatever
now there are obviously other ways you could do it I mean you could just do a git log dash dash
one line and then you could determine okay well I see that the hashes are all field one so I could
pipe that through awk and I could just tell awk to print field one and then I would have
dollars on one and then I would have just the hashes and of course obviously I would I guess
maybe pipe that through a head dash in one and then I definitely have the most you know the top
most hash so I mean you can do it in different ways and it's not necessarily it's not necessary
to learn every single switch of git in order to get the information that you need but it is useful
to know about them and certainly get described can be help can be useful in cases where you need to
to look at metadata about a hash so there you go that is git tagging and introspecting your git
repository hopefully it was somewhat enlightening and useful so git tags use them use them wisely use
them well metadata sometimes is a good thing thanks for listening I'll talk to you next time
you've been listening to hecopublic radio at hecopublicradio.org we are a community podcast network
that releases shows every weekday Monday through Friday today's show like all our shows was
contributed by an hbr listener like yourself if you ever thought of recording a podcast then click
on our contributing to find out how easy it really is hecopublic radio was founded by the digital
dog pound and the infonomicum computer club and it's part of the binary revolution at binrev.com
if you have comments on today's show please email the host directly leave a comment on the website
or record a follow-up episode yourself unless otherwise status today's show is released on
creative comments, attribution, share a light, 3.0 lives in
