Episode: 2198
Title: HPR2198: How awesome is Guix and why will it take over the world
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr2198/hpr2198.mp3
Transcribed: 2025-10-18 15:40:40

---

This episode of HBR is brought to you by Ananasthost.com.
At 15% discount on all shared hosting with the offer code HBR15, that's HBR15.
Better web hosting that's honest and fair at Ananasthost.com.
Hi, I'm Klake and I'm here with Chris Weber to talk a bit about Geeks.
Oh yeah, hello, hi, so good to finally set this up and actually do this call thing.
Yeah, we've been kind of talking about doing it more or less on and off for a bit and yeah,
yeah, I was checking actually I did a recording myself first talking about Geeks from a slightly
different perspective and I was thinking should I release that or should I just go with this one
completely and then today I recorded it three months ago and then I listened to it now to see
maybe I should mix it together because it was cut up in pieces I was doing it while
while walking to office and I listened to it now and it was real rambly so I've never
got to publish that so that's that's sort of why I wanted to to bring you and because you've
been actually speaking on this and so I figured you got this sort of sorted out how to present things.
Oh, I hope so, who knows, you know, so let's start with a sort of overall perspective for those
who don't know anything what what Geeks is. I wonder what is this thing. I wonder if I should have
been smart and pulled up my notes from the talk I gave before. I'm going to I'm going to do that
in the background while I bring the while I talk about that. Yeah, so Geeks, it's how we roll.
Yeah, that's right. I know also my typing is super loud on this computer so I've got one of
those kinesis things that are for people with RSI so Geeks but to get to the topic we actually
are supposed to talk about Geeks is a functional package management system and there's also Geeks SD
which is a Geeks system distribution which is a full distribution using that. Geeks is pretty
interesting. It's spelled GUIX which makes most people including me initially think that they
they should pronounce it GUIX but it's French or the main author's French so hence the name Geeks
and we so yeah, it's a new project. I've been contributing to it a bit. I've also been just
really excited about it. It has some really interesting properties in that because it's functional
package managing you can kind of do cool things like time travel back and forth kind of like
kind of like a Git repository where you can kind of roll back if something goes bad and etc.
And there's a lot of interesting features to it like that that I guess we should actually go into
but that's yeah, there's a couple of things you already brought up here so let's unpack that
a little bit. Yeah, so first there's Geeks and there's Geeks SD. So when I first came into contact
with it, I just knew about Geeks which which you can see it as an additional or supplemental
package manager to your existing Linux distribution. And I guess once you have all the packages
from Glib C all the way up to X then making it a distribution is just a matter of setting up
the startup and getting everything going and having some sort of innate and I guess that's what Geeks
SD is basically. Yeah, sort of. I think there's actually some interesting layers. I think you're
right that you know that the really hard work at Geeks is primarily in the package manager
but there are some interesting things that you know using those same layers as the package manager
that makes a distribution side of things really interesting. I mean, so I guess we should go
to those in detail. Would you refer I ramble into why I think I'm not sure which side of this
tree I should ramble down yet. What's yeah, I think I think we can go into maybe a bit superficially
what is functional package managing and why is that good and then we can go back to how
how that ties in with the the whole distribution thing. Right. Yeah, I think it's interesting,
you know, describing it as functional package managing. Package management, I think doesn't really
give people a good idea of why it's interesting from the beginning. I mean, probably when I heard
functional package management, I imagined a bunch of Haskell people, you know, running around
is shouting monads over and over again. Yeah, I didn't know why that would be interesting to me.
My first reaction when I heard of Geeks was I was like, oh man, like the world does not need another
free software packaging system, but it turns out that phrase free software package manager actually
means something really interesting, but I think we in order to really understand it, you need kind
of a very brief description of what functional programming means in order to kind of unpack that idea.
Oh yeah, that's true. Maybe we should start from there. We don't know really. Right.
Not maybe not everyone knows what that means. Well, I mean, you know, I've been a free software
advocate for a long time and I really didn't know what functional programming really meant
for a long time. I mean, I was a Python web developer and I was like, you know, I've got functions
here. Things seem to be functioning. It seems like, you know, what and you know, what's this having to
do with function? Yeah, what's the opposite of functional? Yeah, right. Yeah, exactly.
Well, it turns out in functional, I mean, functional programmers might say that imperative
programming is dysfunctional, but there is there is that kind of reputation of functional programmers
kind of ways, waking their fingers at everyone, but I mean, that partly does come from
there's some really interesting properties you get when you go into a purely functional system.
So to define what purely functional really means is it means that when you give a procedure,
you know, people are used to the idea of having, you know, a function or a procedure where you have
input and then it has output, right? You know, you pass in some arguments and you get something
return back. Well, in the pure functional system, you have a guarantee that you will,
if you pass in the same input, you will always get the same output back.
And that also in order to be able to get that guarantee and really tied in with that is the idea
that there are no side effects and side effects are things like, like, you know, in the middle of
things, kind of reading and writing from some input output source or, you know, or all,
or, you know, maybe write a displaying beeping from the screen, you know, like, you're,
you basically can't do any of those things. You also can't change variables that anything else
in the program might use. So you can't have global variables that you quote unquote, you take,
you know, so if you have a list and you find out that something, somebody passes in some sort of
list to you and you're like, oh, well, they're going to use that list later. It would be really
helpful if I just, you know, tacked on an object for them. Well, that person might not be expecting
that and suddenly they have a, or maybe you didn't even think about it, you just popped off
something off the end of the list because you needed that object. Well, you basically change
the list to which someone else had a reference. Right. So that person had a reference and then
they might be very surprised to find out that that list doesn't suddenly has something, you know,
gone from it. So a purely functional system won't do these surprising mutations and it won't
have side effects. I mean, when I hear mutations and side effects in functional programming,
I imagine, you know, some sort of person like, you know, some, some person in an office and they're
they like take some sort of bottle of pills and they start mutating dramatically. This is the
comic version of things that I imagine I had. And then some person with, you know, like functional,
some functional programmer comes into the office and they put on some, they go, you know,
looks like he should have checked, he should have read the bottle for its side effects and then he
puts on his sunglasses and there's a couple of llamas on there. And, you know, I guess again,
if you if you go to these, imagine the arrogant functional programmers wagging their fingers and
everyone and calling procedural programming dysfunctional, I guess they would also
think something like that. Yeah, yeah. But the evil mutations with these evil side effects.
But it turns out that in, and I really hated functional programming for a long time until I
discovered that I loved it. But because it's so annoying, you know, kind of curing that,
that type of like finger waving and stuff like that. But it turns out, it really is true
that there are a lot of bugs and programs that are solved by not having those surprised mutations
and being able to kind of guarantee that property that you can guarantee that you will get the same
result based off of those inputs and that you also won't mess with anything outside of that
system. That's really great. Of course, it turns out most of the things that actually matter
on a system require side effects in some sort of really useful way. Like in the thing that people
really care about on their system is not just the programs that they have installed, but all the
data that they built up with those programs and stuff. And you're eventually going to have to
have side effects where you pull things in and out of a database or off your hard drive or something
like that. One of the great, I, yeah, when we talk about, when we talk about states, or we talk
about side effects, it's really about changing states. Right. And in the end, what a program does
is it changes state and it interacts with the user, which is sort of changing the state of the
world. So in the end, in practice, you're going to have side effects and then the the difference is
how you sort of formulate that within the programming. Right. So the paradox is that side effects are
the things that ruin the functional programming world. And they're also the things that actually
really matter. And like so that's a big paradox for functional programmers. Now kind of the way
that we kind of get around it is that you kind of make, you kind of, you have your beautiful
functional programming world and you kind of isolate and quarantine the input and output areas.
And you kind of prop up this beautiful system in the middle where you pass in input on one side
as like as if they're the arguments, the function and you pass out the output on the other side.
And then you've got this small like this scaffolding on either end of things that's holding up
your beautiful city. But you've you've pushed that, you know, mutation stuff out to the side.
So that I mean, that's one way to be able to look at how you can actually do functional programming
given the fact that side effects are actually necessary. Did you do any programming in in
Haskell with Mohamed? No, I've actually never really done Mohamed's at Haskell that much. I
I've done a little bit of Haskell as in terms of going through some tutorials and stuff. But it was
really getting into scheme, the programming language that got me really interested in functional
programming and partly being involved in the guy in the guyle community and the geeks community.
And you know, starting to kind of go down the rabbit hole of reading the little schema and you
know, structure and interpretation of computer programs it. But it's also like watching, I watch
the video of Bittomsen, one of my favorite guyle hackers has a functional reactive programming
based game engine thing. That's that's David's unit on the social networks unit. And he has this
this video that he put up of, you know, like his game engine slide, which was called Gile 2D
the first time I saw it. And he was, you know, programming the system and he was able to live,
change things in the system. And I just watched it like he was able to change the game as it was
running. And like different parts of the system kind of all flowed out of this graph. And when I
watched that video, I was like holy crap. There was a whole side of programming I don't understand
that I need to understand it. And you know, getting involved in geeks and getting, you know,
frustrated and angry that I didn't understand what this functional programming thing was,
kind of forced myself down that whole of kind of, you know, picking it apart. So we kind of
talked about what functional programming is, but we didn't really dive into what it gives you,
right? Like we said, we said, you know, you know, you can, you have the guarantee that the same inputs
will always give you the same outputs. And that's one of the cool things that that slide
game engine that I was watching, one of the things that there's another very similar game engine
called Elm that's able to do something really cool, also functional reactive programming. It's
more than just a game engine, but Elm has a time traveling debugger where you can move, you can
kind of scrub backwards and forwards across the program's time. And that's because, you know,
you're actually folding over the inputs in time. And if you're able to always reproduce the same
inputs that are coming in each other, the program that you can always reproduce the same outputs,
which means you can just replay that system from front to back just by replaying the inputs
and what the previous state was that were built out of that inputs, which,
Yeah, we haven't even, we haven't actually said that, but that's the functional and functional
programming. You look at it as a mathematical equation, where you have the value x that
becomes some value f of x. Exactly. And so even though in Python land, we call the things that
we're writing with depth functions, you know, a functional programmer will say, well, that's
technically a procedure. You might write a function with it, but it's by default the procedure
because you might do side effects and other things like that, whereas like a real mathematical
function is, uh, won't have any of those things. It's a much more restricted subset of procedures.
Okay. Uh, yeah. So, uh, so that's functional programming. Yeah. So that's functional programming.
So what can we do once we end up having that? Well, I meant to the time travel type thing.
You could also say, you know, like, um, you could also have like a guarantee of kind of atomic.
So, so one thing that's kind of familiar to people is Git, right? Like, you have this atomic thing
where, you know, you can commit and you can roll forward back into some time and, you know,
you've got your kind of the local state of the things you're working on, but once that's done,
you can keep going back to a previous state and it's, it's not going to break things.
And that, uh, and also when you end up changing things, there's a guarantee that either things
succeed or they fail. Uh, and there is that promise in geeks where, you know, so you've probably
been in Debian or something like that where, you know, you've got, um, you've, you've been doing an
upgrade in Debian or Fedor or something and suddenly the power goes out and you boot your system
back up again. And there's no, there's no way to kind of restore things, uh, because like,
it's mid upgrade and like fixing it is a big hand in the butt. It doesn't even have to be the
powers. It can be as simple as, oh, yeah, I forgot this thing and then you do control C and you,
and you stop the process and that could also end you up in a, in a state between things where
nothing works. Right. So, I mean, this is jumping ahead a bit. Um, but you can imagine one type of
feature is if you have a new output that you're building is entirely built based off of these inputs,
well, you don't actually need to switch everything over until you've built up that new output.
And then you can just switch it over all at once. Like, so geeks uses a bunch of sim links and
we'll get into that, I guess, but you just switch out which sim link is pointing to your current state
of the system, um, which means that like you can build up the whole thing and you don't switch
everything over until it's ready, which means that you'll never end up with that mid upgrade
breaking thing. And I, I did check the, the command that they use to switch things over is a
atomic, uh, it's an atomic operation from the kernel level. So you won't end up with a broken
thing even on that switching the sim link level, which is pretty cool. Yeah, I guess they, they create
a sim link and then they move it to the position where it should be. Yeah, yeah. So you basically
replace the sim link, um, so, so I guess, um, so, so this actually, I think we're starting to get
to the point where we can kind of move into some of the other ideas of geeks. We've got an idea of
what functional packaging is and we've given a hint about the sim link thing and that there's a
sim, okay, and we, one thing we didn't look at yet is how, what does functional mean in the context
of creating packages? You mentioned the atomic thing of applying, uh, the changes
all at once when you upgrade packages. Um, yeah, yeah. So let's, let's talk about that. So, um,
what in, in a normal, like, you know, the kind of imperative distribution, like Debian or Fedor
or something, you know, you've got, um, so say you're, uh, uh, you're replacing, um, maybe I'm
releasing my systems Python 2.4 and I'm moving to Python 2.5 or something like that, or maybe even
2.4.1 and I'm moving to Python 2.4 or two, right? So then kind of the traditional model of things
you'd actually, uh, you know, add and then remove or maybe the reverse of, like, the files and
basically just kind of write over everything that's currently there. Um, uh, in the functional
packaging version and, you know, the, you also might be, if I replace Python in Media Goblin,
depends on Python, well, that previous version of, uh, Media Goblin, uh, will, will, will,
you'll just have left it in place and it's now just pointing, uh, it's, it's now just using the
previous Python. Uh, but so one crazy thing about using geeks and nicks, we didn't even mention nicks,
you know, yeah, yeah. It's on my list. Okay, we'll get to that later. Yeah. Yeah. So, so one of the
crazy things that, like, was kind of mind-blowing for me when I initially saw it is that, um, Geeks
is entirely based off of each new package that you built this entirely based, based off of its
previous packages. So you started to mention this with, like, Jeal and Z. Um, so say I'm building up,
um, you know, we've got something, uh, give me a package that, that's a good example. I can't
think of a good one. I did say Media Goblin, but I want to think it's something that's not promoting
my own stuff. Bash, right? Okay, so Bash. Um, so there are, Bash both depends on a lot of things and a
lot of things depend on Bash, right? Um, and, uh, um, Bash depends on a lot of things and a lot of
things depend on Bash. So when you have g-lib-c changes, right? Um, Bash needs g-lib-c and it also
needs a number of other things in order to be built. Well, anytime you change g-lib-c, uh, you will
actually a new version of Bash will be built. Uh, and that's because each package and geeks
entirely depends on all of its previous changes. And so if you change one package, it will build
a new package based off of that. And instead of having Bash just 2.4 or whatever, I have no idea
what Bash numbers are on right now, but, you know, it'll actually be, yeah, I, I, it was 2.03 for
several years, and then I'll just, then it's just going. Wow, I wasn't too far off then, I guess,
maybe. Um, I guess it's on 4 or 5, certainly. Oh, okay. Yeah, I guess it, it's not at the Firefox
land, but, you know, uh, no, not yet. So, um, the, so when you, when you end up having some sort of
previous dependency, uh, all the, dependencies above it get rebuilt, which sounds like a big pain in
the butt, but it turns out it's really useful because that's how you get that guarantee that you
can roll forwards and backwards in time. And so you look, yeah, right. Someone might interject here
and say, but well, that's not how it works in Debian because you have forward compatibility, right?
So I up, up, I upgrade Glib C. And, and of course, the new version is compatible. So why should I
also, uh, recompile bash? But as you're saying, that's because in the functional view of all these
things, bash is a product of the inputs, and you just changed one of the inputs. So then necessarily
the output must be different. So you need to compile that again. So if you look in your geek's, uh,
store directory, it's like in slash, canoe, stuk slash store, you'll see, you know, like you see the,
the package names of what you expect, like bash, dash, whatever. In fact, I'm going to look right
now, might as well, uh, going to store bash, uh, oh, it's going to store. Oh, it's, it's the hash
and then bash. That's why it was confused. Yeah. So I've got slash canoe slash store slash GVWF
71 blah blah blah blah blah, dash bash. And you'll notice that there's a hash prior to bash,
which sounds like, you know, like, oh, what is that hash doing there, right? Like, well, you know,
so the version of bash that I have, it's not just bash, it's bash that's, um, built, uh, oh,
I missed another start, right? Yeah. So there's some, so there, but you know, regardless, it'll be,
you have a hash before the name of the package. Uh, I actually have two bash dash 4.3,
0.39 on my machine. One of them is three one blah blah blah one of them three nine blah blah blah.
And that's because at some point, and I haven't garbage collected my canoe store in a while, um,
yes, functional package managing means that you bring garbage collection to your packaging
which is kind of curious, but, um, the, uh, but because at some point, some dependency beneath bash
ended up changing, uh, it ended up giving me a new version of bash, uh, which, which, uh, so at some
point, um, that that might make you wonder, oh, well, that that could be really annoying having
all of those things, but it turns out somebody else is building some of those packages for you,
probably there is a system that can build things, uh, that's off in the distance. We won't worry
about it too much at the moment, though I, you should remind me to mention the, the funding
campaign that they're bringing up related to that later. Right. I want to bring that. Okay. Yeah. Yeah.
We'll talk about that later, but, but somebody will probably have built it for you. So your,
your computer is probably not doing the hard work, though it could, uh, is just pulling down the
new bash when it becomes available, built on the new g lib c or whatever. But the good news is,
if a new version of g lib c comes out and it makes bash really screwy, right, um, it will not be
a problem because you can just roll back your whole system to the prior version of g lib c.
Uh, and in fact, if there are multiple versions of g lib c on your system, uh, you can actually run
multiple versions of bash or multiple versions of different programs that require the same library,
but at different versions at the same time. Yeah. And each of those bashies have their own
specific set of exact dependencies. Right. So people in web development, so like, you know,
so one example is also, uh, so now we're getting to the really interesting feature. So, you know,
since the output of a package of entirely both off of its inputs, that also means, and we've got
this slash, can you slash store, we can move into the simlink for us now, right? I think we've covered
I want to do something, uh, something first more a little bit more about background. So I want to know
how you, you talked a little bit about it, you, you came into guile somehow. Uh, was that because
you got interested in scheme and you started reading the sick p book or it's hard for me to exactly
trace what brought me there. I had a number of things that got me into guile and, uh, land basically.
So about a year and a half ago, I was a very different programmer, I guess. I was on a bike ride with
my brother, and I remember saying to him, uh, one of my friends said that, you know, we should teach
programmers that they, you know, all basic, uh, types in a program should be immutable. And I don't
understand that because, you know, mutation is so useful, why would, why would you not want it? And
now here I am in the functional programming land, you know, also waiting my finger at other people,
they're trying to not be too much of a jerk about it. Um, and so like, obviously, something's changed
a lot. And some of the things that changed were, uh, uh, for some of the people who don't know, I
work a lot on, uh, you know, network item stuff, uh, I work on a project named Media Goblin,
which is written in Python. And for almost a decade, I identified as a Python web developer,
like I, I got really far in my career. Um, I mean, I knew some other stuff outside of that,
but I was definitely pretty core Python web developer, uh, as kind of my core. Um, and about a year
ago, I started to hit some real limits. Um, I was getting frustrated with the state of deployment.
And initially I was not interested in geeks. I knew about it. I thought it was kind of cool
conceptually. I thought it was annoying that the GNU project was basically going and starting
a new package manager and distribution. And I was like, wow, why are they doing that? Uh, so did
you find out about it through the dial connection? No, I found, I heard about geeks first. Uh, well,
I knew about dial, but I was also dismissive of that for a long time. Uh, I had been a fan of
Lisp for a long time. Uh, but, in fact, I, I liked Lisp so much and I liked Lisp. I initially got
connected to Lisp because of Emax and extended Emax, but I liked Lisp so much that I participated in
a project called Hi, which is a hilarious project, which allows you to, um, uh, do Lisp style programming
on top of Python. Um, so you were, you were using Hi before you were using, uh, only, well, I was
a contributor to Hi partly because I thought it was interesting. I wasn't really, I, using it
initially for very much though, I did write the tutorial. Um, for a long time, I really wanted,
uh, macros in Python partly because I wanted what later became yield from and then later became,
uh, like async and await in, in Python, uh, before it existed. So I wanted macros. Um,
and, uh, so when I heard about hi, I got really excited. Um, so I had been contributing kind of
this lesser Lisp in a certain way. Um, it's a really interesting project, but then I, getting
frustrated with the state of deployment, uh, and, you know, running a big network freedom project
with Media Goblin, I was like, oh, I really need some better deployability tools. Um, you know,
like, and I tried looking into salt and I tried looking into Ansible and I tried looking into
some sort of way that people could do deployment that, uh, um, where people could kind of share
recipes and then have a web interface where they could kind of select things and, uh, you know,
select what packages they want and it would be able to intelligently build out the dependency
graph of, you know, if I pick a mail transfer agent and I install Media Goblin and Media Goblin needs
a mail transfer agent, but so does WordPress. Um, but Media Goblin and WordPress's configurations
should be able to know about and pull the information from the configuration I already specified
for the mail transfer agent. So that was a problem I was really interested in and I was interested
in building a really simple, the use web interface for this and it turns out there were some,
I just didn't, I couldn't think recursively about, uh, how to build the directed acyclic graph
that's required for dependency tree. So I started realizing the limitations of what I knew
in programming, you know, I just, there were certain problems I just couldn't reason through
anymore. Um, so you were, you were already thinking about these things like how can I define a system
around this application that has dependencies? Yep. So I was already interested in that.
And I had seen, as I had said, you know, Dave Thompson's uh,
sly video and I knew that he was excited about geeks and I'm like, ah, that's kind of interesting,
but I'm going to, and I wrote out a whole specification for what the domain specific language
was going to be for the config file system that I wanted. Uh, and I, I was, oh, you got that,
yeah, I had actually done a lot of research in it. And I had written out this whole domain
specific language, um, plan and I was planning the web interface and everything and I was like,
okay, now I'm going to build this thing on top of high because high is, you know, like it's
Python's familiar and it's comfortable. Yeah. So I started to do that. Um, and then, uh,
so is this linked somewhere? I do have a copy of this somewhere. It was called the optimal. And, uh,
right. I think. Yeah. And there was a high version and then I threw it away and I built a, uh,
a, a, uh, guile version. So initially I tried with the high version and I was like, okay, uh, this
thing I'm going to, uh, um, you know, I'm going to use high because it's familiar and I like Python
and I can kind of have both things, but it's easier. High makes it so that you can build the domain
specific language on top of Python really easily because you have the advantage of all the kind of
the speed things. Uh, okay. So optimal, uh, the, the, the, the domain language for optimal was in,
uh, list. Yeah. It was in high, which is, you know, list on top of Python. It's like a list that,
yeah, that compiles down a Python stabster syntax tree. So I was, so I wrote that out and it turns
out. It was a nightmare to debug because in Python, when things break, all you really have are
line numbers. But if you imagine that you're writing macros, how do you keep track of line
numbers anymore, right? If you're expanding out code, in something breaks, what line are you on?
Well, if you're expanding out code, you don't really know anymore. So you, you, you use the one
piece of debugging information that you really have. I mean, yes, you can use PDB and stuff like,
it's really not possible to tell where you are anymore in the code. And I just got such a headache
trying to write this thing in high that I'm like, okay, you know what? I'm going to try guile.
I installed the guile, you know, info manual and e-max. And I read it occasionally while
working on other things that I'm like, and I, I was already talking to Dave Thompson because I thought
Sly was so cool. And I'm like, okay, you know, I'll try writing optimal in guile. And so I started
writing optimal in guile instead. And, and I got a reasonable amount with it. There's also
a repository of that somewhere. I wouldn't say it's really good code because I was just learning
scheme at that time. And so I was writing, I was writing that. And then people kept saying, oh,
you should look at, you should look at geeks. You should look at geeks. You should look at geeks.
I'm like, yeah, yeah, yeah, you know, that sounds pretty great. I mean, I can't figure out how to
run it. It sounds pretty good. But honestly, I'm pretty invested in Debian and Fedora and stuff.
And your own system? Yeah, my own system. And like, I had built up all these ideas. And you know,
and yeah, that's true. I'd also gotten emotionally invested in my own system. And I'm like, you know,
I think that Debian and Fedora are not going away. So why shouldn't I build something on top of that?
And yeah, maybe, maybe I should learn more about geeks. And then so I'm like, okay, you know what,
I'll take a weekend. I'll install geeks as a local package manager. And I'll install some stuff
with it. And then I did that. And I was like, whoa, wait a minute. This is really cool. You know,
the ability to kind of roll back and forth was pretty cool. And then I packaged something.
I think the first thing I packaged was, at this point, I had started to dive deep down the rabbit
hole of scheme. I had learned, I had read the little schema. And I had a copy of the reason
schema, which is like this crazy logic programming system built on mini-canron, which is a logic
programming system scheme. And I was like, okay, I really want to play with mini-canron. How,
how can I get a hold of this? Well, mini-canron's already been written, but there's not really a good
package manager for Guile. Like people started on it and then kind of didn't really finish it.
So I'm like, well, I might as well package it for geeks because, you know, you know, geeks is
kind of becoming the package manager for Guile. So I do that. And it turned out it was pretty easy
to write a geeks package. So then I started getting involved in geeks. I started to read more
about it. And I really started to get invested in the ideas. And one of the things that I really
came to realize is that it has, and this is showing how deep I've gone into the scheme land.
It's as hard to not use these terms once you start following this enough, but there's these
terms and structure interpretation of computer programs where they describe a means of composition
and a means of abstraction. And what they're really talking about is how you end up combining
things in a program. And kind of the languages that like directly let you express, you know,
combining things in a program. And what became really clear to me is, hey, wait a minute,
I could ill that very thing I was interested in at the beginning, that web interface thing
on top of this. And if something went bad, I could roll back. And that, oh, I could roll back itch.
I couldn't get it out of my mind. And I think that was something that, yeah, the way back thing is
like if you've ever upgraded the system and things go badly, that that's a pretty appealing thing
already. But then I started to realize that it wasn't just the rolling back thing. Very recently
in Geeks, for instance, Ludovic Cortes, the main developer landed a new system configuration system.
And you can, you can describe, you can, you can do that whole thing I was talking about,
where one, yeah, yeah, dependencies between, yeah, dependencies between services, exactly.
And that made me realize I wrote an email to the list. I was like, holy crap, I now realize I can
totally build this web interface type thing on top of here. Because, and I'm talking about this,
and like, you might be wondering, why have I gone down such a deep dive into deployment stuff?
I already have a big project with Media Goblin. Why would I want to go down a deep rabbit hole
of deployment? And, yeah, so now we're sliding into what's the problem with all these programming
language specific packaging systems? Right. So the real problem for me is that I realized that
network freedom is just going to fail in the current state of deployment. There is just,
and this is from a couple of years of kind of being in denial about this. You know, people
would deploy Media Goblin. They would spend a couple years, you know, maybe they would spend a
while maintaining it, and they would be afraid to upgrade. Almost everybody was afraid to upgrade.
And here's the thing, I'm afraid to upgrade. I'm afraid to upgrade my own software that I wrote.
And it's embarrassing, right? I should be embarrassed about that. You know, why should I be afraid to
upgrade? But constantly, like I even had an experience where I had spent the previous day
making sure before a hackathon that everything was right, that all that like people were able to
go through the documentation and everything would work and etc. Then the next day when the hackathon
starts, something changed in the dependency tree and there's a new version of something.
There's a new version and I couldn't figure out what it was and everybody came in excited to
work on Media Goblin. We had a number of people show up and oh, hey, nobody can get the thing running
who is a new user. And that was infuriating, right? You know, like, because and so David Thompson
says this, this kind of, you know, I guess it's another kind of snarky functional programming thing,
but I, but it's so true that he says, you know, you're dependent on the phase of the moon,
imperative packaging systems. And it's, it's so infuriating having to be dependent on that
and having users be afraid to upgrade their system. So the fear of upgrading is one part of it.
And that's assuming that you even get things installed in the first place, right? If people ask me,
so I run my own mail server and people ask me, oh, well, how do you, how do you run your own
mail server? How do you have it set up? I'd like to run my own mail server. I don't want to be in
the hands of Google with Gmail and stuff like that. I want to run my own thing. They're like, how do
you set it up? And I'm like, well, I don't know if you want to know my setup. They're like, no,
no, no, no, no, no, tell me your setup. And I'm like, okay, so I've got, you know, postfix and
doescott set this setup to handle incoming and out, me coming mail and they get passed through
Proc mail, which ends up filtering everything out all to the right places. And then I end up pulling
it over the wire with offline IMAP and processing it locally with with MU. Oh, I forgot that I actually
also am running spam assassin on my server. You definitely want to use spam D not the spam client
so that it doesn't have to keep restarting itself. Oh, right. Also, when you pull it down locally,
you're going to want some sort of nice client. I'm using, you know, EMAX client here. I wish I could
show you my config, but they're, you know, a big, you know, clusterf. And I, oh, oh, yeah, oh,
also you've got to make sure that you set all these settings up right in your DNS and these types of
things. And like, and people are like, oh, that sounds exhausting. Could I just be here to run it for
me? And I'm like, there is no way you can pay me to run your mail. Like,
such a nightmare. So basically your answer is, I know exactly how I set up my mail, but I have no
idea anymore how I set up my mail. Yeah, exactly. I like, I'm afraid to re, you know, I mean,
I do have backups of my system, but how I got to the state that I'm currently at, I don't know.
You know, and if I ended up installing a new copy of things, I mean, sure. So when I start
describing this, people are like, aha, this is where Ansible and Puppet step in, right? They're like,
oh, you should have kept all your files in there in the first place. And that's kind of true,
except that you're still, you still have this problem that like Ansible and Puppet and stuff
like that are still dependent on that phase of the moon problem, right? So you might roll things
out and you're like, oh, well, I've got to switch over to a new server because mine's compromised
or something like that. And then it turns out you do an upgrade and you were running Debian testing
and Debian testing is broken right now. You can't switch over or, you know, your configs don't
work with a new version of a positive that came out because they completely changed things or
whatever it is. Yeah, maybe actually now there's a Debian snapshot package server where you can go in.
I think GRML, do you know GRML? I don't. It's a sort of systems hacker distribution. It's Debian,
but it's configured. It's a live CD and with certain useful tools installed on the CD, you can,
it uses the Debian repos and you can do apt-get and everything. But what they do is they have a
specific snapshot of Debian because Debian has a package server now that you can say, I want to do
apt-get install bash from the package tree as it looked on June 27th. Oh, that's really great.
I had no idea that that's pretty cool. And I just noticed this. I was using GRML a couple of days
ago and I noticed that they were doing that. So they print out or they create an image that is
their DVD. And that one points to a repo that is actually known at the time they produce the DVD.
And if you come a year later and you do install, they've already verified that that's actually
going to work because it's a specific snapshot of the Debian tree. Oh, that's pretty cool. Yeah,
no, that is really cool. But that's still, it's like you say with puppet and all these things.
You're still taking this malleable system and you're trying to force it to become
deterministic by sort of limiting the, yeah, you're doing the snapshot of the packages and
have some sort of definition with a state that it's supposed to go toward by installing and
uninstalling packages. Yeah, yeah, yeah. So I mean, I actually think that a lot of these systems
can be improved. I mean, I mean, Debian's even leading the way in some of them, right? The Debian
reproducibility project is great. Yeah, they're even ahead of Geeks in some ways. Yeah, yeah. And in
fact Geeks benefits massively from all of Debian's work in that space. So like, I don't mean this
to sound like I'm hating on Debian and Fedora because I have, you know, deep connections to those,
you know, like those communities have served me so well over the years. And I think I'm going to be
important for a long time to come. So I don't actually think that this is a Geeks versus, you know,
Debian and the rest of the world type thing. I think that those systems have good opportunities
to work together for a long time. But I do think that I do think that that vision of the world that
I wanted that that led me down this path that I started at, you know, quite some time ago,
is best served by Geeks and etc. Like it's the it's it has the cleanest foundation. You know,
and I mean, and like really clean in several ways, like I mean, also as in terms of like the
purity, it tries to enforce itself to be a pure free software distribution. There's no non-free
components by default. That's one distinction from Geeks next, which we haven't talked about yet.
But yeah, it's it's easier to, if you have to change your system, which I don't endorse,
but if you have to, it's easier to change a pure system that it is to pull all the tainted bits out
of a system. It's very easy, it's very easy to mess up a pure system a little bit than it is to
try to purify a messed up system. So I think it's really important that Geeks is starting with
that pure basis. So you mentioned now that Debian has a role to play and Geeks has a role to play.
So do you think that Geeks ops and and using Geeks for deployment is the the first
place where Geeks might become important for everyone? Well, I think that there are a number of ways
that Geeks might become important for everyone. And you know, so first of all, you're mentioning
kind of Geeks and Debian side by side. I currently run Geeks on top of Debian. So you don't have to
pick and choose between those two. You can run Geeks as a user space package manager. That's one
cool feature about Geeks also is that you can have different different users can be on the same
system. And if they need different versions of things, they can have a huge feature, right?
You know, your system has GCC4, but you need GCC5. It's AOK. You don't you don't even have to bake
for the system to get moved over. You can just run your own local version of it. And that's fine.
That's one of the things that like because you have that that kind of ties into the Simlink
the first thing I started to talk about you since you have that, you know, all those hashes in
there. You're basically pointing at specific versions. So that's the makes it safe.
Yeah. So let's go into that for for people who don't know how it works. So on Geeks, I as a user
can install and uninstall packages for my user only. And so how does that work?
Right. So what's this forest thing? Right. So you I mentioned that in slash can you
slash store I had this big hash before the name of bash, right? So that's like the very,
very specific version of bash that I have, you know, including all of its previous dependencies. So
so of course, if if the system, if you basically have the what's stopping another user from
installing their own version of bash, maybe they even end up installing bash that has these terrible
hacks installed in it, like terrible hacks that you really wouldn't want to use for any reason
other than that, you have these specific scripts that you created for this off purpose usage. I
don't know anybody do this, but it's an example, I guess in some ways. And so you you need this
and your assistant means like no way. There's no way we're putting that on our system. And it doesn't
really matter. You don't have to bend the system in because you can just install that hacked up version
of things. And since your version is pointing at this, you know, very specific hash, it doesn't
mess with anybody other users on the system. And there are these when geeks packages are built,
they're built and installed by these worker users by default that have pretty much no permissions
other than to create these truths where they built things and that's it. And that's going to get
even more secure because we're some kind of container support stuff has landed in geeks. So
we'll be able to even get that more isolated. So it's both secure to build. I mean, the main concern
is whether or not users install so many packages that they end up, you know, kind of filling up
the space of the system. But if one user installs some sort of thing that really isn't trustable
by the rest of the system, they're they're putting themselves at risk, you know, but not really
putting the whole system at risk or they're they're, you know, just using something goofy that
isn't going to give headaches to the rest of the users on the system. Most users actually,
most systems are kind of by single per users these days. Like my system, nobody else is on it,
but me. And that's true. A lot of people have laptops. Yeah, a lot of people have laptops. So
this might be true more on like a VPN where a lot of people have something on there. But
but even there, I think that there's another way that this becomes really useful, which is like
the geeks environment type thing, which is like say in the Python world, we have something called
virtual and right. We have our own kind of ecosystem of Python packages. And I can install a little
virtual and that has this version of Django. And then another direct rack and have a different
version of virtual and with a different version of Django. And they won't conflict with each other.
And the node does the same thing. Yeah, node does the same thing and so does Ruby and all these
things. And but but it's kind of becomes a headache because now what happens if you need one very
specific version of Django, but you also need a very specific version of like rake, which is a,
you know, Ruby tool and you need a very specific version of jQuery, right. And now you've got
three different systems of packages and you're trying to get them all to play together and it's a
big headache. It requires a lot of expertise in each one of those package management systems.
Like each language requires a heavy amount of investment to really learn the the kind of
sharp edges of that language as package manager. Well in geeks, you can actually do something
called geeks environment, which is kind of like a universal virtual and where you can have
you know, you you can start up something that has a specific of G version of GCC and a specific
version of Django. Yeah, and especially when attracted me to geeks when you and Dave started
talking about that. Yeah, yeah. So it's really great that you and and what I'd like to
in media goblin have a geek status CM file on it, but what's really cool is, you know, David Thompson
being, you know, kind of since he's kind of in Ben pushing hard on a lot of both interesting
guile projects, he starts an interesting guile project, I think at one seven once a month.
But and they are really usually pretty interesting, but but like I don't have to worry about
learning how to install and set up all the dependencies for each one of those projects,
because I can just go into each one of the ones he starts. And I could type geeks environment
dash L geek status, yeah, I mean geek status, yeah, I'm as a file that's in that thing. And it starts
up a new bash that has all of the packages pulled down that are very specific to that project.
So if if it needs guile SDL and I don't have guile, I don't have any reason for guile SDL anywhere
else on my system, well, it'll pull it down. It can even pull down a very specific version of it.
And that's fine. And it can pull down a very specific version of GCC or whatever. And it won't
mess with the rest of my system because it build a very localized file of that. And that's really
cool. Like being as a developer, being able to just give a file and say here, here's all the stuff
that you need to run with it. And it can pull it up. And you still also have that time traveling
feature of being able to roll backwards and forwards in time. And now you have it on that like
virtual environment level. Well, now I don't have to now, I don't need to shiver in my boots
the next time I thought I'd do a hackathon, right? Because yeah. And this is the next level we're
talking about. Oh, each user can have their own versions of GCC or whatever. But you can even
have it down to one process having one set of packages and another process having another set of
packages. Yeah, which is pretty amazing. Which is pretty amazing. So it's like each little
development environment. And people are like, oh, well, I've got that with Docker, right? You know,
Docker, I've got all of my packages packed in there and stuff. But what you've got in Docker
is like a whole distro. And like all of those packages that are in there like the G-Lib-C and stuff
like that might are probably not actually shared by any of the future, the other Docker things that
are on there. And people say, well, Docker's got this binary dip thing and stuff like that. But if you
upgrade your base system, that those other binary dip things were based off of like if you've got a
Debbie and that you started out with and then you upgrade that anything that's got stuff on top of
there will probably break. So like for the most part, when you end up in a kind of Docker-esque
environment, those things are not shared between them, which means that you've got like five
versions of G-Lib-C running in memory or whatever. Well, that's not true in geek. Oh, yeah, that's true.
It eats memory as well. Yeah, it eats a lot of memory and it eats a lot of disk space because
there's a lot of redundancy. Well, you don't have that running through redundancy in geeks. I mean,
you might. Yeah, in Docker, you need to be very careful that if you have several images,
you need to make sure that it's able to use the ButterFS function of having the base image
and then every every other image being based off that in the file system. Right, right. So
that it can share blocks. And like you said, you upgrade the base system, you lose that. Yeah,
yeah. So when you're doing these geeks things, then you have your store and it's just files.
There's no low-level file system. It's just files and they're either simlinked into some
bin directory somewhere and some lib directory or
with geeks environment, you can just set up all the path variables so that you can reach these
things. Right. And so I currently have those two versions of bash 4.3.39. But that's because I've
done some upgrades on my system. The difference is that I can I can have I can just I'm like, well,
I don't need to roll back into any of the previous versions anymore. So I dropped those old profiles
and I can now do geeks GC and it just garbage collects away all the old stuff I don't need. So I
can have multiple versions of things. But the moment that I no longer need those previous provisions,
they just get garbage collected away. Yeah, which is pretty nice. And in the meanwhile,
hey, even when you have those two, it still does the duplication between them. Yep, exactly,
exactly. And which is pretty awesome as well. Pretty awesome. Pretty awesome.
Without low-level file system magic, well, it's just fine on x4. Yep, yep, exactly.
And yeah, I'm running x4 here. I'm not running any complicated butter fs stuff.
But but that thing that you're talking about with the environment stuff is you could take that
environment thing and not only can you do the environment thing like the virtual type thing. You
can also do this for containers and for virtual machines, right? So right, that was one of the things
that I also saw before I even started using geeks that you showed the command line or I read it
in the mailing list or whatever you just do geeks system VM and it produces the command line
that allows you to run a VM with a certain set of packages installed. Yeah,
hilariously, when you run geeks system VM, it doesn't actually boot it up. It returns a
bash script that it generated for you to boot it up. But then you can run that bash script over
and over again, or you can get a new bash script when things have changed. But yeah, that's really,
I think that's really nice. So one of the things that also really appeals to me is that,
so see, I'm doing a lot of deployment stuff. And I want to, and I guess we said we'd get into
geeks ops and stuff, but we haven't yet, but, but you can already get a sense of this right now.
So see, I'm still not nibbling at it. Yeah, we're nibbling at it a bit. So say you're doing
system configuration. And I've set up my system config, which is just scheme code again.
I could build a fancy UI on top of it, or I could just write out this scheme stuff myself. Either way,
this makes that really easy. So I've written out my system config, and I'm like, I think this
is exactly the way I want it. Right? I can do system system VM, or the geeks system container.
I don't remember what the container command is, but I can boot it up in a VM or a container,
and I can verify that that system is exactly what I want before I push it off to the network.
In theory, you can even actually build all this stuff. Say you've got custom packages and
stuff, you can build all those custom packages locally and push them over, like push the closure
of the system over to that machine once you've got it all verified locally. I mean, you can have
it build there too, or pull it down from Hydra or whatever, but, but you can, but I think that's
pretty cool. And since you have that functional promise that the inputs will always give the same
outputs, you are able to be sure that the system that you're going to deploy is the one that you've
got locally. And that's pretty neat, because now you can splat that across a bunch of machines,
and you don't have to be afraid that there's some race condition in between the time in which you
ended up verifying that things are okay, and then you went to sleep, and then you woke up in the
morning, and then you pushed it over to the machines, and oh, no, you know, a new version of this
package came out and all my stuff broke. And now I just pushed a bunch of broken stuff to a bunch of
servers. Well, that's no problem. You don't have to worry about that. You know, you can push out exactly
that version of the system, and it's no problem. Yeah. So, uh, let's, let's go back and talk about
Nix. Yeah. Yeah. So I was really surprised. Uh, I found Geeks first, and then I started learning
about Nix, and then I found out holy crap, this stuff is really old. Well, it's been around since
2004, if I remember correctly. Yeah, I guess it is about a decade old. So, um, so I guess you're right.
I didn't think about it being as old as Ubuntu. I mean, I think Nix is also taken off in a lot of
ways over the last few years, similar to Geeks. Uh, it has a bigger user base than Geeks currently,
but I think Geeks is going faster right now is my biased view of things like it's accelerating faster,
but it has less of a large base right now. Um, but, but you're right, that the Nix has been around
for a while. Um, uh, so Nix, I think is what pioneered most of the ideas that Geeks is using.
It pioneered the store, it pioneered the functional package management stuff. Uh, pioneered almost
all of it. Um, and Geeks makes kind of two big, uh, splits off from, from Nix and two big ways.
So the founder of Geeks was one of, I think he was a developer on Nix, and I think actually one of
the core developers at one point, uh, Ludovic, uh, was one of the core developers, I think he was at
least a developer on Nix first, and then he became inspired to sort of Geeks, uh, because of some
of the limitations he saw in Nix. And those limitations, okay, that, that's not how I saw it, but,
I guess you've looked deeper into it. I, I think that's what it was. I thought he came from the Geeks
idea first and then looked up. So is there something I could build off? But you're saying actually,
he was already on Nix. If I remember correctly, he started out in Nix, and then, uh, when, uh,
started Geeks, uh, basically perceiving some limitations in there. And he was, okay, cool. He was a
guide developer and a neat Nix developer at the same time. It's my understanding. So Ludovic,
the Cortez is not only, uh, Geeks is founder and maintainer. He's also one of the three
co-maintainers of Guile. And Guile has three really great co-maintainers, Andy Wingo,
Mark Weaver, and Ludovic Cortez are all three amazing people, in my view. Uh, and, um,
so he, he, he started, uh, working on, uh, Geeks. And, and when Geeks made these Geeks shares very
little code with Nix, even though it shares almost all the conceptual things, it shares the Damon
that, uh, does the building and installing of things in the background on your system. But other
than that, Geeks has all original code written in scheme. Um, and so the fact that it's written in
scheme is one big difference. Nix has its own domain specific language, which, uh, is also functional,
but it's kind of just used for building the packages. There's a whole bunch of other languages
that are used for the different parts of the system, whereas Geeks is scheme from top to bottom.
It's Guile, top to bottom. Um, and, uh, I'll talk for in a minute about why I think that's really
valuable, but there's one other big difference, which is that Geeks is completely free software,
top to bottom. You know, it's, you know, Linux Libreon up and, um, and you could corrupt it if
you wanted to, but I think it's pretty great that you've got a completely free system from top to
bottom. Uh, yeah, good, clean starting point, like you said before. Yeah. Uh, oh, also Nix uses
system D and Geeks uses, uh, DMD, which is, uh, um, which I think a lot of people assume is for
some sort of system D hater reason, like, uh, but it's actually, it's actually for a very good
technical reason. Um, you know, the, uh, uh, the, the reason that Geeks uses DMD is because of that
service composition stuff we talked about earlier. Um, you, because DMD is also written in Guile,
it's possible to be able to express the system in a way where you can compose the construction
of the system. I could write a web interface that gives people the options that they can select all
those things and it's building out structures and scheme to build out my system exactly the same
way that it is to build up the packages and the package definitions and stuff. And that's a really
good feature. Uh, it, it does mean that, um, they're getting good own package to spend a little bit
difficult, but that's a whole other topic that we test the system D dependency. Right. That, um,
which is mostly, I think, at this point, log in D, uh, for, uh, GDM, uh, is using log in D and
Andy Wingo split out E log in D, which, uh, is a version of log in D that does not depend on system D.
I don't know how well it'll be maintained. Um, but it does seem to be working. Um, I'm not sure
what other dependencies on system D genome currently has. Uh, there's a good number of people in Geeks
who really want genome, um, yeah, but and are working on it. Um, but that it's a lot of work to get
things included and, um, I do worry a little bit that the future of, and I'm not a system D
hater. I think system D is really nice on my Debian machine, but I do really value the things that
Geeks provide for me with the system composition stuff. And that's really important to my long-term
plan. So I, I really hope that genome does not become intertwined in a way that makes it difficult
for Geeks and genome to get along in the long term. Um, but that's kind of a tangent, uh, uh, and
probably one that I'll end there. The other more important one was actually the, the general point
of Geeks being built off of scheme from top to bottom. Um, yeah. And as I said, Nix kind of has a
variety of languages, including its, you know, domain-specific language for packaging. I don't
know Nix very well, but the big advantage that I see in Geeks is because it is scheme from top
to bottom, which is, you know, you can write your system configuration in it by hand. And I,
I like writing S expressions, not everybody does. Um, you know, there's, there's a system called
Wisp that makes things a little bit more pathonic if you'd prefer to use that. Uh, but, um, the, uh,
but, uh, it, it's actually the main feature for me was not this very low-level diving into,
you know, scheme as this academic language type thing. Keep in mind that I started out as like a
Python hacker about a year ago where I was like, oh, I, I love mutation, you know, like, uh,
and like, I want to build a webinar phase. That's what I really wanted. I want to know. Yeah,
you, you came in from, do this from a practical direction. Yeah, I came in from a practical direction
in a very top-down direction of like, I want to serve users, uh, and I want users to be able to
deploy their systems for, and they're, these are these specific needs. And it was really over time,
I realized that no other system provided what I needed. And one of the key pieces that Geeks
provides is that scheme from top to bottom. Um, because you've got the same language to configure
your system as it is to write the packages as it is to everything else, it means that you can just
as a program build out every single part of this system. You can build out, you can build out
logically based off of user inputs. The system definition that somebody explained to you if they
need, you can build out. Um, there's the amount of code to write the Geeks system VM stuff that
starts up the virtual machine is stunningly small. I think that you commented on, uh, the pump
of verse this, like, didn't you end up looking at it or something and like you were like,
I love that I remember about this entirely possible.
Well, the, the, but it is, it is pretty stunning. Like the, the amount of code that you need to build
these kind of features is pretty small because since everything's built in a really nice and sane
language that's really optimized for adding new languages on top of it where, you know, you can use
all the other language features together because it's just as expressions. Um, you can build amazingly
expressive systems where normally you're like, okay, I've got my puppet here and I'm going to
try to substitute in these really difficult string expressions into this config file system and
I'm going to have to think really hard about how that other system wants me to do message passing
between it and all these different like difficult layers between there are not difficult at all.
They're not difficult at all in Geeks and that's because of the decision to use Guile.
So I think that that's, that's the number one feature of Geeks. And when I explain that,
it normally sounds like, oh, I love Lisp so much and I love Corentesis so much. I just want to hug
and kiss parentheses and, you know, I'm such an academic nerd. But the reality is is that it's
actually the opposite. I, I, I'm so concerned about everyday users and I just don't see any other
path to get to that point. I don't see any other path that's sustainable in the long run.
There, you, we maybe we could keep hacking these other systems but I don't think,
I don't think that it'll be as easy for them to provide those features as it, as it has been
easy for Geeks to build these other things on top of them because good foundations really do matter.
Yeah. Yeah, I think I'm running Geeks now. I used to run first a Nix VM and then Geeks as a
package manager beside and then try to install most of my packages from Geeks and then just,
I wanted GNOME. And so then I used Nix as a base to to get GNOME in there. But lately I removed
that VM and now I'm running a Geeks as DVM. I'm using, I'm using Enlightenment instead.
Enlightenment. Because I saw that, wow, there's Enlightenment in there. That's so cool. I'll use that.
And, and then I'm running Nix packages on the side instead. Oh, cool. Because there's,
they have more packages. It's an old distribution. It has had more people. So there's some stuff
in there that that is not yet in Geeks. Yeah, that's so now Geeks SD is my base system in the VM.
And then I had the Nix packages on the side. Wow. So that's pretty cool that we,
we've reached a point where I feel that's actually a practical thing to do. Yeah, nice. You're
even further ahead than I am. I'm still running that data on this thing. I actually have, I just
ordered a, oh, I had one more thing. I was running this Geeks machine and then Nix packages on
the side. And then there was one package that I needed that was neither in Geeks nor next. Oh,
what was it? Cluster SSH. Oh, okay. So I ended up doing a devian jail. Oh, maybe you should
package it for Geeks. Yeah, it's on my to do list. I have this long list of things that in my
copious spare time in the future, I'm going to package this and that and cluster SSH. I think
actually cluster SSH is in there. I don't remember if it's in Nix or Geeks, but it's in there,
but it doesn't work. Oh, interesting. Well, we should fix that. Because it's, it's like hard
coding to respond to by what name it's called or something like that. And it messes up things.
And it does the wrong thing. So that's why I ended up doing the devian jail just just to get
cluster SSH. I'm taking a look. Oh, wait. I do not. But yeah, I think, I think we covered most of
what Geeks is good for and why everyone should be looking into it. Yeah. And I think, and like we said,
you come from the practical angle and I think that's the, maybe the place to start. If someone is
doing development, they should really consider doing Geeks package definition for that thing with
dependencies and use as their language, agnostic virtual end to work in because that's, that's pretty
awesome. That most of all that while you're working on your thing, you don't want the dependencies to
change underneath your feet while you're working. Right. So you're upgrading your system and the
new Firefox comes out and so on. You always want to keep your system upgraded. But if you have
a profile for the package you're developing in that profile can keep a static set of packages
that doesn't change when you upgrade the system. Right. Or you could, so that the only moving part
that changes is the code that you are changing. Right. And if something does change, you can figure
out what it is because you can kind of bisect your way back and forth. I don't know what Geeks
bisect has been written like get bisect, but it should be. Yeah. It's probably on, at least,
some, at least one person probably has it on the, well, maybe Ludovic will listen to this or Dave
and they'll just like, they'll just implement it. I'm constantly amazed that I look at the list
and Ludovic Dave and Mark Weaver are just like, I look on that list and at every, every week,
like each one of them seems to like contribute some sort of major new thing that just astounds me.
And I think the latest thing, I haven't been keeping so much up to date the latest month or two,
but the latest thing I saw was that whole rewriting of the whole services structure. That was
pretty impressive. Yeah. Yeah. That was pretty amazing. He didn't take long. He was like, they
discussed, hey, maybe we should do things this way instead and then someone sat down and just a
couple of weeks. Yeah. Yeah. This entirely new thing. Yeah. I think it was actually Andy Wingo
was writing out. It was one of the systems that he had tried to put in place. Maybe it's color
D or something. I think he was actually trying to get something in good home and like debust or
something like that. And he was running into, you know, he needed each system to kind of be able to
pass information around to the other ones. And Ludovic was like, oh, I'll just run. It was just like,
oh, yeah, it was, was about one service knowing about other services that it would have to
present some something. Yeah, you're right. And then there, like, like you said, debust, it needs to
know what services to activate. And then it needs to know they exist. Yeah. So Ludovic just kind of
spoke, spec'd up this plan. If I'm remembering this correctly, and like over a couple of days,
like suddenly he's just like, oh, I've got a prototype right here. And people like,
it needs to work. And like within, within no time, that thing has hit the list. It's, it's,
it's pretty astounding, I think. Yeah. Yeah. So if people want to look at geeks, now they're really
excited after hearing you being all excited about it for over an hour. Yeah, hour 15 minutes.
Then they can just go to a new org slash s slash geeks. Yep. You should check it out. It's
great. They've got a nice video on there from Ludovic speaking about it as well.
Oh, I haven't seen that. Cool. I'll check it out. It is considered alpha software. But I think as
you said, it's, it's much, it kind of feels like that alpha software badge doesn't really belong
on there to me in some ways. I think the most alpha thing about it is that you don't have a nice
graphical installer. Yeah. There's no nice. But I think that I think that it's the most awesome
installer I've ever seen for any system. Because, okay, I'm here at the prom. What should I do? I want
the system. Okay. Write the definition for your system. And then you apply it to your machine.
And then you have a system. I think that's that's when you've done that install, you sort of
experience the full power of geek. Yeah, it is pretty mind-blowing to go through that process.
And if something is something screws up on the way, you just do it again. And you can, it's
like, what do they say about HTTP operations? It's only something.
Only potent, no? Oh, item posts or whatever. I don't know. I don't know how you can ask that. But
yeah, you're right. It won't screw it up. If you've done it once, you can do it again and it won't
break things. And I've, and basically that's how you upgrade the system or you add services. You
basically regenerate the system every time. Oh, that's one thing because it's functional.
What we hadn't talked about is that not only can you roll backwards and forwards and time across
packages, but you can also do it across the system's configuration. Which means that if you're
upgrading a server, and this is where, and we really didn't have time to get into GeekSops,
and I don't think we should, because GeekSops doesn't really, it's kind of starting to exist, but
but that's the big promise of GeekSops is that you can write out your system. And if you have a
system upgrade that goes badly, you can roll back the whole config, not like, including the Apache
and Ngedex configs on stuff like that. And that's pretty cool. Now, what database migrations
that are a whole other topic, I've got ideas on how to deal with that. That's mutable state.
You mutable state, right? But, uh, well, database migrations are in any system.
Yeah, I do think that we could get to the point where we can explain to Geeks, like,
here is where the mutable stuff from this system is. And so when you do an upgrade,
uh, before you run all of the migrations and stuff like that, you could run a command that
backs up all your mutable state. And that, I think, would be the good solution that we could have,
so that people could upgrade their Media Goblin Instance and not be afraid to do the migrations,
or whatever, because they could just roll back from a backup. And they don't have to locate
that Geeks already knows where all that backup that mutable state is. But that's kind of a far
future kind of, you know, starry-eyed thing that doesn't exist yet. But I think it could be.
So, yeah, I guess, do you have anything else you want to talk about, or should we kind of get to
the wind down part? Yeah, I think we're winding down. We covered most of the things that I wanted to
talk about. Okay, should we do the... What does it do? Why is it awesome? What's the difference between
the package manager and the Geeks SD? Why is there a guy everywhere? What's the relationship
between Geeks and Nix? And how will this take over the world? Yeah, should we do... So a lot of
shows end up doing plugs where you talk about something that you think is really cool, or something
you're working on, or something that you think other people should know about, but not necessarily,
but could be tied into the show. So, should we do some plugs? I don't really have anything to plug,
but I'll take Geeks, the Geeks fundraiser then. Oh, yeah. Geeks is looking to upgrade
this server product because it's becoming so popular that the servers that are providing the
pre-compiled binaries are starting to get overloaded. Yeah, and the... So, this is actually,
hopefully by the time we publish this, it will be officially out. Dave Thompson kind of pre-announced
it on the pump of verse today, but the actual announcement has not been put out yet, but hopefully
by the time this comes out, it'll be out there, but there will be a donation link on Geeks's website
that you'll be able to find to donate to the server farm. And I think it'd be... It's really useful
to the long term of the project, and they're also doing it through the FSF. Very similar to
how Media Goblin was funded through the FSF, which paid for my salary for a while, and obviously
am all supportive of. So, people should definitely donate to that when they see it. It'll be worth your
money. I promise. The future of freedom, thanks you for your donations. Oh, hey, I have something to
plug for myself, actually. Okay, great. And I will be going to fast them. I'll beat you. You're going?
Yeah, I am going. Wow, that's great. So, I'll see you there. I'm bringing some friends. I managed
to excite a couple of people in the office, so we're getting accommodations together and going
there. Oh, awesome. So, yeah, we... Actually, I wasn't sure if I was going to go, but I basically
sent an email to the list being like, I don't know if I should go to FASDM or not to the Media Goblin
list. I'm like, because I'm kind of broke, well, I mean, you know, like there's basically not a lot
of money left in the budget. We've been spending it on Jessica's hard work on Federation. So,
I don't know if I should keep pumping out money from my own personal account to go to these conferences
and a bunch of people donated. And I'm like, well, I guess that's a sign. So,
so if you actually donate between now and FASDM, we might have a little Media Goblin
dinner thing that we meet up. It might be tied into Conservancy's dinner, like have a table at
Conservancy's dinner, but yeah, there's motivation for you to donate to Media Goblin as well,
if you want. But yeah, cool. I'm just really looking forward. There will be a Guile in Geeksroom
at FASDM. So, yeah, so people should drop by there. I'll be giving at least one talk possibly too.
So, okay, cool. Yeah. In the Geeksroom or on Media Goblin? In the Guileroom. I might be giving
another talk as well outside of there. It depends. I might be giving a talk on deployment,
but it depends on what that can accept, accept it elsewhere. I submitted a couple of talks
to the Guileroom as well. Very cool. So, apart from what you already did, you have something else to
plug? I have a few things to plug. I apologize. I'm going to list them off as quick as I can.
Oh, no, no, no. First of all, Software Freedom Conservancy is running a fundraiser
supporter program. I made a nice copy heart logo for them for this thing, and you shouldn't let
that effort go to waste. You should support copy left compliance. So, I think it's sfconservancy.org
slash support or support ur. Sounds right. I don't remember. Yeah, it's either support or
supporter. And you should definitely donate because they're doing great work. I mean,
after service also doing a fundraiser and they can also use your donations. Conservancy,
especially as important to me this year, because they're trying to move to a supporter model.
And that's that's I think it would be really good for the long term of free software for
a conservancy to be able to be supported in that way. Yeah, one sign of you doing good work is
that you upset some people. And apparently, the conservancy has now done good enough work that
they upset some people. So they are support. They do need our support. And they're doing great work.
So, so that's number one. Number two is I have a project that will be coming around the corner.
Very released soon. It the project's already out there, but you hopefully people will be able to
see it more prominently because we'll have a website up soon called eight sync, which is eight
number eight and S Y and C. It is like no JS or async I will for Python, except for Guile. And it
uses limited continuations. I know this is getting really jargony, but basically you normally have
to write code in an asynchronous environment where you end up as in some sort of nasty callback hell.
And then eight sync for various reasons, you don't. Writing asynchronous code is about justice.
That's the only way to our show by itself. Yeah, it's the limited continuations and why do they make eight sync great?
Yeah, we should do that in the future when we get eight sync 0.1 out or something.
But yeah, that's one thing. Also, if you're interested in getting involved in Guile, I just submitted a
I'm starting to work on and it should be fleshed out more by the time that this episode comes out,
a tutorial on how to get involved in like how to start using Guile, because I think the current
manual is amazing as a reference, but doesn't kind of give you a nice kind of jumping guide. So,
if you check them, Guile, develop mailing list, you'll find the link. I can also spell it out.
It said dustycloud.org slash MISC slash. Oh, I should actually check before I start saying things.
I'll put it in the show notes as well. So that's much better. That's much better. So
there's something dusty cloud. Oh, yeah, dusty cloud.org slash mix slash guile-tutorial.html.
That's a temporary URL for you. But I'd love feedback. If you have it, please send me an email.
And I actually keep plugging things, but I think that's enough for now.
No, that's pretty good.
Now, right? So, yeah, thanks. Thank you for this chat, and I'll be seeing you at Fostom then.
Yes, you at Fostom, and I'd love to do another one of these again. If you enjoyed it, I really enjoyed it.
I certainly did. So, let's do eight sync when you're getting ready with that.
All right, sounds good. All right, later. See ya.
You've been listening to HECCA Public Radio at HECCA Public Radio.org.
We are a community podcast network that releases shows every weekday, Monday through Friday.
Today's show, like all our shows, was contributed by an HPR listener like yourself.
If you ever thought of recording a podcast, then click on our contributing to find out
how easy it really is. HECCA Public Radio was founded by the Digital Dove Pound
and the Infonomicon Computer Club, and it's part of the binary revolution at binrev.com.
If you have comments on today's show, please email the host directly, leave a comment on the website
or record a follow-up episode yourself. Unless otherwise stated, today's show is released under
Creative Commons' Extribution, ShareLight 3.0 license.
