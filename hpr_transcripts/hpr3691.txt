Episode: 3691
Title: HPR3691: Starship.rs the best prompt I don't use
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3691/hpr3691.mp3
Transcribed: 2025-10-25 04:10:14

---

This is Hacker Public Radio Episode 3691 from Monday the 26th of September 2022.
Today's show is entitled Starship are S the Best Prompt I Don't Use.
It is hosted by Klaatu and is about 25 minutes long.
To carry a clean flag, the summary is, Bash Prompts.
Hey everybody, this is Klaatu and I'm going to talk today about starship.rs. Starship.rs is
a rust-powered cross shell prompt.
So this is an application that you install onto your Linux or Unix machine and it provides
as long as you put a line into your .bashrc file to start this application up.
It provides a dynamic shell prompt with all kinds of information, optionally, in your
prompt. First of all, I mean the default, I guess, is I think host name.
And then if you are in a Git repository, it will tell you what Git repository or what
Git branch you're on.
And I believe it also understands if you're in an environment, if you're in a specific
programming environment, let's say, which is a weird thing to say.
But like if you have an environment configured within your shell to be using a specific
programming language, a specific version of a programming language, then this prompt
also detects that.
So for instance, if you have made your default, I don't know, Python version for that shell,
Python 3.10, because maybe you have entered a, like one of those Python environments,
a virtual environment, then this starship RS would pick that up and then let you know
it would display that for you.
And by default, it has a bunch of pretty little icons that it uses, like a mode, not
a mode, yeah, a mode to, no, emojis, emojis to sort of like, look, this is the version
of Rust you're using, it shows you a little crab, or look, this is the Python version
that you're using, it shows you a little snake or Java, and it's got a little coffee cup
and so on.
So it is designed to be a very attractive and kind of pretty and prompt for your terminal.
And I mean, I have to admit, it really spices things up.
It's really quite nice to be honest.
And it's easy to install.
You just install the binary, the binary executable and you're up and running.
It's just, it's that simple.
You just kind of download it, you put it somewhere on your path and you put I think one or two
things into your Bash RC and you're good to go.
And specifically, it's Eval, quote, dollar sign, parentheses, starship, and knit bash,
close parentheses, close quote.
And it is a cross shell, so it works with bash, it works with fish, it works with ZSH,
it works with PowerShell, and others that I haven't even heard of before, well, TCSH,
that's a good one, and so on.
So it's something that can work with lots of different shells.
It is something that is very attractive and actually informative.
That's the cool thing, is that this little application actually adds to your terminal experience.
Yes, it's pretty.
Yes, it's got nice little emoji that change depending on what kind of environment you're
in.
It is a very sort of active kind of prompt, I mean, it doesn't like blink or anything,
or scroll or anything like that, but it is, it does change depending on your environment,
which is nice.
It's got a lot of color turned on and there's a lot of configurability.
You can go or I should say, well, yeah, configurability, I guess, or I guess you could say customization.
But you can decide what kind of information you want to have displayed in your prompt.
And there are templates and examples and options for you to activate or deactivate depending
on what you use, what's actually useful for you.
If you don't program and rust, then maybe you don't need that option, I mean, I guess just
leave it on, it'll never show.
But I mean, you don't mean like if you don't need something, then maybe that's not something
that's useful for you.
So you could, you could not have that on, but if maybe you program very frequently and
something else and so you could have that on, or maybe you don't use Git or maybe you
use Git, but you don't care what branch you're in ever.
So you could deactivate that.
A cool one, another cool one is the pseudo plugin or option, whatever, configuration option,
where if you have pseudo credentials cached, then it shows you a little alert symbol showing
you that yes, you are currently, you currently have authentication under pseudo privileges.
And once that expires, then the little, then the icon goes away.
So it's informative stuff.
It's really, really useful or maybe just one really, it's really useful.
It's mildly useful and, and it's kind of neat and, and like I say, it's really simple
to set up.
You download the binary executable or you can compile it from source code, it's open source.
You place it somewhere on your path and then you invoke it in your, in your shell, init
script, whatever that is, bash RC or C, CS, HRC or whatever you've got going, is that
SHRC, whatever.
So that's Starship RS and I don't use it.
So I did use it for like, you know, like a month and it was, it was fine.
It was fun.
It was a pleasure to experience.
It was really, it was a lot of fun and I highly recommend it.
If it sounds like something that would be of interest to you, what ended up happening
for me was that the configuration was complex and, and I, I never got my configuration quite
right.
I was always seemingly displeased with whatever it was showing me at any given time and I
don't know why.
I can't actually explain why that is.
I just think that it, I just never quite found like exactly what I wanted or if I, if
I felt like I did know what I wanted, then when I could, would configure it, it seemed
to sort of take that away from me because of some, because of an environment, you know,
because I was in a different environment than, than, than what I wanted to see strangely.
So it was one of those things that I just, through being sort of particular about what
I wanted on screen, I could never quite get it right.
And that's, I don't think that that's a, I don't think that that's, it's a fault.
I think that that's just me, a combination of me not knowing exactly what I want or eventually
knowing what I want, but then not taking the time to learn how to get it configured.
And then there was this small little thing that kind of kicked me over the edge, which
was when I started a shell in EMAX, which I do fairly often, I don't, it kind of goes
back and forth sometimes some, some weeks I'm, I'm always in terminal EMAX, sometimes
I'm not.
But when I did start a terminal in EMAX, it would never understand, it just couldn't
generate a prompt, it couldn't use Starship, I guess, to, to render a prompt.
And so then it would render an error message and it just, it was annoying, it was annoying
enough for me to decide that Starship.rs wasn't for me right now.
That's not to say it'll never be for me.
If, if I switched from EMAX to something else, which absolutely could happen, like I'm
not, I'm not married to EMAX, it's just, it's just currently the one that I use because
it's the one that I'm comfortable with and I have no, there's no real impetus to
change away from EMAX and so I'm using it quite happily.
So if I switched away from EMAX, I could see myself using Starship, or if I took the
time to figure out how to get the E shell to ignore the Starship initialization call,
then that would work too, because then I wouldn't, I wouldn't care so much about not
having a prompt in my E shell or rather having an error message as my prompt in E shell,
which is really, really annoying.
So I got rid of Starship in the end, but I, I learned the value of having a really,
really descriptive prompt and I, I have to say, I don't know why it sort of took Starship
to teach me this.
I actually used to have a really descriptive prompt at an old job where the shell configuration
wasn't really up to me and it, it had the history number, the environment name because
at this job there were, there were specific environments that you would have to switch
into in order to work on a project.
So if there was a project that you were working on called, I don't know, Alpaca, then, then
you would have to switch, you would, you would have to activate the Alpaca environment
and then your shell prompt would reflect that.
So you would always know or you could always know by looking what environment you were,
that, that terminal, that session was keyed into, which was significant because that, that
defined where specific data directories were and where render directories were and so
on.
So that was a big deal.
And then I think there was a, oh, probably the current directory, like the literal current
path that you were in and I think that was probably it.
And that was on its own line and then the prompt would occur under that.
And then I think there was, I want to say, I want to say there was, it might have even
been a blank line above it.
So it was a very sort of segmented experience and it felt really weird at the time, but
I kind of got, I fell into it because it was at work and it just became sort of the
work thing that like that was how the work terminal worked and that was reflected in
several different ways.
I mean, I didn't use bash at that job.
I used TCSH.
So I just kind of, I don't know, the whole thing felt kind of like this is what happens
at work, but it stays at work.
You don't take that home with you.
And so I think when I, when I tried out Starship and it sort of had the same thing going on,
it felt eerily familiar to me on the one hand and at first it felt almost incorrect.
It felt wrong to be, to have that kind of prompt at home.
But then I kind of remembered how actually how useful that was.
I mean, it's verbose, there's a lot going on, but then again, it's also verbose, there's
a lot going on and there's a strong delimiter between the command that you ran and the command
that you're about to run or if you're scrolling up in your terminal, then you kind of, you
kind of get to see where all the commands happened.
Like it's really, really easy because there's this big long line of colorful text literally
drawing a line through the terminal as to where each major event happened.
So I decided that I would try that myself in bash with just pure, pure bash, no, no
rust involved.
I, it kind of occurred to me that my use case for this didn't really require a rust
application to drive my bash prompt.
I could do this with bash options.
So I did a little tiny bit of research, you know, part of which I already knew.
I mean, this isn't super advanced stuff, but I'm going to just kind of really quick
like go through it.
So one of the things that I actually change pretty regularly is my Java version.
So because I do a lot of, I do a lot of, as much Java programming as I can, because I
really, really love it.
So for that, I just put in a function in my bash RC, Java underscore version, all capitals
equals back tick Java dash dash version pipe head dash one pipe cut dash F2 dash D quote
space quote, back tick.
So obviously just parsing the output of Java dash dash version, not a big deal, pretty
easy.
I use a Java version manager called SDK man and SDK man adjusts my environment.
And this just takes this just responds to, you know, this uses the Java that is a part
of this environment.
So that works quite well.
You could probably use something similar with Python Python underscore version equals Python
three dash C quote import cis semicolon print, you know, something like quote, dot quote,
join parentheses map, parentheses string or STR or S whatever, comma, cis dot version dot
info square bracket colon three square bracket parentheses, parentheses, parentheses, close
quote, close back tick, something like that should work, I imagine.
But then again, I don't, I'm not 100% sure.
Like if you go into a virtual environment within Python, yeah, that should work, right?
I don't know.
I guess you would probably just want to do Python dash C not Python three.
My problem is that on Slack where I have Python two and Python three and technically Python
two, well, nothing technical about it.
They both exist.
And so in order to get the Python three version, I would want to specify Python three.
But then does that limit what would happen if I was to go into a virtual environment?
I don't know.
I'd have to test it.
I don't know off the top of my head.
But you could obviously do that for your favorite language.
Like whatever language you're frequently using and switching around, you could have a
function in there to describe that for you.
Then I create another variable called IP and that goes IP equals, back tick, host name,
dash capital, I pipe,ock, single quote, curly brace, print, dollar sign one, semicolon, curly
brace, single quote, closed parentheses, or closed back tick, rather.
I don't know why I have parentheses in here.
I'm not sure why I did that.
I'm adjusting as I speak.
I also don't know why I used oct parse that other rather than cut.
I don't really know.
But anyway, then I do a source of slash user doc, get dash two dot three five dot one.
So I'll have to update that manually if I ever update, get slash contrib slash completion,
slash get dash prompt dot s h, get dash prompt dot s h is really, really cool.
A little shell script that ships with get, you probably have it on your system right
now.
You may or may not know it.
You can invoke it and it will, it will put get stuff into your prompt super, super simple.
So it already exists.
And then finally I did a PS one equals and this is where it kind of gets ugly.
So well, first of all, in order to do the, do pretty colors, I, I defined human readable
colors like green equals single quote, the back slash E bracket zero, semicolon 32
M close quote.
And these are just values that I looked up on, you know, TLDP dot org or whatever it is,
the Linux documentation project, white equals a single quote back slash E square bracket
97 M close single quote and so on.
So a bunch of colors got defined at the top of the bash RC.
Then I do PS one equals single quote back slash exclamation point, which is the, the history.
So I always know and I can always tell just by looking up where I am in, in, in my history
file.
And so if I need to redo a command that's within easy scroll distance of where I am or
just look by looking up, I can invoke that number.
That's been really handy.
And then I do square bracket back slash square bracket, single quote, dollar sign green
single quote back slash square bracket dollar sign or not dollar sign, sorry, back tick,
I guess, although actually I did dollar sign parentheses.
So I guess I should keep it with that because that's working host name dash S close parentheses
space dollar sign IP.
Now remember, that's the, that's the IP address that I, that I defined as a variable
previously back slash square bracket, single quote dollar sign plain, close single quote
back slash square bracket square bracket square space square bracket back slash square
bracket, single quote dollar sign cyan, close quote back slash square bracket dollar sign
parentheses P W D dash capital P. So that gives me my current location on my file system
close parentheses back slash square bracket, single quote dollar sign plain and all that
stuff.
And then eventually a space dollar sign parentheses underscore underscore get underscore
P S one.
Now I'm able to use that because I sourced the get prompt dot S H. So that's a function
from get dash prompt dot S H. You just get that for free as long as you source that little
shell script that's included in the get distribution.
And then let's see then I change the color to purple, oh yeah, I remember doing this.
So quote square bracket back slash square bracket, single quote dollar sign purple, close
single quotes black back slash square bracket.
And then I have a little get symbol, little fork get symbol space percent S. And then I
switch back to plain and so on.
So I've got a bunch of things in there to change the color.
And the way that you change color in this is you at the front of a thing, you tell you
invoke that color.
And then behind that thing, you invoke a different color to sort of like turn off that color
and go back to like plain or white or whatever your normal color is.
It makes for really, really ugly prompt.
And I'll paste all of this into the show notes, I promise.
It makes for an ugly to look at it.
It's horrible.
But once you, you know, once, once it gets rendered, it looks really nice.
And then there's a little coffee cup and square bracket coffee cup, single quote dollar sign
Java underscore version, remember, that's the variable for the JavaScript, the Java version.
I don't know why it's a JavaScript version, Java underscore version that I created earlier
single quote square brackets and then backslash in to give myself a new line.
And then I switch over to green, do a dollar sign, switch back to plain space, close the
single quote.
It's a very long prompt.
It's got a lot of data in it.
But when it renders, it's really nice.
I've got my history number and then I got my host name and IP address, which I put in
by the way, because I very frequently SSH into something else, some other system.
And it's just really useful to know when I'm not on my local system.
And I've tried little things, I've tried subtle reminders to myself, like changing a prompt
when I go to a different system, like just the prompt symbol, which is normally what
I used to have.
And that just the more you're on different systems, the less I guess you kind of pay attention
to the prompt or something.
And so I have really taken to just making it very explicit for myself, which system I
am on.
So host name and IP address doesn't matter.
What I identify that system as, like this is the confirmation that you're on this system
or not.
And then the home, the directory that I'm in, and then the version of Java that I'm currently
have active in this shell session.
And then a blank line and then a dollars, a green dollar sign prompt and then a space.
And then that's where I type my commands.
So that's my shell prompt in pure bash, so no rust dependencies.
And when I'm in Emax, if I do a meta X or super X or whatever that button's called, it's
alt anyway.
And then do, for instance, eShell, I get a simplified, like I get a normal prompt.
It's not the prompt from the bash RC, but it is a reasonable prompt.
It is not a prompt that is an error message about not being able to load a rust thing.
So that's kind of, that's what I want really.
I don't necessarily need my prompt to be the same as it is in bash when I'm in eShell.
I don't care about that, but I do at least want it to be a reasonable prompt.
And that's, that has been achieved.
So I realize it's probably, like on one hand, a little silly to opt out of something
just because I couldn't be bothered to figure out how to make it work with an occasional
shell that I sometimes use in Emax.
I could easily switch from Emax.
I could easily stop using eShell.
I could easily do the research to figure out how to use the other thing in eShell, whatever.
It doesn't matter.
Point is, Starship, it is really nice.
And I do recommend it.
I mean, I recommend it in so far as I used it for a month and didn't, you know, and enjoyed
it.
Like I didn't hate it.
It was fun.
So if that sounds like something useful for you, then check it out.
And if it doesn't, that's fine too.
As everyone knows, and I'm just finding out, bash prompts can be actually really useful.
I mean, I don't, you know, I don't regret not using a big, ugly, bash prompt for most
of my Linux time.
I mean, like for a decade or whatever it's been, I've been very, very happy with a simple
dollar sign.
Absolutely.
Did not mind having to type PWD host name, whatever.
If I needed more information, I would get the information.
But right now, for whatever reason, I'm finding the big verbose sort of delineation, actually
pretty useful.
And so I'm using that now.
I can't promise I'm going to always do that.
I might switch back some other time.
And certainly on another system, I might keep a very simplified prompt.
But in fact, actually, I think that's what's really driven me to having a very verbose prompt
is the fact that I'm on so many different systems right now.
Like if it's just me on a laptop and nothing else, then I could, I absolutely could see myself
going back to just a single dollar sign, totally see that.
But right now, because I am interacting with lots of different systems, lots of different
clusters, lots of different little control nodes and nodes and all these different computers,
it really does help to have that sort of constant reminder and constant reference point
really of where am I.
What am I about to do?
Oh, yeah.
I'm on this system right now.
Okay.
Let me tab over and get to a different one, whatever.
So that's it.
That's prompt.
That's starship.
That's bash.
Choose one.
Use it wisely.
Thanks for listening.
Talk to you next time.
You have been listening to Hacker Public Radio, as Hacker Public Radio does work.
Today's show was contributed by a HBR listener like yourself.
If you ever thought of recording podcasts, then click on our contribute link to find
out how easy it really is.
Hosting for HBR has been kindly provided by an onsthost.com, the internet archive and
rsync.net.
On this advice status, today's show is released under Creative Commons, Attribution 4.0 International
License.
