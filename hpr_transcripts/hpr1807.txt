Episode: 1807
Title: HPR1807: Arch Linux Development Environment: Ep1
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1807/hpr1807.mp3
Transcribed: 2025-10-18 09:30:57

---

This is HPR Episode 1887 entitled Arch Linux Development and Myronment,
EP1. It is hosted by CKM and is about 36 minutes long.
The summary is a tour on how to set up a base Arch Linux environment.
This episode of HPR is brought to you by an Honesthost.com.
Get 15% discount on all shared hosting with the offer code HPR15.
That's HPR15.
Better web hosting that's Honest and Fair at An Honesthost.com.
Hello and welcome to the CJM podcast recorded for Hacker Public Radio.
Not to bring a whole bunch of advertisements into the mix, but I'd just like to say if
you'd ever thought about recording a show before or anything, you should definitely
give it a shot because I was just a listener like you that maybe three months ago and then
I just picked up a microphone and I'm loving it now.
So yeah, well, I guess I'd better move on to what I'm actually going to be talking about
today.
I'm going to be talking about sort of in the same vein is what I was talking about before,
but I'm going to take a step back.
I had my intro to C series in which I started just showing you the basics of what C is
and how to do it, but I'm going to actually do a three part series before I get to any
more of the C. I'm going to do a way of setting up your dev environment or the way I would.
Now it will be based on the new Linux and in particular, it'll be based on Arch Linux.
So I'm going to teach how to just go through the whole install process and make it all kind
of in sync with really where we want to be in terms of a development environment overall.
So I'm going to actually split it up into three main categories.
I'm going to split it up into the first episode, getting a base system running, a second
episode getting your tools installed, and then a third episode, I'm going to talk about
an editor war that has raged on for centuries.
I'm going to be talking about the Emacs versus VIM and where I'm kind of lying on the stance
for it.
Okay.
So those are kind of what I'm going for and I hope that the third episode in particular
will kind of fall in line with Dave Morris's VIM Hint series as well.
So it'll be great.
I've kind of written up quite a few notes here.
Just kind of to teach myself more or less than anything else.
But the beginner's guide on the Arch Wiki which I have a link to is just perfect and I also
have a link to downloading the Arch Linux, Arch Linux ISO.
So if you need to get the Arch Linux ISO, feel free to do that.
All right.
So what's the first thing that we do when we start to install a new operating system?
Well, we download the ISO.
So if you just go here and go to my show notes, I've got a link here that says it's the
U of Waterloo Arch Linux mirror download.
You can just grab it and it should be fine.
I don't really know where you're going from, but I just put it up there as it's the closest
for me.
So I also have another thing here, a guide to a DDing your image.
So DD is a tool that comes with most unique systems and then right here, I've got zero
before we get into the guide section zero is preparing your boot image.
So you can use the DD command and I've got this link here that points you right to how
to use the DD command itself.
And then the third and final link I've got here is the Arch Wiki beginners guide.
Now this is really some great documentation that you should start with.
And to be honest, a lot of the things I'm about to say are directly derived from there.
So I'm just going to kind of add some more of my types of things like my insights into
what we're doing and things like that, but but the Arch Linux beginners guide is really
where you need to go.
So I'm just looking here, actually my table of content is a little out of date.
I don't have my preparing the boot image on there, so I'll update that by the time this
gets out.
But yeah, so let's let's begin.
So what's the first thing that we do when we start to start an installation is we get
the ISO.
So if you just open up the show notes, I've got the Arch Linux mirror and download and
grab it.
And once you get it on your system, we're going to have to prepare it onto our actual boot
medium.
Now boot mediums can be CDs, they can be USBs, if you have a really ancient, ancient, ancient
name, it might be a floppy drive, it might be something like that.
But either way, we're going to have to pick some sort of some sort of, how do I say it?
It's installation medium to kind of put the ISO on.
All right, so let's see.
The basic syntax for doing it is using the DD command, as I said, now best practices state
you should probably put a dollar sign or a hashtag in front just to make sure you can
get the DD command all right, well and good.
But even if you go to the guide to DD and your image in the show notes, then you can
just copy it.
And I've also got the code there too.
So all you have to do is DD and then your input file is if equals and then your path
to your Arch ISO, your output file is going to equal your slash dev slash sd a or b or c
or wherever you're driving.
Now X, like I said here, I have sd x but x is really where your USB is and to find it
one good way to do it is you can either do an lsplk command or you can do a D message
piped into a tail.
So that will just grab the end of the tail.
So this just brings down the, I'm sorry, the show notes here, I'm just kind of following
those.
So I hope I'm kind of giving a thorough enough explanation.
But the DD command copies drives bite by bite.
So by copying ISOs, which are basically like CD file systems, we can put it directly
on the usb and make it bootable.
So that's what we're doing.
And I'm kind of going with the usb here for my, for my media.
So like I said, just the input file, the output file and then BS here is bytes per second.
So I put four megabytes and then just to make sure all of our buffers are synced, we
do a double ampersand, which in bash means and logical and it also it's kind of do this
command and do that command, right?
So we have this sync command here at the end, which basically just says the file system
once be all, we have all our blocks lined up and whatnot and make sure we're all good
that way.
So I have an explanation of what each of these things do here in bold on the show notes.
All right.
So the first actual step after we've prepared our boot images, the boot.
So once, once you boot, you plug it into your computer, you might have to fiddle around
with the BIOS and choose the boot order, usually that's done by pressing F2 or F8 and then
you can choose a boot menu and go through there.
And I mean, some people probably won't have trouble with that because we most of us have
installed the Linux distro here at some point, but I might as well go over it.
So just go into your BIOS and go into the boot menu and make sure everything's good
like that.
Okay.
So once you get booted in, you're going to be greeted by a prompt.
And this is all our clinics is.
This is the live CD of our clinics.
It's just a basic prompt with some utilities, some show utilities to get you started.
And I think one good place to start is checking the network.
So I just have a note here, if your connection is wired, then the DHCPD client will automatically
a boot, find everything it needs to have and then it'll actually bring up your interface
and you'll be connected hopefully.
If you're on a laptop or something of that nature, which a lot of people might be, Arch Linux
is actually, I think it's one of the only.
If I could be mistaken if I am, but it has a Wi-Fi menu, which is a nice end curses interface
in the terminal to find a good network, use the NetCT back end to be able to find everything.
On enterprise WPA networks, you might want to use a different network manager, such
as network manager or something like that, but for most, for most, it should be fine.
Just to make sure we're all up and running, you can use the ping command, and just too
it's a URL and you should be fine, and if it starts setting packets back, then we all
know we're good.
Yeah, so once you get the network up and running using the sudo Wi-Fi menu or the ethernet
cord, if that's what you're running on, then we can move on to the next part, which is
the partitioning of the actual system, partitioning, and most other distros is actually done
by itself.
Just an overview, every operating system starts with a specific way of how to lay out memory.
So it doesn't know how to lay out its own memory, we have to tell it.
So basically, what we do is we create a partition table to be able to say, well, we want this
data here and this much data going here.
I can read more about the partitioning tables and the file system hierarchy here in the
show notes.
I've kind of given an overview in terms of some links you can go and check out.
But the basic summary is that everything starts from the root directory.
A basic layout for a system in terms of our partition table would be, it's best to separate
your boot.
So where the kernel gets stored, where your init RAMFS gets stored, all of those types
of things, it's best to get that stored in its own separate partition.
So my basic layout is to have a boot partition, which is about 200 megabytes.
Now then you've got your root partition, which is usually around 20 gigabytes, that's
kind of good because you don't need enough storage there, but you don't need too much.
Just because the root will hold everything else, but in terms of the root actually filling
up, it doesn't fill up.
So a lot of the things and a lot of the partitions we're creating, although they're stored, they're
mounted on root as it's called, they're actually completely separate file systems, and that's
why we're partitioning them.
So you don't have to worry, oh, my root's 20 gigabytes and my home is 100, because home
is actually a completely different partition than the root.
So we have our boot, which is 200 megs, we have our root, which is 20 gigabytes, and
then another one you have, especially if you're going to be doing a lot of system administration,
you're going to have a var partition.
Now that's going to be about 12 gigabytes.
Now that just will hold if you have any log files, if you have any mail that you're getting
in the var directory, log files, and everything that goes wrong there.
So anything that goes wrong will write to the var partition.
And that's pretty common practice.
And I like to separate my var, and then the last partition we have is our home partition,
and our home partition will be the rest of your disk space.
So if I had 100 gigabytes, then if I did the math, it's 68 gigabytes, so the home partition
would be 68 gigabytes in size, because that's, we want all of our user files and everything
we're going to store our images, only files that the user storage will go in their home
directory.
Other than their home partition, excuse me.
So you have your boot, you have your root, you have your var, and you have your home,
so I'm just going to go through it again.
You have your boot with just 200 mags, you have your root, which is 20 gigabytes, your
var, which is 12 gigabytes, and then your home is usually the rest of the disk space layout
is kind of taken back from the arch wiki itself, so that's still on the partitioning table.
And if you dig around a little bit, then you can find the basic layout, but this layout,
I've probably used for five installs to ten installs, and it's actually, it's really
worked for me, and I've had no problem, so that's what I'll be going with.
And it's not set in stone either, so feel free to mess around if you want your boot partition
to be 300 mags, your root to be 50, and your var to be 20.
If you have the space, you go for it, because there's no hard and set rules.
I mean, I was thinking, sure, you've got to add liquid space for everything, so now we
had to do something that actually writes this partitioning, this partitioning data, and
kind of makes the layout that we want.
So now that we have the basic layout, kind of laid out on paper, we need to put it in
memory.
So for that, we're going to be using the F disk utility, so that's F, DISK, to start the
one thing we're going to have to use in a command that we'll have to get familiar with,
L-S-B-L-K, which just lists the devices that are in your system, so it lists your different
hard drives, it would list USB drives, it would list things like that, and it would list
them in a nice, formatted fashion.
So let's say our device, our hard drive that we will be partitioning is slash D, dev slash
SDA.
Well, then we're going to choose that dev SDA with F disk.
What once you put the dev, or once you type in F disk slash dev slash SDA or SDB, wherever
you're located, then you will be taken to a prompt.
There should be no partition table located on the drive, if there are, then you can hit
D, and that will delete a partition one at a time, so just delete, delete, delete, delete.
Make sure you back up your data, obviously, before doing this, because that will wreck
your data.
Once your partition table is completely deleted, and we're starting fresh, we're going to
be using the N key to hit a new partition, so it will ask you for its type, and you can
leave it as default, and then once again, it will ask you for the first sector.
Now, the way it works is you have to define the first sector in the last sector, but the
last sector actually shows how much space you want.
So for boot, you would say, for boot, you would say, our first sector would be default,
because we're starting at the beginning of the disk, and then our last sector would be
plus 200 megabytes, because that's where we want it to end.
So that's what you do.
You get to the, when it says, specify the last sector you type in plus 200 MB with a capital.
So it's in the show notes as well.
So you just do that, and then again, that'll create the partition.
Now you have to hit N, and this will start where boot left off, and you have to 20 gigabytes
for the last sector, because you want it to take up 20 gigs.
And then for the var, you have a plus 12 gigabytes, and then for home, you can just leave
the first sector and the last sector the same.
What important thing to do is once you've got the partition table, which you can view with
the P command that will print the partition table, you could do is just hit the W key to
write the changes.
So that will delete all the data on your disk, so make sure that you've got everything
up to date and going, all right.
All right.
So now if you do an LSBLK, you should see whatever your drive is, so if it's SDA, SDP, you
should see the different partitions underneath that, so you should see SDA1, SDA2, SDA3, SDA4.
So SDA1 should be your boot if you follow what I was doing, SDA2 should be 20 gigabytes
and your root, SDA3 should be var with 12 gigabytes, and then your dev SDA4 should take
up the rest of your space.
All right.
So now that we've got our partition table written, so make sure you hit the W key on that
and once you get it, once you get it written, then the next thing we actually have to do is
tell the operating system what file systems we want to create out of the partitions.
So we're going to be using EXT4 for all of these partitions, so you just do MKFS for
MKFS.ext4, and then slash dev slash SDA1 for boot, SDA2 for root, SDA3 for var, and SDA4
for home.
So that's just a MKFS.ext4, and that just tells the operating system what file system
we want to use for each partition.
All right, so on to the next thing.
The next thing we have to do is actually mount the partitions within our file system.
So like I've said before, we're actually going to start off of the root partition.
So now that the file systems are made, and the OS knows what kind of file system structure,
we actually have to say, hey, this space is readable and writable and all that.
So it's really important to do this, and that's achieved actually using the mount command.
So if you do mount dash v, and then slash dev slash SDA1, or SDA2, sorry, because that
would be, that would be the 20 gigabyte.
So if you have SDA2, which should be the 20 gigabyte, if you follow what I was doing,
if it's not, well, that's okay, you can just go back and kind of redo those steps,
but that that's the root partition.
So once again, you can use LSBLK to make sure we got the right root partition, and we
mount it onto the mount directory, which is slash mount command to run for that is mount
dash v, and that's just for verbose output slash dev slash SDA2, and then space slash mount.
So that just mounts whatever partition or device onto the specific directory you specify.
So as simple as that, we've now got a root directory to make everything else.
So if you've got other partitions, which we do, if you follow the partition structure,
I've been following, the main thing is we need to do the same things.
We should probably have folders for each one.
So now that the root partition is mounted, you can be able to do make directory slash mount
slash boot, make directory slash mount slash bar, and then make directory slash mount slash
home.
Now I've also got a shortcut located here in the show notes, make directory dash p slash
mount, and then slash, and then I have an opening curly brace boot comma bar comma home
ending code, ending brace, because that actually is brace expansion, if you just do a Google
search for brace expansion bash, you can actually find some really interesting things.
But for right now, just use three different separate commands, make directory, and make
sure it's through the slash mount slash whatever you're mounting, it's really important.
So just to recap, we have, if you do an LSBLK, you want to put your 200 megabyte to mount
boot, your 12 gigabytes to mount bar, and your root should be on slash mount, and then
the last partition to slash mount slash home.
So once again, check with LSBLK, make sure everything's set up, and I've got it all in
the show notes, if you want, but also the arch, excuse me, the arch wiki is really important,
you can go there.
Yeah, so once we're ready to go to the next logical step, is to install the base system,
and the base system is basically just the way a foundation for our system to build on,
you can specify any packages here that you actually want to install, but one important
thing to note is that we don't actually have the package manager installed, that's installed
in base.
But the arch Linux folks have been kind enough to provide us with a simple wrapper script
that will reach out to the repositories.
So another thing you can do is you go to your Etsy mirror list under the pack and folder,
and just check for the newest closest mirror you've got there, and it'll help.
But anyway, that's another story, it's all through the arch wiki if you want to look
into that.
But the pack strap command is the one you want, so the pack strap command is pack strap,
and then you have to give it wherever you want it to go, in this case you want it to
go on mount, so that's going to be specified with the dash i flag.
So pack strap dash i mount slash mount, and then the name's here, the packages you want
to install in this case, we're going to install base and base develop.
So just wait for that to finish, it'll take some time, and there you go, now you have a
basic system installed in the mount, and that's really where we need to go once that's
finished.
The next thing that we have to do before we start actually configuring our system is
to generate an f-stab, now once again an f-stab file is basically, it tells the operating
system how everything is mounted, and what, sorry, it tells the operating system what is
mounted and how to mount each system when it actually starts up the PC, so you don't have
to go through a mount, all your var and your boot and your home all the time, right?
So generating the f-stab is really important, and arch Linux has actually provided a really
nice script for that as well.
So genf, genfstab, g-e-n-f-s-t-a-b dash capital U dash p slash mount, and then the append
operator, which is two opening greater brackets, and then slash mount slash NC slash f-stab.
Now what is the dash capital U do?
It says use UUID for source identifiers, it's just a little bit easier to see everything,
and then the dash p says avoid printing pseudo file system mounts, so that's a fancy way
of saying that it doesn't want to mount it twice and then print it, and it's just more
of a precautionary measure.
And once you generate the f-stab, it's always good to look at it, so if you just use the
cat command, and go cat slash mount slash NC slash f-stab, and make sure all your partitions
line up, so your boots on boot, your roots on root, your bar is on bar, and your home
is on home, and once you get all that done, you should be good to go.
So once again, we just have to generate an f-stab, that's really important.
Okay, so you might be thinking to yourself, we've got this mount directory.
And I've installed a little of these things to it, using my packstrap command, and I've
generated an f-stab, but it's not actually my system yet.
I'm still in the live CD, and you'd be correct, you still are in the live CD.
You're still in the environment that the Arch Linux live CD gave you, you're not actually
into your system yet, and that's kind of something kind of hard to wrap your head around,
but at least it was for me at start, but the main thing is that we know that all of those
utilities are installed onto the mount partition, which is where we're starting, because they're
root in Unix is where everything branches off.
So the main thing we have to do now is kind of change that root, so we have to change where
our tree branches off from, and we have to make sure that we actually want to go into
the slash mount directory, because that's where our system's mounted, if you remember,
that's where we put our root partition on, our root partition, you know, and it's really
important to get within that, so our root directory is that slash mount.
To do that, there's actually a really nice tool called Arch-Changer root, while it's actually
chur root, so C-H-R root, so it stains for Arch-Changer root, and it takes the directory you
want to change, and the shell that you want to use, so you can use Arch-Ch-R root, Arch-Ch
root, and then space the directory you're giving it, in this case, mount slash mount slash
MNT, and then space slash bin slash bash.
And the bin bash just tells it what shell we want to use within the mount directory.
If you want to use another shell, feel free, you can use it here.
I think they've got the SH shell, and they might have the SH shell, yeah, so here we go,
and just another thing, I would highly recommend that you are reading the documentation along
with this podcast, so if you're not, if you're on your way to work, then that's a different
story, but it just helps, because I'm kind of going off of this, no, that's just another
reminder, but now that we're actually in our system, so once you've changed rooted, your
shell prompt must change, and it'll say, now you're within the system, and that really
means that we don't have the utilities that we had before, so we no longer have GenF
stab, we no longer have Wi-Fi menu, and those are the things that we're going to need,
so just don't think that we're in the same system, because we, although we are, we don't
have access to the same live environment tools that we did before, so there's a few things
we've got to do, once we've changed rooted, we've got to set the locale, now this is really
important, the list of locals is located in slash NC slash locale that dot Gen, so that's
locale dot GEN, and you have to uncomment the one you want to use, in my case, that's
EN underscore capital C A dot UTF-8, now this could be very confusing, but if you just
do a nano slash Etsy slash, so that's nano, then space slash Etsy slash locale dot Gen,
and then look for it wherever, whatever your locale is, so if you're in the States, it's
EN underscore US dot UTF-8, if there's other places there, so you use nano, and you go there,
and then once a line that you want is uncommented, we have to run another script that's included
in BASE, which is locale-GEN, now it'll generate your locale settings for you, now another
thing is we have to populate our slash Etsy slash locale dot com, and this is done really
easily by using UNIX's wonderful redirection operator, so we can go echo-lang in capitals
because it's an environment variable, equals lowercase EN underscore capital C A dot UTF-8 in
my case, or whatever your locale is, so once again that's Lang in capitals equals whatever
your locale is, with a greater than sign to redirect the output into slash Etsy slash locale dot
com, and then I'll put it right into the locale dot com, and you should be done, finally we
have to export our environment variable for the Lang, so you have to go export Lang equals
EN underscore CA dot UTF-8, in my case once again, or whatever your going to do, so that's
export Lang in capitals equals EN underscore CA dot UTF-8 for me, or whatever Lang you chose
for yourself, how the next thing we have to modify is the time zones, now the time zones
are actually stored in slash user slash share slash zone info, and I don't know exactly what
you're doing there, but you're going to have to find your own time zone info folder, and
then what we do is we actually make a link from that time zone to slash Etsy slash locale
time, and then that'll set the time for you, so in my case it slash user slash share slash
zone info slash Canada with a capital slash Eastern, and what I do is LN-S, and then I put
in that path of Canada Eastern, and then I put in the path of Etsy local time, and that
should be that, and you can do a cat of Etsy local time to see what's going on there,
but it should be all set up, and then finally we have to set our hardware clock, so to set
the hardware clock we use the command hw clock, space dash dash sys talk, which is syshtohc
space dash dash uttc, and then that'll set the clock to the appropriate time according to your
time zone, a few other modifications we have to make, we have to put our host name in, so you can
name your computer whatever you want, in my case only with arch, I do an echo arch, and then
use the redirection operator, which is the greater than the sign, and put it into slash Etsy slash
host name, and then there you go, and you can do a cat on slash Etsy slash host name, and you can
modify once again, once you make the host name, you have to modify your slash Etsy slash hosts,
and put the host name that you want with on your 127.0.0.1 line under hosts, and we should be good
to go, and you can use nano for that as well, to modify slash Etsy slash hosts,
okay finally we want to be able to connect to the network and your reboot our systems, so
for anything it's really nice to have that Wi-Fi menu tool, you can do pack me in dash
capital S, and then space IW, space WA, underscore supplicant, space dialog, and then that will
install all the tools that you need for the Wi-Fi menu utility, and then once you install those,
you need to set the root password by using past WD, that will, that will set your root password,
and just make sure it's secure and robust, and you should be good to go for that, and then find
and then finally you have to install a bootloader, so you have to install a bootloader,
and for this I will be using i386 basic bootloader, but if you have a UEFI
boot system, then you can search that on our Twiggy, and I'm also going to be using grub, but
feel free to use whatever you want, so to install grub we do a pack man space dash capital S, grub,
and then OS probe, if you have a different probe in there, and then we also have to know where our
root partition is, so once again that for me that's SDA2, once grub is installed you can do a grub
dash install, and then space dash dash target equals i386 dash pc, and then space dash dash
recheck, and then slash dev slash whatever we were using, now it's important that you don't put
any numbers on the end of that, you just put the SDA SDB SDC, okay, and then finally once you do
that you have to make a grub configuration, and that will be done by using grub dash mk config
command, so that's grub dash mk config space dash o, and then slash boot slash grub slash grub dot
cfg, and there you have it ladies and gentlemen, you have just installed basic archlinic system,
this is bare bones, you can't really do much with it yet, but i'll be coming back with another
episode, all you have to do know is exit and reboot, so i appreciate your time, and i hope this was
informative, you have a great day, all right, i'll talk to you soon, it was a pleasure, and once again
if you ever have anything to talk about please submit it to hbr, all right, we'll talk to you soon, bye
you've been listening to hecka public radio at hecka public radio dot org,
we are a community podcast network that releases shows every weekday, Monday through Friday,
today's show, like all our shows, was contributed by an hbr listener like yourself,
if you ever thought of recording a podcast, then click on our contribute link to find out
how easy it really is, hecka public radio was founded by the digital dog pound and the infonomicon
computer club, and it's part of the binary revolution at binrev.com, if you have comments on
today's show, please email the host directly, leave a comment on the website or record a follow-up
episode yourself, unless otherwise status, today's show is released on the create of comments,
attribution, share a like, 3.0 license.
