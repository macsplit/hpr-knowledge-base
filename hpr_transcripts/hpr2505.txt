Episode: 2505
Title: HPR2505: The power of GNU Readline - part 3
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr2505/hpr2505.mp3
Transcribed: 2025-10-19 04:21:50

---

This in HPR episode 2,505 and titled, The Power of the Annuary Line Part 3.
It is hosted by Dave Morris and in about 27 minutes long, and Karina next visit flag.
The summary is more useful key combinations.
This episode of HPR is brought to you by archive.org.
Support universal access to all knowledge, by heading over to archive.org, forward slash donate.
Support universal access to all knowledge, by heading over to archive.org, forward slash donate.
Hello everybody, this is Dave Morris doing another show in the series by Gunu A Readline.
This is number 3.
I thought I could need to about one when I started this and realized it would develop so far.
But there's a lot here and it's more accessible than it seems or it seemed to me anyway.
So I'm going to carry on for another maybe a couple of shows to cover some of the really interesting and useful features.
So today, trying to keep the number of read line features down to a minimum.
So it's not indigestible, as I've said before.
But I wanted to do a couple of preambles before I start.
The first off is to talk about some of the terminology.
The reason I'm doing this is because I'm pointing you at the Gunu Readline manual in many cases.
And their terminology is unique to them.
As you often find with these things, we've already looked at kill and yank for as names for cut and paste.
But the thing is, if you go and read these manuals, you'll maybe, if you're anything like me,
it'll be puzzled by these weird terms unless you've had a pointer to the way to decode them.
So the three terms I wanted to address today, which I'm not really going to be using very much today,
are point, mark and region.
The point is the Gunu Readline term for the current cursor position.
I normally call it the cursor position.
It's also called the insertion point at times.
But point is sort of shorthand that's used in the documentation.
Mark is a thing we're not looking at today, but we'll do at some point,
some time, I should say.
It's a cursor position which has been saved by a command called setmark.
Now I've not personally used this, but I will have done by the time I talk about it.
But it's something you might encounter.
The third term region is the text between the point and the mark.
So you can see there's some potentially useful things coming up that will use these features.
So what I'll try and do is refer to these terms with my decode of what they actually mean whenever I come across them.
But that's going to be maybe the next episode of the one after that.
Second point I'm going to raise was that Readline takes arguments.
When you type the various key sequences that we've looked at so far,
what's actually happening is these key patterns like control and a letter or meta.
That's the alt key, remember, and a letter or whatever.
Then what you're actually doing is you are invoking a binding.
These key sequences have been bound to underlying commands.
I'm planning to look at this in a couple of episodes time.
I'll probably alluded to it along the way.
But the business of underlying commands is something that you'll find if you go reading the manual.
Anyway, these commands can often take numeric arguments.
Sometimes the argument acts as a repeat count.
Another time it's the sign of the argument that's important.
So to provide an argument, you hold down the meta key and then while it's held, press a digit.
If you want a multi-digit number, you then release the meta key and the digit, of course,
and just hit another digit.
The first, quote, digit can actually be a minus sign, a hyphen.
If the argument is to be negative.
So, for example, control D that we saw last episode or the one before.
I don't remember, but we've seen it.
Control D, which is delete forward, one character.
If you want to do that ten times, you can type meta one.
So that's hold the meta key down, press one.
Release the press zero and then do control D.
Try to type this out in two different forms to make it clearer.
But that will delete forward ten characters.
A negative argument reverses the effect of the command, so meta minus.
So that's the meta key held down with the dash or the minus or hyphen key.
And then control K, which normally deletes forward characters to the end.
It deletes the end of the line, control K.
So instead of deleting characters forward to the end of the line, it deletes backward to the start of the line.
So it deletes everything from where you are to the end of the line, normally control K.
But if you put a meta hyphen or a minus in front of it, then it reverses its effect and it goes backwards to the start of the line.
Having learned this, I sort of vaguely knew about this before, but never used it.
And then coming to talk about it here, as is often the case, I had to really understand what I was talking about.
You may not believe I do, but I do.
And so I rehearsed this and been using it.
And I actually found it quite useful.
There's some quite cool things you can do with it.
And once you've got your head around what's going on, it's not too hard to remember.
Even for me, I can remember it, so I'm sure you can.
Final point before I get into some key sequences is to remind you that some of the sequences that we look at in this series, we are going to look at, particularly, can be intercepted and then interpreted by possibly the terminal emulator that you're using or the desktop environment that you're used.
So, for example, when I was testing stuff recently, I found I was using the Terminator Terminal Emulator and I'm on XFCE.
And I found that Meta-L, which we'll look at briefly later, was interpreted by Terminator, and so you couldn't actually get it to Readline.
But I wanted to remind you that all Meta-key sequences can, in fact, be entered as Escape Key, followed by the second key.
So, you don't hold the Escape Key down, you hit the Escape Key, and then you press the second element.
So, Meta-L could be typed alternatively as Escape, and then Lockcase-L, and that works.
So, I suppose it does get a little more complicated.
I guess I would tend to ignore certain terminal emulators.
I was trying to stuff out with X-Term, boy does that get difficult, because X-Term is so basic in its functionality.
It doesn't necessarily recognize the Meta-key, I think it wasn't, I was having problems.
You have to go and reconfigure it to make it work. So, be aware.
Okay, let's get into some Readline key sequences.
So, first thing is, you can comment out a line.
Now, this is something I often do, I do quite a lot of bash command line stuff, and I sometimes am typing a complex command with lots of arguments.
Lots of options, etc., etc., and possibly a pipe line, and it's getting complicated.
And I'm thinking, am I doing this right? How do I check?
And there's the half written command. I don't want to delete it and then type something else.
Or maybe the phone goes to something, and I want to make sure I don't accidentally hit the return key while I'm on the phone or something of that.
So, what I used to do was I would hit the Home key while I was doing the typing, which moved the cursor at the beginning of the line,
and then, or I'd use Control-A, that's the alternative.
Then I'd stick a hash mark on the front of the line.
Now, I hit Return, mostly, and that would store away that particular line, so it could be recalled with the Barrow.
It's in the history, and you could then take the comment off and finish typing it and invoke it.
Particularly, you'd want to do the hitting of Return and storing it away if you wanted to use the same terminal to type something else.
So, you could have two terminals and hop between them, but you know what I mean.
Sometimes it's convenient to do it this way.
Well, there are read line sequences that'll help you with this.
If you hit MetaHash as you're typing a line, it adds a comment symbol to the start line and issues a return.
So, it actually stores away the partially completed line and with the comment, but doesn't execute it.
So, if you then recall that line and you want to take the comment off when you do that, you can do that.
But in order to do it, you have to give the MetaHash an argument.
So, you'd have to type Meta1 MetaHash, and then it would remove that comment symbol and issue a return and the command would be executed.
It could be any argument, it could be Meta0, it could be MetaHyphen, it could be anything that's permitted as an argument, which is any number or that hyphen, which is a sort of pseudo digit.
The interesting thing about the argument one is that it's a sort of a toggle.
If you're on a line which has no comment on the start of it and you do Meta0 MetaHash, then it will add one.
If you're on a line which begins with the comment, you do Meta0 MetaHash, then it will take it off, so it toggles it on and off.
But there's more to type, I don't know, prefer not to do that.
It's a good thing to know.
There is a way you can change the comment character.
Mostly this is used in Bash, but remember that Readline is used in other things like MySQL is the one I normally cite.
And a hash is a comment symbol in MySQL, so you can use it to park a command that you're typing query and come back to it later if you wish.
But it's not the case in Postgres, for example.
So there are ways in which you can change to the comment character of the particular environment you're working in.
But we'll come on to that later, and it's not automated.
You'd have to set that up yourself, I think.
At least it's not automated on my system, I mean.
So I'm trying, I thought I would add a little example per key sequence this time rather than collect them all up at the end.
So my example was type the Bash command, echo, space, double quotes, hello, close, double quotes, but don't press return.
Type, meta hash, and it turns into hash, echo, hello.
And the lines accept as this return have been pressed, you don't need to press returns tool.
Then you can recall the line of the other arrow key, then type, meta, one, meta hash.
The comment character is moving, the lines accept it, and you get the wonderful message, hello.
And it's, I think it's a good one.
So I'm, I've sort of, my sequence for doing these is, I'm trying to think of things that fairly easy to use and hopefully useful before I get into the really esoteric stuff by which time you might have turned off, gone away.
Next one then, transposition of characters.
So I'm a bad typist, and I so often type words like direct Troy instead of directory.
So I transpose the, the O and the R, and I do, oh, it's so frustrating, especially when it's nearly finished typing the line and you look back and see those transposition.
But I guess most people do that.
It is frustrating.
Readline offers a facility to correct stuff like, and it consists of the sequence control T, control T transpose characters.
So it swaps the character before the cursor, I put in brackets point to remind you that it's also called a point, with the one under the cursor.
And then it moves the cursor to the right.
When I discovered this, which a few years ago now, it seemed a little bit counterintuitive.
So I've got an example here.
Imagine you've typed the word directory wrongly, so it says direct Troy.
You position the cursor's cursor on the O, so T-R-O-Y is at the end, and you've positioned the cursor on the O.
Press control T and the O and the R are transposed, and the cursor moves to the Y.
I've tried to diagram this in the notes.
Just because I know some people prefer, it's a thing that's better to see if you can.
If the insertion point is at the end of the line, that is the cursor's at the end of the line, then the two characters of the line are transposed repeatedly.
So I've shown if the cursor's after the last letter of my misspelled directory, direct Troyer, it's even worse spelling this time.
And type control T, then it flips the Y in the R at the end to the correct order, R-Y.
And if you do control T again, because the cursor hasn't moved, there's nowhere to go anyway, it flips it back the wrong way.
I don't know how useful that is. I don't personally find that useful, but lack of imagination on my part, perhaps.
But still, it's useful to know, because if you inadvertently hit control T twice, then you would not be surprised to see it flip back again.
You can also transpose words. I was surprised to find that when I did discover it.
So it's pretty simple, it's metathe. So control T for letters, metathe for words. It's often the rule in readline.
The control for character oriented stuff and metaphor word oriented stuff.
So word is, as we've discussed before, a series of letters and digits.
The cursor, brackets point, to remind you, can be anywhere in a word, or just before it.
And it and the word before it are swapped. Again, it's slightly, I find that swapping backwards, like this is a little bit odd, but there you go, that's the way it's designed.
And once you know it, you can use it.
The word you're on, or just in front of, and the word before it are swapped, and the cursor's left after the pair of words.
If there's no word before the word, the cursor is on, and as you're on the first word of a sequence of words, then nothing happens.
If the cursor is at the end of the line, the last word in the word before it are swapped.
And it's done repeatedly, just like control DT did with the last two letters of a word.
The last two words of a sentence will be processed in that.
So my example is imagining that you've typed echo to boldly go where dot dot dot.
And you think, oh, I hate split infinitives, so you position your cursor on the O of go.
You press meta T, and it's transformed into echo to go boldly where.
That's worse actually, but Harry, it's probably better grammatically.
The cursor is left after the word boldly, the space after the word boldly.
So that's interesting.
Transposition occurs even if the cursor's not on a word.
And so once you've done the first transposition I just talked about, you hit meta T again, it would swap, you've got the words boldly and where.
And it will swap them so that it says to go where boldly.
The cursor's left on the first dot after the word boldly.
It's important to know what where it's left because that affects you in the next action.
So I think those two are pretty cool, I like them very much.
What do you do too?
Next, we've got three sequences which affect the case of words.
So you can change the case of a whole word, two uppercase, two lower case, or you can change the case of the first letter of the word.
Or that's not strictly true, but we'll go with that for the moment.
So in other words, it capitalises it.
Remember that because we'll come to that.
So meta U is the uppercase, uppercase the current or following word.
So it's the same as before. If you're in the word or you're pointing to the start of the word, then it will uppercase that word.
If you're pointing just in front of the word, it will do the same.
If you use a negative argument with this one, this one can take an argument.
Then it uppercase is the previous word, but interestingly he doesn't move the cursor.
Not quite clear why it does that, but it does.
So meta U for uppercase.
Meta L, lower case L, lower case U, I should have said.
It will lower case, didn't know that was it.
A verb actually.
It will lower case the current or following word, just like before.
And with a negative argument, it'll do the word prior to the current one.
And it will not move the cursor.
I've used the terminology here more or less as it is in the GNU readline manual.
Tended to do that to a moderate degree, but add a bit more of my own just to make it clear.
Because it's not always that clear.
This one seems fairly clear to me.
So we've got meta, lower case U, meta, lower case L.
And then we've got meta, lower case C.
And this capitalizes the current or following word.
With the negative argument, it capitalizes the previous word.
And it doesn't move the cursor.
So these three are very similar in their behavior.
Now, it doesn't say this in the manual, but I discovered this by experimentation.
That if you want to change the case of a whole word or capitalize it,
your cursor must be before the word or on its first letter.
If it's partway through the word, then the rest of the word from the cursor to the end of the word is changed.
And this is similar for capitalization, the capital, if the capital is at the start of the following word.
Or it occurs where the cursor is positioned.
And the other thing to note is that the rest of the word is lower case.
So if you've got a mixed case word and you do a meta C on it,
it's going to change the letter you're pointing to or the one at the beginning of the word,
depending on whether you're between the words.
It's going to uppercase that and it's going to drop the case of the rest of the word.
Again, I was a little bit surprised that that happened, but I guess it makes sense.
So I guess capitalize means raise the relevant letter to uppercase
and the rest of the letters from where they are to be to lower case.
So I've tried to do some examples here showing how this would work.
And it's got one example for uppercase and it's a sort of a recipe.
And you do various things that I suggest and you get the various effects,
just to demonstrate the sort of thing you want to do.
So imagine you have typed the command that you haven't pressed to turn yet.
The command is echo space, double quotes, hacker public radio,
with spaces in between, all in lower case, close quote.
You move your cursor to the H of hacker and you do that by pressing meta B3 times.
It's going to move three words backward, which is cool.
I'm so glad I've learned to do this.
It's a good way of jumping around the line.
Then if you press meta U, what you get is, and it's shown in the notes here,
the word hacker is converted to all uppercase.
The cursor is positioned at the space after the word.
So that word has now been changed to uppercase.
If you now hit meta U again, it's not too surprising,
even though it's not on a word, it's before a word,
and the word it's before is public, and it uppercases that,
and moves the cursor to the space after it.
Now if you did meta hyphen, meta L at that point,
you just moved your cursor after the word public,
then that's a negative argument to the meta L command,
and it lower cases the word public again.
So it's changed the previous word,
because remember the negative arguments make it go backwards,
but the cursor hasn't been moved. It's still in the same place it was.
The thing I didn't try, and I should have done,
is the effect of a positive argument on these things.
I assume it will, is the same as typing meta U or meta L multiple times.
So the whole sequence of words gets changed in case.
Yeah, I should have checked that, but I'll leave that as an exercise.
Now, I added a bit here, which shows going back to the hacker public radio,
all in lower case.
The cursor in this case is positioned under the K of on the K of hacker.
Now if you press meta U here, then the letters KER are uppercase,
and the rest are left alone.
So it's processing the word from the cursor position.
I had expected it to do the whole word by backtracking or something,
but that's not how it works.
Like I said, that's not documented in the manual.
Okay, capitalization then, example of that,
and I've put the echo, an echo command, which is in quotes,
the capital of Scotland is Edinburgh.
I don't know what made anything of that.
And it's all in lower case, and the cursor is positioned after the closing quote,
because I've just typed it.
So if you press meta B six times, then meta C, then meta F twice,
and meta C again, then you get the is,
it's got a capital T, capital of is all lower case.
Scotland's got a capital S, and the cursor is positioned after the word Scotland.
So I sort of, I was sort of leaving you to work out what I did there.
Basically using meta F is going forward a word.
So if you then press meta F and meta C, then it skips forward a word to the word Edinburgh,
and it uppercases first letter.
I did say it should be self-evident and previous episodes in the series.
I tried to smiley face, but it's so tiny you can hardly see it.
So hopefully that stuff will prove to be useful.
Now I added one more sequence here, which at the time seemed like a good idea,
I'm not sure it was, which is how you revert the line to its previous condition.
Now we saw the undo command in episode one, and that is control underscore,
or you can use control X, control U, and each one of the undo commands reverts one change.
There is a sequence that will revert everything on the line,
and I've just chopped out the text and put it in these notes.
So it's meta R, and it will undo all the changes made to this line.
It's like executing the undo command enough times to get back to the beginning.
Now I'm going straight into an example to try and explain this.
I don't use this sequence myself very often.
It looked good, but I could never get it to do anything particularly useful I thought.
I was experimenting it for this episode, and I didn't find it all that useful, as I said in the notes.
So let's look at what the undo command will do in normal use.
It reverts in individual steps.
So imagine you've typed the command echo space, double quote, star wars in mixed case, close quote.
The curse is positioned at the end of the line after the closing quote.
So if you move back to the R in star and press control T, then you get star wars.
You move forward to the capital W in wars and press control T,
and you get straw R's.
Now press control underscore to perform one undo, and you go back to star wars.
Press it again, and you get star wars.
We're back to the original state, except that the curse is in a different place.
If you press control underscore again, then it reverts to the absolute beginning,
which was nothing at all on the line.
So if you had the same starting point, I don't know why you're doing this to star wars, but there you go.
You're learning what control he does, and it's fun.
So if you did all that, and then instead of doing the undoes, you press matter R,
then it just deletes everything.
You end up with a blank line.
So you might think, well, what's the use of that?
Because control U, which we looked at in episode two, is the kill the entire line command,
and it's used the same thing.
However, if you recall a line, I want to do some more stuff to it.
So say you typed the star wars echo thing, and you press return,
and you've got wonderful message to star wars, then you recall that command,
and you wanted to do something like star wars is rubbish.
No, you wouldn't do that.
But if you wanted to make further changes to it, then the individual changes you've made to it
can be reverted with control underscore as before, or can be, all of them can be reverted with matter R.
But you can only go as far back with the undo and the matter R as the point where you recall the line.
None of neither of those commands will get you back beyond the echo star wars that you recall.
So that's really where it's useful, I guess.
But I can't see myself using it very often.
But you might think differently.
Okay, so in the notes I've made reference to the new Readline manual,
and the Wikipedia article I'm going to read line, which contains a condensed version of some of the stuff we've covered.
But we're going to go deeper.
And there were two previous shows which were also referenced.
So that's it.
That I hope was not too long and tedious.
I hope you get some use out of those cool commands.
Alright, see you next time.
Bye!
You've been listening to Heka Public Radio at HekaPublicRadio.org.
We are a community podcast network that releases shows every weekday, Monday through Friday.
Today's show, like all our shows, was contributed by an HPR listener like yourself.
If you ever thought of recording a podcast, then click on our contribute link to find out how easy it really is.
Heka Public Radio was founded by the digital dog pound and the Infonomicon Computer Club,
and is part of the binary revolution at binrev.com.
If you have comments on today's show, please email the host directly,
leave a comment on the website or record a follow-up episode yourself.
Unless otherwise stated, today's show is released on the creative comments,
distribution, share a light, 3.0 license.
