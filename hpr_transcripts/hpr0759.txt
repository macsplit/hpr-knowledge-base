Episode: 759
Title: HPR0759: LPI study group
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0759/hpr0759.mp3
Transcribed: 2025-10-08 02:00:28

---

And...
This is the first installment of the LPI study group.
This session was recorded June 8th, 2011.
If you're interested in following along, the reading assignments are posted on the Linux
Basics Forum, the URL is www.LinuxBasics.com, that's Linux Basics, l-i-n-u-x-b-a-s-i-x.com.
The sessions will run from June 8th to August 31st.
All are welcome to attend and to participate.
We meet every Wednesday at 9 p.m. Eastern Standard Time Online using the Mumble Client.
Again, all the details can be found on linuxbasics.com.
Why don't we just start opening it up for two general questions first, and pretty much
taking it from there, and we'll see how this goes.
Anybody have any questions?
Yeah, okay.
I guess I'll start with the first one.
I guess a few look on page, I think it's 85 there, the Shell Variable Basics.
They're talking about the PS1, the prom string.
I'm wondering if you guys use this, or if there's any practical use for changing how your
prom string looks.
I know I'm getting how it's done, but I just can't understand why it would be useful
to change it.
I wonder if you have a practical example, anybody?
Well, I have an example.
But sometimes say you're SSH into a few different systems.
You might want to change your prom string to reflect your host name normally.
It does, but a lot of people actually customize the prom string to say put in the time and
other variables, but I typically don't.
Yeah, I guess that now that makes a bit more sense.
Definitely.
If you're SSH into many different machines, you could have unique things about each machine
in there.
Yeah, I guess that's one really good example, actually.
Apparently, the page number is a different in the PDF version compared to the book, because
I might 85, page 35, it's talking about sport, but it's 65, I guess.
Okay.
Okay.
That definitely is a good example, but just to be able to add different information,
whatever the options are, some people may not want for whatever reason, their home path
or whatever, or the current working director, or whatever it's showing, but I think that's
a good example for anyone else having questions.
I got one.
I think it's on page 66, I'm sorry, I'm in the PDF version on my screen, so I'm not really
sure exactly what page it is, about exporting a variable to a child shell versus the parent
shell.
Did anybody else get hung up on that for like 20 minutes like I did?
I understand what it's saying.
If you have another shell, then you can export it so that all the shells can see it if
you will.
Actually, I had a real life running with exactly this where I thought I could set an environment
variable.
I could then have another program running in another shell executed entirely separately
would be able to read that as long as they were contemporaneous while the export was
on.
I ended up learning the hard way that exporting only affects the child shells that you create
from the current shell.
If you have to save to a file, if you want to communicate from one shell application running
on one to the other, or you know RPC wherever, you cannot send an environmental variable
into some sort of generic key value data store where other shells that you open subsequently
can have happily find it and stuff like that.
And that's where I thought it worked until I actually, oh sorry, going on like I said.
No, I was just going to say that's exactly what I was getting at because I was sitting
here at my terminals playing with it and I thought it was going to be on any of the
shells that I did, I did had running because I had like three or four shells running
trying to play with different things and so on and that totally screwed me up.
I had to start a shell in the same, it was only a child shell in that instance not across
all the instances.
And was that your intuition as to how it worked when I read through it my first impression
of it was it was going to be through all of the instances of my shell.
I'm running the old GNOME still so you know I have you know just the standard terminal
will open and I open up two different terminals I thought I should be able to use the same
variable in both of those that's not what they were saying.
And they're right exactly that but that's not what I got and you know if you guys didn't
play with it you might have even missed that that's you know the only reason I caught
onto it was because I was sitting there and like I said it took me like 20 minutes of
trying to figure okay did I type the command wrong did I do something wrong kept going
back and forth at it looking at the you know looking at my commands and everything else
before I finally realized and when you type in bash that opens up a child shell underneath
your current shell which then is a little access to variable.
Right if you notice it does say a child shell you write a lot of people might miss that
it says now we spawn a sub-shell or child process.
My intuition was exactly like yours so so you know what I mean it was like well things
that I definitely it's not like I have never accessed environmental variables before but
I had no idea actually of the mechanisms involved and it was really is really interesting learning
specifically how that all worked.
So just to kind of understand what the conversation is if let's say I have the terminal open
right now and I export a variable only anything that I spawn from the current shell will
have that variable is that what you're you're saying there correct correct and that's
what trip me up because it child process to me it didn't quite equate when I to only
if you spawn it from that particular shell.
I thought all the shells that I was doing was the child processes and when I exported
a variable it would go to available of all shells that I was running from from this
term from that in or am I trying to say.
Okay so let's say I'm in the command line and I type in ENV and that will list all my
variables how do I change those though because those are universal right because those variables
in there should work for for everything right.
Right when when you set a variable on the command line like they they have a instance of
my var equals hello you can echo that and it's obviously types it out.
If you start up into another bash instance unless you export that variable first it won't
be available to you and you would have to start the next bash instance from within your
current terminal which would make it a child process.
But I can see that that was probably by design because let's say you want to run a command
on two different directories for example and it's going to be you know it's going to take
some time or maybe not two directors but two different you know to do two different things
at once with variables.
You may not want that you ain't want to reuse that variable name but not have it in a fear
so that's why you have to specifically export it if that makes sense.
I actually kind of missed that as well to be honest because I guess when I got down to
like his size you know it was talking about multiple shows and one does and I guess
that's what I was thinking of but that would be what I think the reason why they do it
that way.
I wholeheartedly agree it just that's like I said that's one thing that if you just kind
of skipped over it or glazed over it you might not have caught and like I said it took
me 20 minutes just reading you know going back and through and making sure I was doing
the steps right to catch on to what they what they actually said.
What is the good question so far?
Okay let's see you guys ready to kick this off for the review questions.
Sure.
Alright I'm just going to do them in order.
The first one was describe the difference between shell variables and environment variables.
Okay I think this is exactly what I was thinking about before was that when you type
that ENV and you get a list of variables I think from what I always understood that those
were universal across the board but then when you do shell variables that's the ones what
we're doing where you export them from one shell to a child's shell.
I think that's how I always understood it and that's why I'm kind of confused about all
this.
That's the way I understand it as well and it's good to understand it especially when
you're trying to do different scripts and things where you might open a couple different
shells and you need to know how to export those and you also need to know the difference
between what's going to be across all of your shells or all of the instances automatically
and what you have would have to export or what you would have to use only in that particular
instance of bash.
That was a subtle thing that has as bit me in the real world no thank you for pointing
it out man.
Good looking out is that.
Yeah, first question is describe difference between shell variables and environmental variables.
Yeah, he wants to start the second question then.
Okay, compare and contrast built in and explicitly define commands and those found in.
All right, well I know the built in commands those are going to be listed in a variable
that you can use set if I'm not mistaken to you know it and it looks through all the
command you know it looks it checks all those paths and then you can define commands by
typing them in and then there's commands by typing the path out and then if the command
is where you are in the current working directory then you can just run it from there by
typing in its name.
That's all right.
Yeah, I'm not so sure I even understand what they're trying to ask us there.
So basically path has all the directories that contain binaries so that instead of doing
user bin less or LS you can just type in LS and if you want to add different directories
into your path so that you can just use like basically shortcuts to all your commands
right?
Well, I think another issue is where the commands are actually being run from so if it's
just a shell command like say set you're not going to have a binary file for set that's
part of the shell whereas if you're going to do like say RM there is a RM binary file
that will be found when you run RM.
Yeah, that's exactly the distinction that they're looking for here that you know the difference
between say the CD command you won't find that anywhere on your system it's going to be
built into back itself and any other command like LS RM you know that's in your path and
you need to know something that's not in your path like in the current directory you
can tell it to look in dot slash for that binary.
Just as an example if you do which say which RM it'll show you the RM command words
being run from but if you do which set there is no binary for that that's just basically
built into the shell and it's not going to show you anything.
I had never I never even thought about thinking about this it's just I don't know this is
interesting.
Another issue is just like on ODOS systems if you had like a compile and a exe file with
the same name which one will it execute first that could be you know an issue to that that
you want to know about.
So like DOS it would be like the commands that are built into the kernel then the ones
that are actually binaries right exactly and not not even so much the kernel but the
shell that you're using.
So I would assume that the shell commands would be executed first then if it doesn't find
that command in the shell as part of the built in shell commands then it starts to look
along the path for the command that you type.
So and if you're using different shells you're obviously going to there's a potential
having a different built in commands right.
The bash is part of the Linux kernel from that statement so you should be able to find
bash on any any Linux install unless it's maybe tried to get any remote or something
other possible.
No, when I do a witch bash and it's telling me it's a binary that is in slash bin slash
bash.
Exactly.
Okay, any more or should I move on to the next one?
I guess you can move on I'm kind of getting this now.
Okay, after a lengthy session of file manipulation on the command line what will the bang ls
command produce or is it the last time you ran it will reproduce the last time you ran
the ls command or something because I just typed it I did bang ls and it did ls of a directory
that I did before so I'm wondering if that's just the last time you ran ls it just repeats
that command.
I'm going to go with yes because there's actually a small section command history expansion
designators and it gives you the four examples which is the bang bang the bang n the bang dash
n and the bang string.
So it would be the last command that you or the most recent command that you ran more
specifically it's not actually looking at a command it's not that smart it's looking
in a history for anything that started with ls so if you happen to run ls mod it would
run that instead.
Excellent.
Thanks for the clarification.
So basically if you do bang in with any string it would run the last or the most recent
version of that or a string what a rich never hits first it will run that that's right
it looks in the the bash history for that string.
Now that's something very useful that I seem to have missed.
Okay the next one is what program was the source for the default history editing key
bindings in bash.
Is it that question four?
Yes.
We have a different one here.
Oh all right.
Well the answer to that question was emax but what was your fourth question?
What files does bash read when you log in would that be the bash or c file and then the
profiles file rate.
I think profiles the log in one to someone carry this but to explain that in more detail
than what you know.
Batch is actually looking at several files when you when you log in it's checking Etsy
profile first of all because that controls everything for the system every shell that
you run you want that an Etsy profile if you wanted to take effect and after that it's
starting to read things in your home directory.
There's home slash dot bash profile for there's a distinction between a log in shell and
a non log in shell.
If it's a non log in shell it's going to read home slash dot bash or c but for the log
in shells it's reading the bash profile and less commonly bash log in and home slash
dot profile.
It's it's kind of complicated just to hear it but I do recommend you go read the invocation
section of the bash man page it explains all this.
I just put another link out there for people to check it out.
Just as I had said for the notes that I'm putting on here very I probably wouldn't pay
too much attention to them tonight but I'm cleaning a lot of the stuff up tomorrow.
I'm also going to put in that link that just showed up in a chat as well.
The next question I have is explain the notion of pipes as they refer to shell capabilities
and illustrate using an example of two or more of the filter programs.
Well I guess I'll start here this is one that I use quite a bit.
What I do a lot is I will cat file so cat space and then file name and then I'll pipe
that through prep and then I'll have a regular expression to filter out lines with a certain
name or in such and then sometimes I will do do that twice or three times to do the
results the result of one grab through another grab through another grab whatever and then
pipe that into a word counter the WC or or the grab space C I think or dash C that's
another one that's that's what I use it for I'm sure there's probably more efficient
ways of doing that but I find that very useful sometimes if you go through logs to to grab
out certain lines and in the whole list of logs in the in the bar slash log directory.
And actually John can I get you to put that put an example of that in the Google docs.
Yeah and I guess another example sort of along those same lines would be like if you cat
a file and the file isn't sorted you might want to sort that so you would pipe it through
sort and then if you're only interested in unique occurrences you would also type it through
the unique command.
Yeah exactly and that's another one that I find very useful as a sort it's sort space dash
you and it will take it all duplicates of the of the result and the Google doctor I did a quick
little right up there basically cat the file pipe grab Linux pipe grab test sort dash you word
count dash L that will give you basically no else start over here it will count the lines in the
file that have Linux and test in the line and then take all do put take out all duplicates.
Okay moving on to number six explain the dash P option to CP and give an example of why it is
necessary. Yeah this is the one I found out yesterday actually I think this can be used for
make directory and all those is if you're copying a file that is like four directories deep to
somewhere else but a few of those middle directories that don't exist in the other and the where
you're copying them to it will make those directories and I think make director does the same thing if
you make let's say you only have a directory home home user name but you want to do home user name
ABC all these different the high level or deep directories it will make all of them even if you just
specified the one or I guess a better way to explain this would be that it will if you create a
directory that is a child and the parent doesn't exist a lot of likely create the parent.
All right let's see moving on to the next give two examples of files matched by the wild card
which is the question mark question mark bracket bang one through one dash five and close bracket.
Well that's sure what the bang is but I know the question marks are you know any ditch
you know it would be like AB and then the one through five I would think is a number one through five
so okay so it would be anything that is not I believe one through five is that correct
so would be like AB six and AC seven correct that sounds correct to me actually that's true
because under the table that I had here common file naming wild cards that's exactly the last
example that it gives it was matched any single character from among the characters not in the
range list between the brackets. Yeah the thing that threw me off on that one was the the bang
character which is I guess the not character so that was a good catch. Oh actually good call on that
I wouldn't sure I just kind of worked that so it's got to be what it is and I'll know what else
because if it was outside of the bracket and obviously you'd be looking for that name.
Okay moving on naming the three standard input outputs streams and their functions.
I guess the input is by default your keyboard that's one standard output is your screen
secondary output is error if I remember correct. Yeah the defaults are those and you can
change the default or change the output to another file or any other direction you want to go.
I will take those answers let me see and also there's actually a section under object for you
using unique streams pipes and redirects and it's actually the second section after the main
paragraph. Okay number nine give an example of the redirects and operator and describe how the
outcome would be different using the double arrow operator. Okay I'll take that one. Well the
the greater than sign is the output operator so say if you do a LS and you want to save the
output of the LS command you just it will use the greater than sign and you say redirected to
a file to save it for later so you would say LS greater than sign and then say output text.
But the double greater than sign is actually if you want to have say a series of commands to
append to one one big file where the basically the double greater than sign appends and the
single greater than sign will just overwrite if a file already exists. All right naturally done
anyone else want to add anything else before I move on. I was just going to say make sure
you use the right one otherwise you can cause yourself a heck of a lot of work I've done that
before. I like to play with that in that. All right number 10 what process is the ultimate
ancestor of all system processes and give both the PID and the program name.
Is this init and then one? I think it's init in zero. Yeah that might be let me excuse you
ends up starting from zero. Now you had it right the first time. It's one. Yeah because isn't it
a knit run level zero shut down? No these wouldn't be a run levels they're just processes themselves
right? Yes. In fact under processes the header for that it's actually the fifth item down process
parent process ID the parent PID and one is the PID of init. It sure is.
All right number 11 name the three common utilities used for process monitoring.
One is ps tree and the other is ps and the other one I'm not sure the top it is indeed.
And that ps tree is the one I read in this book here that I never really used but I'm starting to
find that one very useful like if you guys put in like type in ps tree ps t r e and it'll enter
you get a tree of all the processes like the parents and children like very detailed and you can see
exactly which process spawn which other one and it's really detailed. Actually that's nice because
it's funny I generally use top myself. This is actually great because there are some there are some
programs that are using other processes that I'm not aware of. This is actually very cool. Okay
number 12 what happens to a typical demon when it receives the sig hub and how would the behavior
be different if it received the sig kill? I think the sig kill is pretty obvious as far as they'll
just kill the process but I think sig up I'm not quite sure but I think that just will reread
the configuration file as if I'm correct. All right it's a little confusing to me but I'll read
the definition of what it has here. It's the first example in the signal name it's hang up the
signal is sent automatically when you log out or disconnect the modem. It is also used by many
demons to cause the configuration file to be reread. There you go. You are correct John.
All right next one compare and contrast background and foreground jobs and state the syntax to put
a command in the background on the command line. Well the command is running it's initially
unless you tell it to is going to be in the foreground and if you want to you know get it out of the way
of your batch of that way you can let other commands as well you can put it to the background and
we'll do that with dg. You can also bring it back to the foreground with fg and I think there's no
way what I can't remember what it is. Another way to put a command in the background is to use a space
and then an ampersand and that will run it in the background. Yeah that's the one I'm very
familiar with is the ampersand especially if you're running or if you do a bash script and you want
to open up a program and leave it open then you have to put the ampersand after the command.
Which is something I had to do with the program on shared hosting recently because it really
didn't want to run it in the background unless I forced it to run the background with the ampersand.
Okay next up explain the relationship between a process nice number and its execution priority.
You need to have a different question here again but we could actually just do you I think yours
is a very good question there. Sure it says explain the relationship between a process is nice
number and its execution priority. From what I understand the higher the nice number the
the lower the priority as far as it being executed and then the lower the nice number
the higher the priority in the execution. I've never used the nice command before but let me give
you the quick description of it here. The nice command is used to alter another commands nice
number at start time. The normal user's adjustment is an integer from 1 to 19. If you're a super
user the adjustment range is from negative 20 to 19. If an adjustment number is not specified the
process is nice number defaults 10. The command consists of any command that you might enter on the
command line including all options, arguments, redirections and the background character the ampersand.
If both adjustment and command are omitted nice displays the current scheduling priority which
is inherited. So is that just if if you want to start a command can you change the nice value
on the fly when a program is running? Yes you can and that would be the re nice command to change
the priority. Okay so nice we do it and when you start the program and if it's already running
re nice okay that makes sense. John did you want to read the other question I figure we might
just catch them all so we're all under the same roof here. Yeah so that would be 14 is what two
classifications of characters make up regular expressions. I know one is literal and the other one
is either meta something because you have the literal characters that you're trying to represent and
then then you have the symbols that are that represent kind of an action rather than the literal
value of the character. Okay I'm going to go with that for now. Let's see let's wrap it up with the
last question I had for 16 which is how our regular expressions bracket A dash to C while close
bracket wild card and carrot bracket A dash to C close bracket asterix dollar sign different.
Well I think just looking at it with the carrot sign that is saying that that regular expression
has to be at the front of the of the expression and it also looks like the dollar sign is matching
the end but but actually looking at them it could be that they're actually the same.
Would the the first one without the carrot and dollar sign mean that if you find any range from
A to Z capitalize anywhere in the word and then the other one would be it would have to be
care being the beginning and dollar being the end the entire word it would have to represent
capital letters from A to Z then again I'm not I'm not really good at regular expressions I can
never read them and I don't really have a good example like to try because I don't know how would
we quickly try this so that we could find out. I think you're right I think that's exactly what it
is it would be like you know A whatever A wild card or D wild card whatever like D1 or A3 or
A anything A and the second one of course it would have to start yeah but it could also be
A123 the second one well I guess it's saying the same thing.
Actually I think the first one you're right it's anything that matches in between A to Z
but the second one has to go in order so if it finds a character first that begins with A
then it goes with that if there's no A then it'll go with the next one.
Actually I think the first one is anything that matches anything that only has capital letters
A through Z so it all caps alternate as in our Bruce and the second one is only going to
well it is going to match yeah and in the second one it's anything that would be like Bruce
123 or Bruce 2 or Bruce B or Bruce lowercase B and alternate as in stuck together the
others and it could be in any format or it could be Bruce you know 123 does that make sense yeah
it to me it just seems like this is one of the things I really need to practice on because yeah
regular expressions can be kind of tricky unless you really do them all the time.
Well let me repeat one more time the first one is anything in all caps that it's only
letters in all caps and then the second one can anything that starts with all caps and then also has
any other inner or letters after it but if it was if it started with lowercase then it would not
find that or pick it up or if it starts with a number or anything like that.
I think I'm going to have to look at that a little bit more closely we'll table that for now
unless someone comes up with a better shot here. I was just going to say that we need to find a
cheat sheet for regular expressions on in the bash shell that would be perfect because then you
could just quickly look things up because these are for me regular expressions like if I have a
cheat sheet beside me I'm looking it up I can write some pretty complex ones but I don't do it
often enough that I can memorize what they all do and and that's why they always they always get
me every time you were saying that that was your last one there right we have two more here okay
by our way what is the difference between executing colon q versus colon q bang in d i
colon q is actually one that I'm surprised that I know go ahead the bang at the end forces it to
quit even if it's not saved that is correct the same here the past couple of months I've been trying
to use it and that's why I actually knew this one I wouldn't have known couple of months ago
yeah the last question is what does it mean to put vi into into command mode or I guess with vi
there's there's two modes you can be in editing mode and then command mode which is you know
normally you do the colon and instead of you know you typing like text you're gonna say okay
quit or save or or read in another file and that's when you're in command mode you can also
delete a character in command mode as well real quick I want to say those people that might be
listening along now or in the near future you know over the course of practicing for your LPI and
just doing the the little text editing that's required to try examples and learn it you probably
want to take on vi now just start with the basics because if you start now with it it's going
these these if you're not familiar with vi and are not sure how easy these questions are these are
very easy and it seems to be that if you were to take the course the do use vi as your primary you
know as your as your editor and all caps necessary then you will you will those questions are
going to be gaming those questions on vi are going to be giving these are not complex difficult
questions in regard to vi these are something that you know you know by heart and soul if you've
been using vi so if you're not using it my want consider doing so yeah here again I found that
I was starting with vi it's very smart to have a cheat sheet and what I literally did is I
downloaded pdf with all the commands printed out on a piece of paper and had a beside my keyboard
and that's how I navigated the whole thing and what I found is I'm by no way very fast
using vi but I found that vi is not as hard to use as I initially thought because I thought all
these commands I'm screwed I'm never going to learn this but with that cheat sheet beside me it
actually is pretty intuitive of how it works and doesn't take very long and you got the basic
commands to get around and then you're all set okay seeing that we've wrapped up on the review
questions I guess what I'm going to do is open back the floor up and just sort of discuss where
we are in terms of what people thought of the first couple of chapters this is a good pace you know
some of the hurdles that they had to overcome any thoughts I'm going to say that where I'm going
to have to do go back and studies a little bit more is the whole variable situation as far as
how they react to environmental variables and shell variables and how to set them and play around
them I've always that's always been a weak spot for me in the Linux opting system but yeah definitely
I think we're going at a good pace here I was reading the roadmap if this is kind of the chunk
that we're going to do every week I think that's for me anyway that's perfectly digestible I can
read that one or two chapters pretty easily reading three chapters in a week I think this is a
perfect pace for me hey I just want to repeat for some of the people who came late that the just
you know I came early really early I guess I got the time mixed up but I went to penguin tutor
.com and took that sample LPI 101 test and it just sort of let me know like some of the things
that I really needed to or sort of like brush up on because I think the thing is there's some
of the things that you don't use all the time and so you just tend to forget about them but things
that you do use all the time they're just like they're there for you so that that's a good resource
I'm going to put that link back in the back in the form just in case somebody didn't have that
yeah definitely pretty down the sheet as well and once I clean up those notes I'll publish those as well
sound good to me one thing that I I'll volunteer to do is on question let's see number 15 what
I'll try to do is I'll try to work up some examples of regular expressions and sort of maybe try to
get down to the bottom of that question because I've been playing with it uh you know just just
you know afterwards because you know like I said I don't use regular expressions that much so
the more that I work with it the better you know it it comes to me and I'll just
whip up some examples and and put that out I guess on google docs how you appreciate that verbal
that would be great
thank you for listening to H.P.R. sponsored by caro.net so head on over to caro.nc
don't need
.
