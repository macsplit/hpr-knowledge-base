Episode: 339
Title: HPR0339: Reasons to love Symlinks
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0339/hpr0339.mp3
Transcribed: 2025-10-07 16:42:28

---

music
music
music
music
music
music
music
music
music
music
music
music
music
In pretty much any operating system command line tools for file management are usually
the first ones you learn.
In Linux for example, usually Rm for removing files, Ls for listing them, while CP copies
files and Mb moves them around through your directories.
These are some of the most common two letter commands for manipulating files.
But I think there is one command which goes a bit more neglected than some more popular
siblings.
Ln.
Ln makes links between files, but specifically Ln-s that is Ln with the symbolic flag makes
symbolic links, or siblings, also known as soft links.
Simulings may be used in many useful ways.
Many of them neglected by modern computer users, mostly newbies who found Ubuntu to be
interesting, but don't really know much about Unix and the history of the command line.
Rather people use the copy command, CP, or they use Mb to move files back and forth
from directory to directory to accomplish many of the functions that could better be served
by using Ln.
Now before I talk about some of the creative uses for siblings that I use, I think it's
useful to go into what they are exactly.
You see, Ln is one of the GNU core utilities, probably the most important part of a GNU
Linux system, probably besides the kernel, though that's a different debate.
But again, Ln's in the core, GNU core utilities, much like LS, make directory, cat, or touch,
and it's roots go back as far as AT&T's original Unix, and AT&T's Unix from, I believe,
69 it was, it's sort of the adoptive great grandfather of all modern GNU Linux systems,
anyway.
Ln with the dash S, meaning symbolic flag, specifically creates siblings.
And again, that's what I'm focusing on here.
Now siblings are links to other files in your file hierarchy.
If for example you had a text file A and create a sibling entitled B, when you used cat
on B, you would see the contents of A. Likewise, if you open B in your favorite text editor,
let's save them and edit it.
And then you looked at the contents of A, you'd see that it had been altered.
Because B was nothing but a pointer to the file A, there's a problem with siblings though.
They could point to nong to some objects.
And also, they point to objects using relative hierarchy.
So once you create a sibling to a file, it's usually not a good idea to move either the
original file or the simlink.
But if you've already arranged your files, in a way that pleases you, this shouldn't
really be a problem.
Now of course, simlinks in terms of, you know, computer upkeep and such, can create problems,
dead simlinks.
Much like a dead hyperlink on a web page, a simlink pointing to a nong as an object can
cause problems for various things.
But that's all a bit beside the point, because I'm not here to, if tutorial when using
simlinks, I'm here to promote the use of simlinks.
I use simlinks for a lot of different things that I used to use CP and MV for until I realized
that's a very inefficient means of doing things.
With CP, I'm re-duplicating disk space.
If I want to add a file, I have to add it twice, that's re-duplication of effort.
Very ununix like.
And using MV, once I move the file to the directory I want to add it in, or in order
to organize, you know, projects or such, I have to then move it back to where I had
a previous it's, again, effort that I don't need to expend.
Some examples of how I use simlinks.
Let's say in my home directory, I have a collection of, you know, a directory where
I keep my PDF documents in e-books, various technical, some fiction, some creative common
stuff, and I want to keep those files there, I want to organize them there.
Let's say I'm reading a creative comments book by Corey Doctoro, a PDF document, for
example.
I'm not finished, but I must leave, I have to go somewhere.
I don't want to have to remember what exactly I was reading or where it was, and, you know,
within the myriad of files, it's something like three files deep in the hierarchy under,
you know, my directory entitled e-books.
So I create a simlink and a different directory, a directory only one file deep, well, only
one level deep that is in my home directory called unfinished reading.
I go to unfinished reading and create a simlink to the PDF document I was reading in order
that I can find it more easily when I'm next at my computer.
That's one useful example of how to use simlinks to your advantage.
Another is to create playlists.
It might be a bit unusual, but I like to browse my music and listen to it through the
command line and Linux.
So when I happen upon a song that I want to put in a playlist, there's not exactly
a lot of easy choices for me.
I could open it in Amarok and create a playlist, but I'm going to go through that trouble.
The reason I'm using the command line is because I want to get it done quickly.
So again, I have a directory in my music directory called playlists, and directories within
that directory, which are the various playlists I create.
In those playlists, all of them having different titles, I create symbolic links to the original
songs.
Now, this is very important because if I were to use the copy command to perform this function
and all my, you know, I have dozens of different playlists for different moods that strike
me, I would be duplicating, oh, that's probably hundreds of megabytes on my hard drive.
Now I have a 400 gigabyte hard drive, but still I don't like wasting space.
I don't need the same song twice.
I just need a link to the first song under my music directory.
And so I use simlinks to affect a way of organizing and utilizing playlists, which really
is one of the most useful things about simlinks, in my opinion.
Now, simlinks are also useful for programming.
I have a folder called PROGPROG for programming, which is where I keep the different programming
products I'm working on.
And it's organized by language, C, C++, Java, Python, common list, I think even some
purl.
That's what a thing.
Oh, bash scripts are there as well, I'll get to that later.
And all of the original files of the original programs I write, the source code, and even
the compiled, well, even the compiled code in some cases, are within these directories organized
by programming language.
That's how I prefer it.
But let's say I'm working on something for a CS class in school, which will usually be
in Java, and I'll honesty.
If I'm working on something for school, I'll be organizing it by project or by homework
assignment, obviously.
So I will write the original program in my Java directory.
But I will create other directories in my PROG, I guess, PROG folder, and use simlinks
to the original in the Java folder in order to organize them.
And this is useful, especially because of the nature of simlinks, so I mean, because
they are simlinks, when I open those and again, them and edit it, I'm also editing the original
because it is simply a pointer to the original file.
There are no two files.
If I use DU to see the dis usage of the items and the directories could take nothing
with simlinks, I will see zero just space being used because it is, in fact, not using
dis space is nothing but a pointer that original file.
Though that's not exactly the sexiest thing about Linux, that's one of the useful little
tools that really make you glad you're not using Windows anymore.
Even though I think Windows might have some strange way of, this at least has some strange
way of using something like simlinks that requires some bizarre permissions than going on
that no one really understands.
Now another way I use simlinks is to organize plain text notes.
I keep, again, my text editor is VIM, it's all command line based, sometimes I might
use GVIM, but usually it's just, you know, regular vanilla in the command line VIM.
And when I take notes or write notes to myself, I don't use, I mean, I'm a GNOME user,
but I don't use Tom Boy, I don't use these wiki, these personal wikis, I don't use any
sort of advanced settings software, I simply create text files.
I have a directory on my home folder called text files.
I have hundreds of text files, some of them only contain a few URLs of sites I should
really, you know, read up on and research on because I, for example, like the way they
use their CSS, I want to see, you know, their code base and learn a few things because,
you know, I kind of like web design, it's a hobby of mine.
But these plain text notes, which number in the hundreds, have to be organized, but some
of them fit into many categories.
Something that's programming related might also be Linux related.
Something that's school related, again, might be either programming or Linux related.
Something that's, you know, like phone number that I want to keep in my, you know, text
file, which I use as sort of a dress book, really, might also be on my, in someone I should
call and a list of phone numbers I should call soon, because, you know, I want to get
back in touch with that person.
Again, I could use copy, I could move from directory to ping what my focus of the project
one as a time.
But again, that's the most, most inefficient way of doing things, simlinks.
And then here's the real advantage of simlinks, or again, it is just a pointer.
I can not stress that enough of pointer to that data when I edit the simlink.
I'm in fact simply adding the original file.
So I can keep all of these plain text notes in a subdirectory of my text files directory
in my home directory, and then have, you know, dozens of other directories, some, some
of the text files appear in all of them, some two or three, and it is this wonderful
notion of pointing to data and being able to access and modify it from within a different
place in the directory of the location of the original data that makes simlinks something
you can leverage.
And that's really what free and open source software is about, leveraging code to get
things done faster, more efficiently, and with less expenditure of energy if you can
help it.
When it comes to, again, simlinks, a more mundane kind of boring, which is why I'm setting
it for laterally, save the worst for laterally, a very boring means of using simlinks is to
keep control of your bash scripts.
Now in my home directory, I have a bin directory, which is in my path, and that's where I put,
you know, bash scripts I want to execute.
Of course, I'm working at a one time on dozens of bash scripts that are at works in progress.
Now obviously I cannot store them in my bin directory because they're unfinished.
They might do wonky things to my file system or something if I accidentally execute them
and that the code's not exactly in a state that I find, you know, acceptable for human
use.
So I have, again, under my programming directory, a bash scripts directory, which are,
those contain all works in progress, and in my bin directory are the simlinks, two files
in the bash scripts directory, which I consider finished.
For example, one shell script I wrote, and I audit, which simply moves, which simply
moves files from my hard drive to my MP3 player as quality for augurbis files in order
to, you know, conserve space.
And so using simlinks in my bin directory allows me to work on bash scripts, keep all my
bash scripts under one directory in my file system hierarchy, with that worrying about
axiom executing something that's not in a finished state.
That's a very practical and somewhat ho-hum use for symbolic links.
Again, I'm not exactly trying to explain what they are.
I'm rather a cheerleader for the Ellen dash-ass command.
I'm trying to encourage his adoption by the latest generation of GNU Linux users because
some people are ignorant of this wonderful tool, while others know of it, but think it's
one of those not precisely ubiquitous, while others think it, well, it's ubiquitous
on every GNU Linux system.
It's not exactly one of the utilities I should turn to as often as say LSCP or MV, whereas
with me, I use Ellen dash-ass more often than CP.
I can quite honestly say it's perhaps my favorite and two letter command.
And with that, I'll say goodbye.
