Episode: 4011
Title: HPR4011: The Intel Hex file format
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr4011/hpr4011.mp3
Transcribed: 2025-10-25 18:35:04

---

This is Hacker Public Radio Episode 4,011 from Monday the 18th of December 2023.
Today's show is entitled, The Intel Hexfile Format.
It is hosted by Brian in Ohio, and is about two minutes long.
It carries a clean flag.
The summary is, a synopsis of this old but far from dead file format.
Hello Hacker Public Radio, Brian in Ohio here.
I'm out from under my rock, and this episode is about an old file format that, despite
it's agent still in use in many places today, that format is the Intel Hex format.
What is this format?
Glad you asked.
From the book of knowledge we read, Intel Hex a decimal object file format, Intel Hex
format, or Intel Hex is a file format that conveys binary information in ASCITEX form.
If you have ever programmed an Arduino board of the file that is used to program the board,
the file generated by Arduino ID is an Intel Hex file.
The format consists of any number of lines, called records.
Intel Hex consists of lines of ASCITEX that are separated by line feed or carriage return
characters for both.
Each text line contains uppercase Hex a decimal character that encode multiple binary numbers.
The binary numbers may represent data, memory addresses, or other values, depending on
the position in the line and the type and length of the line.
Each text line is called the record.
The record consists of six fields that appear in order from left to right.
One, start code, one character, ASCITEX colon.
Two, byte count, indicating the number of bytes in the data field.
The address, four Hex digits, representing the 16-bit beginning memory address, set
of the data.
Four, record type two Hex digits, 0, 0, 0, 0, 5, defining the meaning of the data field.
Five, data, sequence of bytes of data, six.
Check some computer value that can be used to verify the record has no errors.
An end-up file record must occur exactly once per file in the last record of the file.
The byte count is 0, 0.
The address field is typically 0, 0, 0, 0, 0, and the data field is omitted.
The records check some bytes as the two's complement of the least significant byte of the
sum of all decoded byte values in the record preceding the check sum.
It is computed by summing the decoded byte values and extracting the least significant
byte of the sum, and then calculating the two's complement of the sum by inverting its
bits and adding one.
I have included in the show notes an example of a record with pipes used to break up the
line.
I hope you enjoyed this recap episode.
There are so many ways to produce shows that there is no excuse not to.
This is Brian in Ohio signing for reminding everyone.
We are all creatures of ego.
You have been listening to Hacker Public Radio, and Hacker Public Radio does work.
Today's show was contributed by a HBR listener like yourself.
If you ever thought of recording podcasts, click on our contribute link to find out how
easy it really is.
The hosting for HBR has been kindly provided by an honesthost.com, the Internet Archive
and our Sync.net.
On the Sadois status, today's show is released under Creative Commons, Attribution 4.0 International
License.
