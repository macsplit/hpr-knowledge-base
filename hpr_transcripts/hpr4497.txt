Episode: 4497
Title: HPR4497: fixing 328eforth
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr4497/hpr4497.mp3
Transcribed: 2025-11-22 15:05:39

---

This is Hacker Public Radio Episode 4497 for Tuesday the 28th of October 2025.
Today's show is entitled Fixing 328 F-Earth.
It is part of the series Arduino and related devices.
It is hosted by Brian in Ohio and is about 19 minutes long.
It carries a clean flag.
The summary is a summary of making 328 F-Earth useful.
Hello Hacker Public Radio Brian in Ohio here.
I'm out from under my rock and doing an episode to continue from where I left off an episode
4388 and that episode was called a review of the book The Arduino Control by E4 Dr.
Chin Hansen Ting.
In this episode I want to talk about installing E4th onto an Arduino board and then talk
about the problem I encountered and what initially made 328 E4th a no-go for me and then how
I solved the problem and the fix to make 328 E4th a useful for anybody.
In order to install E4th onto an Arduino board you're going to need some software and some
hardware.
I've got links in the show notes for all the software you would need.
The first place to start would be to go to get this 328 E4th source code and that's
at the Peterforth Github account where he has a mirror of the O-feet store which was
Dr. Ting's site that had all of the software that he developed or collaborated with other
people to develop for different forth for different processors.
The next link is for Avra.
Avra is an open source assembler for what used to be called Atmel but is now microchip AVR
processors.
This is one of the reasons that I switched to using 328 E4th because in order to build
other forths you need to either use proprietary software or old Windows systems and if you're
a Linux user that that means using wine.
This way using Avra you can easily assemble the source code into a hex file that you can
then upload onto the chip and it's all open source software doesn't require anything
more than a make-make install to install the software and if you're a Slackware user and
why aren't you a Slackware user.
There is a Slack builds for the Avra assembler.
The next link is a fuse calculator.
The fuses on these microchip atmel AVR chips are configuration registers.
You configure them, you use these registers to configure the chip to behave in certain
ways, such as in the way I change it is, well it changes the boot loader size, changes
the clock systems that you can use, tells the chip whether or not to save the e-prom over
reboots, things like that.
They are registers in the chip to configure the chip in certain ways.
The link that I have there is a fuse calculator that allows you to select what you want the
chip to do and then it gives you an output to put into the flashing software in order to
make the chips, the chip be configured the way you want it to be.
That's the next link is the flashing software.
You'll need AVR dude which is the flashing software of choice for the microchip AVR line
of chips.
This used by the Arduino IDE, that's what they used to upload the Arduino source code
files that you would develop if you're building a straight Arduino project.
You'll also need some kind of a shell program, terminal shell program.
I use the terminal program, serial terminal program that's an extension on EMAX which is
I can develop my flash programs pretty simply in EMAX.
There's also a kind of a cool terminal shell program in available to flash for its site
so I've got a link to that.
That's a TCL based shell program that allows you to do useful things like uploading files
very easily to the board and also recording sessions and it gives you tab completion and
things like that.
That's available at the flash for its site.
There's also some shells written in Python.
There's a lot of terminal shell programs that are available out there.
If you're going to do this in Windows, I think everybody uses TerraTerm.
As far as hardware goes, you're going to need a programmer.
Programmer is a device that uploads, that takes a hex file and uploads it onto the board.
They are doing no board.
The one I currently use is actually an average to programmer.
That's the one I would recommend.
It's fast and it works well.
They're about $45 USD on Amazon.
If you don't want to spend that money, there's cheaper clones out there.
There's all kinds of different programmers available.
You can even build your own and I actually, as I started this episode, I realized that
I'd done an episode, episode 2799, where I describe how to build a microchip AVR programmer
out of an Arduino Nano board.
That's what you need programmer-wise.
You'll need an Arduino board.
For this project, you're going to want an Arduino Uno R3 or an Arduino Nano.
You don't want to use a Leonardo, you don't want to use anything other than that.
You want the very early versions of the Arduino boards.
You really, the one that I use is an Arduino Uno board with a dip package where I can pop
the chip out after I've flashed e4th onto it and I can put the chip onto a breadboard.
That's how I use it.
Although you can use e4th right on that Arduino board and that's really useful if you're
just beginning.
So with Active, we've got hardware and the software that you need, I'll just briefly go over
how to install it.
It's described in the book, slightly obliquely.
You can also look at the flash forth site or the m4th site on how to flash Arduino boards.
I'm not going to go into a lot of detail about that, but essentially what you're going
to do is when you go to that first website with the Ofeet story, you're going to want to
download, you could clone the whole repository or you could just download 2159, underscore
328 e4th.zip.
That's the file that contains the source code and a bunch of other useful documents, including
a PDF version of the book, the Arduino controlled by e4th, right in that zip file.
So after you've unzip that file, you can CD into it and then you would assemble the 328
e4th source code, which is 328 e4th 220 dot ASM.
You want to assemble that file using AVERA and that's a very simple incantation.
It's just AVERA, AVRA and then a space and then 328 e4th 220 dot ASM.
You're going to see a bunch of output go flying by and some of the things about the output
you'll see 56 or 58, 50 plus warnings that AVERA generates when it's assembling the
code and that's just AVERA telling you that it's padding out some of those words and it
considers that a warning.
It's pads out the words to make them an even number of bytes as it goes into the board.
Such a quick overview of what's happening in that assembly process.
You're taking an assembly source code and AVERA is processing it into AVERA, AVRA, AVR,
excuse me, AVR machine code and then you end up with an Intel hex file which you upload
onto the board.
That's what's happening when you're doing that.
The source file that you have contains what Dr. Forth considers to be, Dr. Forth.
Dr. Ting considers to be the optimized version of an e4th to run out of Arduino board.
He optimizes it by taking words that could have been written in Forth and turn them into
straight assembly language and then building it that way.
It's described in the book.
Once you've got that hex file you can upload, you can flash the board using AVR2 and I've
got in the show notes two incantations on how to do that and the only difference between
the two is the first one is the one that comes straight out of the e4th book and the
second one is the one that I use because I don't use an external crystal oscillator for
my clock.
The Atmel chip has it built in oscillator to run itself and it makes when you do that
it just eliminates some components that you don't need.
The chip runs a little bit slower but it makes it for a very elegant simple dow board
that also is described in the book.
It's a very minimalistic chip that allows you to run Forth on a, once you pull it out
of the board it's no longer on Arduino.
It's just on a microchip AVR328 processor.
So after you've done that, after you've flashed your board, you can then plug it into the
chip into a computer running some kind of terminal software, serial terminal software and
when you plug it in or reset the board, you can use Arduino IDE that's got a serial
terminal built in.
You should see a response that says 328 e4th space version 2.20.
If you hit return, you should see an okay.
If you've done that, you've done everything right.
You've got now have Forth running on the Arduino board or on them and then you can start
playing around interactively.
And that's one of the things that's in that zip file that you downloaded originally.
I've got all kinds of lessons and lessons to help you learn how to use Forth.
It gives you some of the source for some of the content that's in the book on how to
extend e4th to make it to do some useful kind of fun things just to get started.
It's the book also chapter 45 has a bunch of tutorials on what you can do and what you
can't do with e4th.
So after I got done doing all that, I realized that the one problem with e4th that I encountered
was after I defined a new fourth word when I would reboot the board that those definitions
were lost.
And took me a while to figure out what the problem was and I came up with a very simple solution
by just defining one new word in fourth.
And I came to realize how to fix this problem from the book, from the e4th book.
There are clues in there from the section where Dr. Ting talks about building turn key applications.
So a turn key application would be where you have written a bunch of fourth definitions
for the board to do something, turn a light on, run a motor, make a noise, whatever it
is.
And you want to be able to just plug in the board and have it auto just start that, auto
exec that set of fourth words to do what you want it to do.
And that's called a turn key program.
And there's a way to do that in e4th and it's described in the book.
And in that I realized that what was not happening was the dictionary pointer that the pointers
to where the dictionary ends were being lost across reboots because those were not being
saved into permanent memory, flash memory.
And so there are a bunch of systems variables that are in e4th and four of them are basically
described where the beginning and the end of the fourth dictionary is.
And those four variables are context, CP, DP, and last.
And those four variables are when you read it in the book, those are stored in the flash
memory.
And when you boot up the board, those four variables are copied into RAM.
And then as you add definitions to your fourth dictionary, they get updated in RAM.
But what never happens is they never get re-put back into the permanent storage in flash
memory.
So I came up with the word flush plus.
Now I use flush plus because flush is the word that you use after you've defined a word.
And what it does is it takes it out of sort of temporary storage and puts it into the
flash memory so that you can be used by the chip to be able to be executed in a Harvard
architecture chip.
The code is in one part of memory and RAM is in another and they are not combined.
And so there's this back and forth.
And you cannot run things in flash.
But you use that flash memory to put things into RAM where the chip does all of its work.
That being said, I created a word flush plus.
And flush plus, what it does is after you've defined a word and what's kind of cool is
you can just type flush and start using the word and that's all described in the book.
And if you like what you're happy with how it works, you've tested it, you can then
use flush plus.
And that will save those currently temporary variables, context, CP, DP, and last, into
flash memory.
And then when you reboot, those words will be there again.
Being able to save words across reboots is necessary, I think, because you don't want
to have to redefine these words every time by uploading a bunch of files each time that
you start the board.
You want those words to be saved as you are working on some project, some you're trying
to solve some problem with forth.
So a simple solution, it's a fourth word with just a few lines and save it and away you
go, it saves words across reboots.
So that's how I fixed E-forth to make it run the way I wanted to do.
I still would recommend that if you're new to forth, after all these episodes you've
decided, all right, I'm going to take Brian and Ohio upon his challenge and I'm going
to learn how to use forth on an Arduino board, I'd highly recommend using flash forth.
That's the place to start and then expand your knowledge from their flash forth is a great,
great forth for Arduino boards.
Then lastly, I just want to thank Dr. Ting and the work that he's done in providing us
with a really, really cool open source forth for Arduino boards.
Thank you so much.
So that ends the show, if you have any questions, go ahead and email me or write a comment
in the show notes.
If you are working on a project, even if it's not a fourth project, hit record, record
a show for HPR, we love hearing different things out there when it comes to building things
in hardware.
And lastly, I just want to remind everybody that you're currently going through a difficult
transition period called life.
Thanks, bye-bye.
You have been listening to Hacker Public Radio at Hacker Public Radio.
Today's show was contributed by a HPR listener like yourself.
If you ever thought of recording broadcast, you click on our contribute link to find out
how easy it really is.
Hosting for HPR has been kindly provided by an onstoast.com, the internet archive and
our syncs.net.
Onstoast.com, today's show is released under Creative Commons, Attribution 4.0 International
License.
