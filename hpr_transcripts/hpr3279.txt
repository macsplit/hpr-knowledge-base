Episode: 3279
Title: HPR3279: Linux Inlaws S01E24: Legacy programming languages
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3279/hpr3279.mp3
Transcribed: 2025-10-24 20:06:07

---

This is Haka Public Radio episode 3,279 for EarthNation 25th on February 2021.
Today's show is entitled, Linux In-Loneness 01824, Legacy programming languages and is part of the series, Linux In-Lon.
It is hosted by Monochrome and is about 54 minutes long and carries an explicit flag.
The summary is, the two chats discuss why history keeps repeating itself in programming languages and beyond.
This episode of HPR is brought to you by Ananasthost.com.
Get 15% discount on all shared hosting with the offer code HPR15, that's HPR15.
Better web hosting that's honest and fair at Ananasthost.com.
This is Linux In-Loneness, a podcast on topics around free and open source software, any associated contraband, communism, the revolution in general and whatever else.
Fans is critical. Please note that this and other episodes may contain strong language, offensive humor and other certainly not politically correct language.
You have been warned. Our parents insisted on this disclaimer. Happy mum?
That's the content is not suitable for consumption in the workplace, especially when played back on a speaker in an open plan office or similar environments.
Any miners under the age of 35 or any pets including fluffy little killer bunnies, your trusted guide dog, Ananasthost's speed, and Qt-Rexes or other associated dinosaurs.
Hi Martin, how are things?
Hey Chris, how are things? Things are great and wonderful. Excellent.
Today's episode is all about Martin, upon the special request of a soul of a soul co-host.
Yes, Martin, is there another co-host? What's going on here?
No, this would be you.
Okay.
You put this in, yes.
Yes, brilliant programming languages and their mediocre modern counterpart.
The official title of the show actually was something more like legacy programming languages, but that's okay.
It is, there you go. So what are you going to cover tonight Chris?
Let's talk about legacy programming languages and how they affect modern hipster languages.
Like C, maybe Pasca, maybe Motel or two or something.
You've got to define what's the legacy language in that case.
Anything until you were born I suppose, that makes it mid-60s.
Nope.
I don't think that.
You would define that as we go by it, that's okay.
No, you can't say it's legacy because it's still being used.
Legacy would be something that's normally used.
Well, that's true.
But some of the programming languages that we're going to cover only live in certain isolated biotops, right?
Is that the one I'm looking for?
Ecosystems, yeah.
Ecosystems, probably.
So for example, Cobal nevermind Algo, we're going to cover that in a minute.
I'm not coming Cobal, by the way.
Don't worry about this.
I mean, you would be hard pressed or hard pushed to find anything.
Any application written in Cobal running not running on a mainframe.
Indeed, however, these applications have been running there for many, many years.
Very successfully.
Absolutely.
Absolutely, because the people wrote them along that.
And you'll be, and you'll be hard pushed to find anybody who can maintain the code.
Just take a look at any general ledger on running on a mainframe driving you on a bank, right?
People do a lot in order not to touch the code base.
Any new functionality is normally implemented in systems surrounding these general ledgers.
Because the general ledgers have been implemented about or were implemented rather about what?
30 years ago, 40 years ago, solid code base has been tested to death.
You do not want to change a running system.
Change, so why would you?
Exactly.
So if you make new functionality, you basically put a system in front of it and then this new system.
Does what the what you would normally incorporate in in general ledger now?
No, no, the systems around there are more to.
Like your personal banking apps in the color of nonsense, right?
So it's likely changing the ledger itself.
So yeah, so would you say you say in comments, the legacy language?
Yes, sorry. What was that?
You are saying could all is a legacy language?
Oh, absolutely.
For which and how do you define this legacy languageness?
As I said, legacy language for the purpose of this podcast episode is probably anything that was invented before the 70s.
So are we saying computers are also legacy?
Well, yes.
I suppose.
Oh, dear.
Why?
Well, that's probably a lot of people that would not agree with that statement.
Anyway, it doesn't matter.
It's just a matter of definition.
So for tonight's episode, anything legacy is anything your age and all the.
Thank you, Martin. Yes.
For the purpose of discussion, let's assume that yes.
All right, then.
So.
So Martin is going to cover L goal.
I'm going to cover cobalt.
And that will be the shortest limits in this episode ever.
Because essentially we're done after that.
Oh, we can talk about program language in general.
Yes, because we did a.
A comparison on earlier.
Okay, so.
So let's start actually with plan.
How about which is.
Like, you know, right?
Planca crew.
Why don't we start with the beginning?
I'm just doing this.
Planca crew was actually a program language that is certain Conrad Zoosa invented.
And that ran on a something called a Z3.
Well, this.
Okay.
So this programming language would.
Level the playing fields or whatever you want to call it from a similar, right?
Invented in the, I think early 40s, late 30s or something.
When Zoosa was just putting together set three, essentially in a collection of tubes.
How to get the hell together by wire?
Most people consider it considered to be the first iteration of something called what is known as now as a computer.
I think you'll find there were.
To that.
True.
I don't know.
Now.
As a machine driven by electricity, not, not, not, not some other stuff.
Okay.
Fair enough.
All right.
So.
So let's.
So let's.
An expert.
No.
Because these people would be now 80 years old or something.
I don't know.
Of the same language.
What were the characteristics of this language?
I drive on a Z3.
Okay.
Right.
Okay.
Simplers that.
Of course, we will use find the links in the show notes.
In case somebody wants.
Okay, somebody wants to dig up a Z3.
Emulator and one Plankacool on it.
Hmm.
I don't exist.
Okay.
Cool.
Okay.
Yes.
Before we leave Plankacool.
Actually, as I said, you will find the links in the show notes.
Plankacool goes back to something.
I think it was called.
Bear with me.
Alamda calculus.
Invented in the 30s by I think along the church and student clean.
And essentially.
It's a.
What's up?
What's up?
I'm looking for.
Pretty much like.
Commercial or something to to product.
It was a.
It was a.
A.
Equations over.
More or less.
That ran on the Z3.
Right.
You mean the calculator.
Yes.
More.
Product is a little bit more than that.
Product is a form of the theory.
Improver.
I think.
But we cover that in a minute.
Okay.
Okay.
Okay.
Okay.
What came next?
I reckon Fortran and Corbola pretty much alike, right?
50s.
Yeah.
And.
The idea at that stage was actually.
I think both were developed by by IBM initially.
Fortran was taken over by some sort of committee, I think.
And these are some of this.
I can't remember.
Links, of course, in the show notes.
I don't know anybody wants to read up on this.
How you find the links in the show notes.
The thing is that.
At the time, I think you had.
There's notion of computers looking for use case.
So.
The machines at the time and you are talking 50s here.
And not necessarily just ran by just just build on transit on on the transit.
But rather still kind of working with cubes and stuff.
Or relays for that matter.
We're doing simple calculations.
And the idea behind both behind Corbola and Fortran was actually
to put to to to introduce an abstraction there from a similar.
So Corbola setting for common business oriented language.
And Fortran, I think for formula translator.
The idea was to use something closer to something called the English language.
In order to implement algorithms rather than doing that in sampler.
And the hint with Corbola is in the name.
In contrast to Fortran is what it was much more oriented at.
Not necessarily mathematical equations, but rather batch processing.
Record transactions and all the rest of it.
Hence the name.
Common business oriented language.
Or good name.
Yeah, Fortran obviously being more prevalent in the academic circles.
Fun in our fortunes to use today,
even outside main frame environments.
Because if you take a look at some of the hard performance stuff
that is still written in Fortran these days.
Like some stuff in signal processing for example that you cannot do in C.
Or that you don't want to do in C.
I kind of call some coming across some embedded systems that where people for some reason
chose Fortran over C.
Okay.
Probably has to do with with em floating point of medical sampler this.
I don't know.
I mean, you still can get very performant.
Fortran compilers.
The GNU of course is a front end links on the show notes.
And most of the people consider GNU Fortran as one of the best.
Best Fortran compilers for Linux and other open source system of the market
at this point in time I suppose.
It's an outside the mainframe world.
What are these mainframe Tiki talking about?
They go back to something called the early computers.
I mean, 36.
36 was invented mid 60s.
And they are still an architecture that is still around.
In contrast to all the PDPs 11 of the world, all the taxes they are gone.
But mainframes for some reason have managed to linger on.
I mean, I mean, I'm still makes a lot of money with selling something with selling something called systems e
these days that has been around for the last 60 plus years.
Essentially more or less.
I mean, it comes in in a different package these days and runs links on all the rest of it.
But if you take a very hard, very hard, cold, closed look,
it's still the mainframe architecture that IBM invented in the 60s.
Yeah, let's stay away from mainframes all my life.
But then you are one of these young hipster ones fired.
I am an old hipster.
Excellent.
So Martin brings coffee all day long.
Goes to fancy coffee places if they're open, if they're not.
We can't go there.
No, no, I don't live in California.
And talks about rust.
What's it called?
Julia Kotlin.
All these other fancy languages.
Scala, yes, of course.
So Martin, on to your favorite subject as an algal 68 or algal general anyway.
Yeah, I'll go 68 is the only one.
I'm familiar with not its predecessor.
Anyway, I'll go standing for algorithmic language.
Yes.
Case.
For the hips as amongst us that are not aware of this.
Yeah, so I will succeed first success success at algal 60, right?
So correct.
Also running on mainframes at the time I might add.
Yes, but it's about you can still get a algal interpreter these days running on windows if you're interested.
Absolutely.
A normal Linux.
But what's Windows?
It's an operating system.
Is it?
Okay.
Fair enough.
Do continue, please.
Last time you used windows.
Let me check my records.
Okay.
Yeah, let's check it.
Curious fact.
Anyway.
Yeah, so.
It was a very standard based language of pages and pages of the stuff that.
Nobody knows.
Well, there was a lot of complaints about it at the time and a certain guy was so upset with it all that he decided to make his own language.
Which was the opposite of algal.
I think was he German?
I don't know.
I think he was German.
Are you a friend who?
With.
Worst.
Worst.
Whatever his name is.
No, actually, he's Swiss.
Are you Swiss?
Okay.
Nicholas, but you're talking.
Yes, yes, yes, yes, yes.
So yeah, he.
So what did Mr. Vertu then?
He created Pascal, right?
Yes.
Oh, he did many other things too.
Probably, probably.
Yeah, that was his main.
Yeah.
In relation to algal, that was his contribution to leave the project and start Pascal.
Yes.
Any particular feature or trade that algal, that the algal family of languages is known for or is famous about famous for sorry.
That's quite a few.
I mean, the nice thing about it is, well, there's a lot of nice things about acting.
What is that you can use a proper beginning ends rather than squiggles and all that kind of nonsense, which become completely unreadable.
So that's.
Yeah.
So great language for people who like to type.
Okay, I get it.
Well, okay.
So languages aren't just for people who type, right?
Okay, let's get this one.
So just developing a program isn't the only purpose of programming.
The.
All right.
Well, we can.
That's okay.
Why don't we extend this to the standards of programming that people may or may not have?
Very good, very, very good observation, Martin.
So let's start with the classification, shall we?
So algal is known for some to for trend and global for its imperative paradigm.
Bring capital elaborate or should I do this?
I might be the way.
Oh, why don't you do this one?
Impressive program language is basically means you tell the compiler what to do and what way to do it and the way to do it.
In terms of there's no deduction from the compiler side unlike, for example, a prologue.
It's it's it's a basic construct as in it understands blocks.
That's what you're looking for components compounds.
Compances that word.
So essentially, I think it's one of the lowest levels of abstraction.
You can define in program languages like, for example, you can define functions, you can define procedures.
But in contrast to other paradigms like object orientation on the rest of it, you have to do pretty much everything yourself hence the name.
Whereas, for example, optical program languages know how to do polyformism and encapsulation and so forth.
These are these imperative languages normally don't.
Yep.
Okay.
And now it's never a final.
And we come we cover that in minutes.
Okay.
So I'll go call by and forward.
Now I can would be kind of the three initial examples for imperative languages.
And I'm talking about the original language is not necessarily the add-ons that came later.
Of course, you can get object oriented flavors of both fort and cobalt these days, whether people use them is of course a different story.
And what is also important.
Yes.
Necklace word is famous for two languages.
Pascal namely Pascal and what something called modular to which probably modular.
Yes, which most people are reckoned consider as the success of the Pascal.
Both languages not necessarily were the first ones, but both languages.
Introduced the notion of structured programming.
Because for example, especially modular to and the hint is in the name.
You could at that stage and we're talking late 60s early 70s with Pascal at least modular.
I think it's in it's in the 70s modular to allow you to break down.
A application into modules, which in turn consists of procedures and functions.
And these set procedures and function in terms of consisted of stuff you would normally find in your imperative language.
Like loops, if then else close on all the rest of it.
But the idea behind modular to especially was to introduce modules like libraries and packages and stuff.
That you were then able to use to compose.
And this is now the hint to reuse algorithms.
Yeah.
I can't think of any successes from modular to can you know.
I mean all of these languages were highly influential of what came later like object oriented language and all the rest of them.
I mean reuse is essential.
It's one of the essential notions behind object oriented.
I don't know.
And now I disagree with that. I mean, we use this is.
I'm sure to any programming language.
I mean, as long as we have procedure functions where he's spitting into packages and modules fine.
Yeah, we use is we use right.
So that's, I mean, object oriented paradigm or whatever you want to call it is.
Yeah, to me, it's a bit of a.
Let's have an object and think of all the methods that you can perform on it rather than just writing it.
For progressing further, what difference in an object or language from a structured program or language approach like the different speaking modular to and say small talk.
Small talk in a girl that was.
Small talk.
I've never used that.
This is basically what happens if you fought it with the wrong crowd button.
Oh, absolutely.
Okay.
You find link in the show.
You find links in the show notes, but smart talk about 30 years ago.
Make that 40 years ago was really on Vogue.
Quite a few large code systems and.
As I said, you find the link in the show notes, but there was.
I can't even remember.
But at the time I came across from some large copies that were written in smart talk.
And small talk being, of course, one of the first object-oriented languages developed,
developed at something called I think park, right?
As an example,
Pablo has reached the center.
I just remember it from university.
Yes.
Being a very annoying piece of part of the study that one had.
What is the general notions behind object-oriented language in comparison to other language smart?
Any guesses?
Well, the object defines the methods.
I think that's probably the.
Yeah, that's how I would describe it.
Well, you said no.
First of all, you have classes.
Classes define different levels of abstractions.
Yeah, languages.
Yeah, hierarchy of.
Yes, this is the important bit.
Language like Java, take this one step further, because the original smart talk implementation didn't
allow, for example, to define something called interfaces, where as most modern object-oriented
language is basically defying interfaces or abstract based class like C++ Java and all the rest of them.
The idea behind the initial object-oriented paradigm was to provide a generic class and then derive
more specialized behavior in so-called derived classes.
In example, you have a generic class called fruit and classes deriving from this
basic, from this, from this generic based classes like Apple, like banana, different shapes,
different form, other fruits are.
Other fruits are able to exactly.
Or different.
Very.
For example, yes, or another example would be vehicle, right?
You have a generic class called vehicle, essentially defining methods of member functions as they're known in C++.
Like start, stop, drive, steer, that sort of thing.
And then derived class like car, boat, plane would implement these functions in a different way.
Because planes, for example, do not, well, planes do have wheels, but boats normally don't.
So to steer a boat or to accelerate or slow down a boat would be quite different from doing that with a car.
So the idea is to provide different levels of abstraction through derived classes.
And as I said, the idea behind the general approach was to increase the level of reuse.
So for example, if you have, and the idea was also to encapsulate certain common behavior in said based classes.
And only to implement the differences in the draft classes.
So that you actually, if you want to introduce a third vehicle like a bicycle, you would only have to implement the stuff that is not already present in the base class.
Yep, exactly my point.
And of course, small talk was one of the first language that introduced something like a meta level.
You're creating these all these levels of abstract for three items.
Exactly.
But of course, I'm by go directly from structured program languages to object around the program languages.
We skip one important step of the evolution, right?
And namely function languages.
First example that end at the stage of fun to a program language.
Anything that comes to mind?
There's loads of them, right?
Which was the first one?
The first one.
I don't know, I'm not that old.
He said boldly lying.
But do you know, just can do you know an operating system called Emax?
No.
You don't.
No.
I'm sure you've come across it.
It normally comes in it in the disguise of an editor.
But anyway, it's not operating system.
And that is funny enough that is actually written in this.
Okay.
This goes back to also late sixties, early seventies,
when people had this idea of constructing a computer, including software,
that was able to simulate a human brain in terms of something called artificial and brackets intelligence.
Because this was one of the first languages to implement a software.
And as I said, you're talking MIT, you're talking seventies here.
And function program will introduce something like, for example,
and a number of functions like lambdas.
Everything more or less.
No, no, no, no, no, no.
They already had that alcohol already.
Good day.
We're going back.
Actually, they didn't have them placa crew, but I don't want to eat it.
No, I mean, Lisbon's actually any idea what Lisbon stands for?
We need one older on the show.
I can love it.
One.
One.
And any idea what Lisbon stands for?
It's the acronym.
Oh, not speaking with the limp, you mean?
No, no, no, exactly.
No, it stands actually for something called list processor.
And that's exactly the idea, the initial idea behind it, because the most fundamental data structure in the in Lisbon's actually list.
Okay.
As you had a head off, listen, then you had a tail of the list.
Like a recursive structure.
What if you don't have a list?
You have something called an atom.
Okay.
What if you have a set?
You can implement that as a list.
You just have to make sure that that items don't repeat the list entries do not repeat themselves.
Because there are no such things as to identical items in the list, right?
And sorry, is that?
Yeah, but then we can.
Okay.
Sorry.
Hi.
Yes.
Okay.
The list based language.
And these are still used today, because EMAX, as we all know, is one of the most famous, favorite famous popular, sorry, popular.
And editors that are that are around, I suppose, especially with old school people like me.
Martin, of course, prefers them for some reason.
I don't know why.
Sorry.
Exactly.
But they would be waiting for him.
Okay.
What came after object to wrong get languages, Martin?
Nothing much.
Oh, there's still around quite a lot of object-oriented languages, aren't they not?
Yeah.
Good question.
Scala, Julia.
That's it, I think, for the recent editions, because Go, Lang, Rust would at most best considered to be abstract data type, supporting languages.
I think the Rust people are working on object orientation, but I'm not sure what the exact status at the very moment is, but.
Version 43, 42, at best supported abstract data types, like the original Rust definition.
Yeah, well, anyway, so after the generation of Pascal's and why have you came the fourth generation languages.
But they are there, right?
Unfortunately, so yes, they were.
Well, no sequels in dead.
You say that.
Full disclosure, people.
Martin is a believer in something called postgres.
I'm not saying you're the only one, Martin, I'm just saying.
Yes.
Yeah, being in memory nonsense.
Sequel, of course, would be the example with the exception that proves that that that point that actually most of the fourth generation,
further generation languages are pretty much dead.
Do you have any example of a fourth generation language that is studying some production part from sequel?
That's good question.
It does have up still exist.
What did they change that?
Actually, you have a point because I think it's around.
But put that, put that be a true fourth generation language.
I think it's possible for the hipster to listen to this podcast.
Of course, obviously, of course, would be a program language is invented by is by company called SAP in the 70s.
If I'm completely mistaken, as indeed, as in the first language that SAP used to implement their functionality in terms of ERP and CR model,
rest of it.
Funny enough, they made the move to Java late 90s, I think.
Did they?
Yes.
When they invented something called, there's an enterprise bus in SAP.
It's not that means there's something else.
You find the links in the show notes essentially and that was the first Java implementation that they used to essentially facilitate communication between the different components of an SAP system.
Netweaver, that's it.
Netweaver, yeah.
Netweaver was their answer to proper enterprise service bus as an ESB.
And that was invented, I think, late 90s for set reason.
Because as we all know, SAP systems are not normally used in corner shops, but rather in enterprises beyond a certain size.
Because only they have the funds that is supposed to to to to to finance SAP projects.
Yep.
Hmm.
But apart from all of these filters, there's there's nothing that comes to mind in terms of it's of a fourth generation language that has rights.
Listen, listen, there's a fifth generation here.
Indeed.
What's fifth generation there?
Not a one that comes after four.
Third of any examples, Martin.
I think there were two attempts at it, but still not quite.
I was mainly, yeah, there's that that became self generating code, right?
But hasn't quite happened yet.
No.
So what came afterwards nothing nothing nothing much nothing much new, right?
Well, people keep reinventing the same things.
That's exactly it.
Hmm.
Some some do a better job than others.
So I have to say.
So what's that we'd like to conclude this.
Thanks for listening people.
Seriously, I mean, if you're if you're studying, I don't know computer science or whatever it is,
or any even in secondary school, I think they are shoving Python there.
Everybody right?
And yeah, there's nothing.
It makes more sense to start with something closer to how.
What's closer to December, right?
In my opinion.
Okay.
I mean Python Python is probably good example because it started out pretty much.
Like an object.
I don't know the language and it had.
Lumbars from the very day one.
And but over the last.
Thirty years that language has just been refining things because Python as such, whether it's two or three.
And most people probably will shoot you for it, but if you take a very close look at the car, Python did.
Not bring anything.
Striking you to.
Because all these concepts were.
No, no, no, no, no.
So in the language, they have been around for decades.
Yeah, by the way, same goes for us in Java.
Exactly.
So yes, it's curious.
My events keep repeating itself.
But then.
And people invent language in new languages all the time, right?
I mean, Russ has been around for the last 10 years to 11 years.
Okay.
Julia.
Julia is what, seven years old, five years old.
Kotlin is around the same age.
So probably go, go long goes back to 20 or seven.
If I'm completely mistaken, maybe earlier than that.
But again, from a, from an innovation perspective, what does go along bring to the table?
Okay, third of increased parallelism, otherwise of it, but you had that before.
Occam, for example, rings about, right?
Long that now was, I think, invented in the 80s.
And Occam was actually the answer to the increased requirement for parallelism at the time.
But nobody use Occam anymore.
So again, it's not something new.
Same goes for us.
If you take a look at the multi-princessional facilities that Russ provides.
Yes, go along is not too far away.
And, and other languages come very close too.
So there's no, there's no real innovation there.
Of course, this is a very provocative statement.
If you have different opinions, please.
Back to feedback, I'm a little in love.
Thank you.
Yeah.
No, it's, it's interesting.
I'm what do you need from a language, right?
It's probably the question, too.
I mean, at the end of the day, like, which I like, I like, I like cars, right?
Yeah.
Cars, different to for cars.
Cars get you.
Cars get you from A to B, right?
Problem languages basically abstract from the operating system.
Use program languages in order to avoid to having to implement your algorithm in December,
which is the basic common denominator that most of that most computers understand directly.
Because this is the way they work.
Unless you're going for microcontrollers or transputers or tens of low processing units,
because these would be specialized things, or even just basic GPUs, right?
So, but at the end of the day, if I'm talking about any major CPU architecture,
like, like, cisquants, like, Intel, like, wristbands, like arm, or wrist, V or whatever,
they can order in December, not a big deal.
C comes pretty close to a similar, but other problem languages offer more abstraction layers.
I mean, this is probably the...
I mean, C is probably the good example for the case where people still prefer to be a very closed machine,
because at the very end of the day, C is kind of close to the hardware level.
It doesn't provide an order of a lot of instruction, but if you take a look at the code base that is out there
and placed like it happens or forth, or just take the little operating system kernel,
it's written in C, for reason.
That code speed is now about 30 years old.
And if you take a look at many of the frameworks, like GTK, like QT, they are all written in C.
Yeah, there's a lot of major projects there, also, everything in C, like,
Redis Postgres, you know, as you say, closer to the hardware a bit too.
Plus the fact that you get a very rich ecosystem for C,
other problem language like Python, Rust, and Golang are catching on,
a lot, but the fact is also that the compilers have mature for the last at least 20 to 30 years.
At that time, Golang or even Rust wasn't even invented.
Yeah.
Okay, so what do you look for in the programming language?
Good question.
Probably learning curve.
As on how quickly I can learn the programming language,
never mind the paradigm, because as I said, there hasn't been any fundamentally new paradigms
wrong for the last at least 20 years, if not longer.
The ecosystem, the availability of suitable compiler suites on any given platform.
And what people have been doing for that program language,
and it is how the program language interface to other things.
There are two common denominators around C bindings and of course,
form function interface.
So if a program language doesn't support this, that's probably not for me,
because you always find a borderline case that way you cannot get an existing implementation for,
so at that case, you either have to trust the right to yourself,
or to have to incorporate a different program language.
And early examples for integration approach like the JNI,
the Java native interface, go directly down that route,
because when Java was invented like mid 90s,
there was an awful lot of code already existing written that that was written in C.
So the Java people made one smart move to provide an interface
that would allow Java programs running on the JVM as Java virtual machine
to use that C code base.
With all the disadvantages that that pro chat like not managed code,
sorry unmanaged code rather missing memory section or the rest of it.
Yeah, okay.
Martin, what are you looking for in the program language?
Most of the things, one of the main things is readability, I think.
Easy to learn.
Come and go hand in hand with that.
Interface into other.
I don't personally need that as much as you do.
Not programming any devices as such.
So I'm happy with that.
But yeah, ecosystems, available libraries, etc.
Very.
Yeah, because there is this is all why we use again,
why write something if someone else has already done it.
That's exactly it.
And at the end of the day, program languages are like cars.
Because if I say women, I will get shot.
So I won't say women matter.
Let me elaborate on the car.
Other cars, especially if they're working as functioning,
bring you take you from A to B.
Some cars are faster than others.
Can pack more payload than others.
Some cars are easier to draft than others.
And that's exactly true with the program language, basically.
It depends on the use case.
If I have a challenge at hand, I normally take a look at what's out there already.
And then non-functional requirements come into play like,
how fast has the generated code to be in order to meet the performance requirements?
That the particular use case at hand demands that sort of thing.
For example, if I'm looking for some millisecond latency,
only gives an RSVPU architecture, I can normally safely rule out
interpreter-based program languages like JavaScript, Python,
or it's not a good example list for that matter.
Yes, and I mean, that's obviously C interpreters for Python.
I'm sorry, I'm sorry, I'm sorry.
And friends, so.
If you can.
With the with the job.
I'll ask that is the project spring brings us.
Yes, of course.
Yeah, no, it's it's about it.
And as you say what the use uses,
if you are programming a low latency device,
then yes, that makes sense.
If you are doing a project that doesn't have such a.
Requirements, then you go for the easier approach.
Absolutely.
It depends people.
Yes, so maybe we should start our own programming language.
Why?
Well, why not so you can get the hipster following.
Any any final fail, any final fairway greetings to these hipsters Mark?
As you keep talking about them.
Well, I don't know, I don't.
Yeah, you don't know any hipsters, okay?
I've been to California for a while.
They don't live in the UK, no?
No, no, no, no, they have to live in.
Yeah, we don't have.
I mean, you do have coffee shops as well, but.
Especially that you also have coffee shops in the Netherlands, right?
I believe so, I believe so.
We do drink coffee, yeah.
A long established coffee brand.
Yes.
Very good.
Okay, any any passing, any final remarks before we close off the show?
Yes, so final mark is, I think for the hipsters out there that haven't had the pleasure of programming an outdoor 86.
Do check it out.
I wasn't on 68.
That's why I said there.
Okay, maybe I'm old.
Okay.
Now about the famous episode on problem languages has finally come to its conclusion.
It's time to cover the box.
What's your box?
Well, we can't say it's famous because it hasn't gone out, but yes, it will be famous, I'm sure.
Okay, so my box of the week is a book again, because I do like books.
Well, I have time to read them, but.
There are quite useful for many things, which is called cracking codes with Python.
Ah, finally you do you intend to learn Python once again?
No, no, no, it's just a little bit of a hobby.
You just have to crack codes, that's okay.
Yeah, this is a long time since I learned anything properly, I have to say.
Yes, yes.
Well, this is the beauty by Python, you don't have to learn it.
If you don't, okay.
No, it's great.
It just writes itself.
Just works.
Excellent.
Okay.
What is your box of the week, then, Chris?
I don't have any, but before we go to my petty antiprox, why don't you elaborate a little bit on that book?
Okay.
Right.
So this is a, well, as the title says, are you interested in cracking any codes?
Well, you know, obviously there are many different coding algorithms as in algorithms to create codes.
And should you have a powerful GPUs at your disposal, then this comes in quite handy to calculate various things you might want to find out.
Crack-and-code means like a good first attack, like pass for correct.
Yeah, but then you're different.
And how, where do the GPUs feature?
They are installed in a machine called computer.
Yes.
I get that, Martin, but that book covers the unknown.
Of taking Python source code and translating that to something that the CUDA interface can understand.
So that the GPU can execute the code.
This is a theoretical book, right?
So.
That's implementation.
See.
So why does it, what is it called?
Basic Crack-and-code with Python?
Because it covers various coding algorithms that you can implement and decoding algorithms you can implement by some.
Okay.
I thought it wasn't about the implementation.
Not only in preparation on GPUs, indeed.
I'm sorry.
Okay.
I got lost.
As I usually do.
I know it's very confusing.
It is indeed not.
It is indeed.
And links in the show notes, of course, if I can find this book.
You need to have a future with the GPU in it one day, maybe.
I do have prop computers with GPUs in them, yes.
That is a non-chip GPU.
I think I have one or two, yes.
It is a great GPU built into the path of Cardians.
Thank you.
So there are, on which century there are lots of.
Last but not least.
All right, okay, onto my, onto my, onto my, onto my
empty box, courier authentication team people, if you're
listening, please do something about the debunk level. Last, I,
I ventured last weekend to tell my postfixings to use the
authentication team that comes with courier to authenticate
people when they want to send emails and it took my way too
long to properly get to the bottom of the issues that I was
facing because of the deeper information that the authentication
team didn't provide. As a matter of fact, eventually I had
to absorb to estrace to see what was going on on the system
call level. And that's not how we should have to do, there was a
reason episode on this one, yes, but it may come as a surprise to
your short news, brother Martin, that estrace and myself have
been friends for at least the last 20 years. So, 2020,
hmm, interesting. So, I'm a courier people if you're listening
get in touch and I give you some means of how to do it better
or I may even submit a poll request at some stage. And with
that, we are almost at something called the feedback.
Or I mean, almost, well, almost, we are the feedback.
Yeah, the feedback is indeed we are.
Okay, let's start on something.
And the feedback. Yes, feedback.
That's E01, E21 feedback. And yes, feedback, a guy called
another guy, but rather one of the, one of the indicators are
no, and one of the HPR hosts by the name of operator comments on
the last, the previous but last, no, on the second last show.
It's 2021. Yes, thank you, wrong.
We think in great show. And the rest is, it's technical,
details like, no, we've got kernels that I like a terabyte and all
the rest of it. He also just covered net hawks and Linux.
And of course, he's a big TMAX fan as in the terminal multiplex, but then
people who isn't right, who is behind the 25 years of age stage.
And of course, he sent that email to something called feedback at
Linux in lost, are you? People, if you have feedback.
No, sorry, sorry, of course, you're right. He posted that on
heck of public radio. My mistake operator, I do apologize.
Yes, he posted on heck of public radio. And I could, of course, he could have
sent this to feedback at Linux, and those are the you.
But both ways are welcome in terms of how to get in touch with us.
And the email addresses feedback at Linux in lost at the you, but you can also
like, operated it, post a comment on the HPR website on the episode.
And with that, we'd like to thank you for listening and keep on coding.
Any final remarks? One of your set, Martin, before we close off the show.
Oh, sorry, keep on coding. Sounds good. Keep on commenting. Keep on feedbacking.
Yes, keep on listening. Excellent. This is the Linux in lost.
You come for the knowledge, but stay for the madness.
Thank you for listening. This podcast is licensed under the latest
version of the creative comments license type attribution share like credits
for the entry music go to blue zero stirs for the songs of the market to
twin flames for their peace called the flow used for the second intros.
And finally to select your ground for the songs we just use by the dark side.
You find these and other details licensed under cc at Chimando.
A website dedicated to liberate the music industry from choking copyright
legislation and other crap concepts.
You've been listening to hecka public radio at hecka public radio dot org.
We are a community podcast network that releases shows every weekday Monday through Friday.
Today's show, like all our shows, was contributed by an HPR listener like yourself.
If you ever thought of recording a podcast, then click on our contributing
to find out how easy it really is. Hecka public radio was founded by the digital
dog pound and the infonomicon computer club and it's part of the binary revolution at binrev.com.
If you have comments on today's show, please email the host directly, leave a comment on the website
or record a follow-up episode yourself. Unless otherwise status, today's show is released on
creative comments, attribution, share a like, 3.0 license.
