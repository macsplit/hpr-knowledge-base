Episode: 1811
Title: HPR1811: Life and Times of a Geek part 2
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1811/hpr1811.mp3
Transcribed: 2025-10-18 09:36:50

---

This is HPR Episode 1811 entitled Life and Time of a Geek Part 2 and is part of the series
how I found Linux.
It is hosted by Dave Morris and is about 43 minutes long.
The summary is part 2 of my personal story of experiences with computers.
This episode of HPR is brought to you by an honesthost.com.
At 15% discount on all shared hosting with the offer code HPR15, that's HPR15.
Better web hosting that's honest and fair at An Honesthost.com.
Hello everyone, this is Dave Morris.
Today I want to tell you the next installment of my personal story, which I've entitled
Life and Time of a Geek.
In the last part of the story, I told you of my experiences as an undergraduate student
at Aberystwyth University, where I started using a mainframe computer and learnt a program
in the Algole 60 language.
Today I want to talk about the next stage, where I left Aberystwyth and became a postgraduate
student at the University of Manchester.
I had a wonderful three years at Aberystwyth and I think I said a little bit about it last
time, it's a lovely location by the sea with access to all sorts of great areas and landscapes
perfect for a biology student.
I'd agree involved a fair bit of zoology and of botany in the first stages and then
specialised later, so we went out and about quite a lot.
I could go into a lot of detail about the forays to the tidal areas outside the university,
looking for strange creatures and the tidal gone out.
I could talk about the woodlands searching for fungi, about the mountains, climbing the
mountains, look for strange things, the salt marshes, the bogs, there's quite a lot of
boggy areas in that part of the world.
I could tell you about some of my fellow students like the one who used to bring her pet
jack door to lectures along with a border collie and so it's quite disruptive when they
came along.
I could tell you about the day that friend and I were trying to do something with a rat
which was incredibly fierce and ran in, jumped out of the cage into the lab, caused 30 students
having to jump on chairs and table to run out of the room, but maybe that should be
another thing.
This is Hacker Public Radio after all, not Zoology Public Radio.
Anyway, suffice it to say that as I got to my last year and we needed to specialise,
my interests were in the area of animal behaviour.
I did a project on memory in goldfish and I had to train them to perform a task, then
apply a drug to them which prevented the formation of long-term memory and proved that they
had forgotten the task while the control group which hadn't had this drug, hadn't forgotten
it.
So I got a pretty good degree in on his degree, I should say, these things are important.
I don't know why really, but there you go.
I got a degree anyway in Zoology in the summer of 1972 and then was faced with what
to do next.
I considered developing the programming skills that I've been using in some sort of biological
context and I applied to a few places with the idea that I could take some sort of further
degree which involved the two, possibly moving into the direction of computer science.
But it was very hard to find anybody who wanted a zoologist who'd done some programming
dabbled in it a bit and so I think maybe I should have worked harder to achieve that
but I didn't do that.
I started looking for a possible place to do a postgraduate degree.
I was offered a place to study for a PhD in the animal behaviour group at the Zoology
Department at the University of Manchester.
Now funding in those days was by grant and I'd had a grant from my local education authority
which is the way it was done and had that for my first degree.
So I needed funding for my PhD but I couldn't find a grant to do it so the only real choice
was to put my studies on hold and go and see what I could do to fund myself.
So I headed home and tried to find a job to do that.
Once I was back home I found a job by the simple experience of knocking on the door of various
companies.
I think I went to what they then called a labour exchange.
I found a job in a local plastics factory where I'd worked before during vacations and
ended up as a labourer doing shift work earning the princely sum of 50 pence an hour.
It seems ridiculous now but there you go, it was pretty much the going rate for this
type of thing unschooled labour and by this method I managed to accumulate enough to fund
myself for my first year of a PhD.
While I was researching stuff but to do this talk I happened to be going through various
files where I found that I actually kept my employment contract with this company.
United Glass it was closures and plastics limited and I included a copy of my employment
contract, basic rate of 0.4167 pence per hour.
And a shift pay supplement, it's pretty amazing, eh?
So average paper week 19.71 and it was two shifts, I did two shifts and I had to work
on Saturday mornings too.
So yeah, it's okay though.
I was actually in the, just in case you wonder why it says your department is grinding.
It looks great now.
This was the bit of the company where waste plastic and misprinted stuff was recycled, there
was a big machine that ground it all down and then another device that melted it back
into pellets so it could be used again in the moulding machines, the blue moulding machines.
That was heavy noisy boring work because I've written it, it was okay, it got me where
I needed to be.
So in the summer of 1973 I was in the city of Manchester and the University of Manchester,
one of the largest universities in the UK and I was there to take a PhD doctor of philosophy
degree doing this research in animal behaviour as I mentioned.
My research topic was to be looking at how animals decide how to feed, wet, look for food,
how much effort to expend, finding and eating it, that sort of thing.
At the time this area was referred to, it was a growing area, it was an area that a lot
study was being put into and it was referred to as feeding strategies or optimal foraging
in various other names.
This area grew into the early 80s and became what's now known as behavioural ecology and
mathematical methods, particularly ideas for economics we used to describe and predict
animal behaviour.
And as I mentioned in the notes in a recent programme on the BBC, the Radio 4 is a series
called In Our Time, where they did a great job of covering this subject, interviewing some
of the round table discussion with some of the movers and shakers in this area.
I'm hoping that if you're interested in this, that you can see the episode and give
you a link to it in case you can do so.
So here I was, a member of the Zoology Department, which was then a separate part of the university's
separate entity.
It later became subsumed into the School of Biological Sciences, but that was well after
my time.
It was an old department from being established in 1870 and it had, it looked, the rooms
and the labs had that sort of feel, which was nice.
It was all oak panelled and quite old benches and that sort of thing.
In 1973, the department was in a beautiful old building down the road, actually adjoining
connected to the Manchester Museum.
And as a postgraduate student, we were given keys to the lessons of building and all sorts
of hours that we needed to do work.
And we also had access to the museum, which was quite an interesting concept.
The museum is quite a nice place, it's quite still going very strong, it's been refurbished
quite spectacular.
And in those days, it included live animals amongst its various exhibits, which is unusual
for a museum.
So my PhD supervisor, two other students who were starting at the same time that I was
also doing research and animal behaviour, two of us were studying the Barbary Dove,
which I've referenced in the notes, as our experimental animal and the other one was
using common mamasette.
So we were often spending our time in the animal house in the basement of an old building
near to the Asology Department.
The usual way that postgraduate students worked in those days, at least in Manchester,
was that you started your research project by doing a literature review and then writing
it up for a system.
I think this is a sort of filtration process to pick out the real duffers from the boy,
ones, and so in my particular case, it meant reading through any of the relevant journals
that covered my particular subject in the University Library, but particularly we needed
to read through a thing called Current Contents, which is a magazine, a small journal thing,
which I can't remember how often it came out, maybe weekly, which contained a summary
of all of the publications produced since the last one, which you could find in peer-reviewed
science journals.
So you didn't actually see the paper itself, you just got a title in a quick summary.
If it looked interesting, then you could either get a photocopy of it through the interlibrary
loans, which cost money sometimes, I think, or I think the University covered a fair
bit of it, or if that wasn't possible, you could write to the author, of course, addresses
were published willy-nilly in this publication, which seems unheard of nowadays, and you
could write to them with a physical letter on a bit of paper to ask for a reprint, and
then they would, if they wish, and mostly they did, they would send a copy of their paper
to you.
This was a slow and laborious process, though as I recall, whenever a new paper came
long in the post from somebody who you'd requested it from, it was quite an exciting event,
you know, this was really bleeding edge of the subject.
Obviously, the purpose of doing this literature review was to become highly conversant with
the subject, and as up today as possible with everything that was going on.
This required the keeping of a good collection of references to papers and reprints, and
the way to do that in these days was by keeping a filing system.
So I started by keeping a box file full of index cards, kept them in alphabetical order,
they referenced the papers, the authors, the summary of the contents, and that type of thing.
There wasn't really much else to do in those days.
My supervisor introduced us to a slightly more advanced technology.
He gave his three PhD students a bunch of edge-notch cards, and these have holes punched
around the edges, and then you can get a special tool which cuts out, cuts a notch over the hole.
We didn't have those, we just used scissors, and this differentiated them from other cards,
and the principle is that the cards relevant to a particular topic, and you organize this the way
you see fit. The relevant cards will be notched in a particular position, and so when a deck of
cards put together, passing a needle or metal rod through a relevant hole, and lifting out all the
cards which didn't have notches in, would mean that the ones that were left were relevant to
a search. So this is a very so primitive searching technique. It could be a little bit more sophisticated
in that you could put more than one needle or rod through the holes, and lift out cards which
matched several criteria at once. This was a sort of mechanical database. I don't think any of
us actually used this to any great extent, because it seemed far too much of a fiddly thing to do.
We just get stuff on regular index cards, you could buy in any stationers. Now, the University of
Manchester was particularly strong on computing, had been for quite some time. Just across the road from
the Zoli department where I was was the School of Computer Science. What was to become the School
of Computer Science? This was a newly built building called the Killburn Building, which was
sort of cool and new looking. It doesn't look anything very special now. There's a picture of it
in the notes. This contained computer science, but on the ground floor it contained
the University of Manchester Regional Computer Centre, which was colloquially known as Umrock.
This computer centre was one that had been government funded to provide high power computer
facilities for universities in the region. So the Umrock provided facilities, services for all
of the universities in the north west of England. So that was Southford University, just down
the road with in Manchester, Liverpool, Keel University, Lancaster. There's a similar one in London,
ULCC, University of London Computer Centre, which was another large one. There was really only
two very large ones. This is another one at Edinburgh, but it wasn't quite as big as I recall.
There wasn't a tremendous amount of inter-computer networking going on at this time.
People who wanted to use Umrock, who were not in Manchester, not at Manchester,
University could get access to it through slow modem links, mostly, I think, and they had
remote job entry facilities at the satellite universities. I'll talk a little bit more about
these later in the next episode of this, I think, because I found myself at one of these universities
and was able to investigate this stuff. So it wasn't much in the way of networking, I think,
it's really the point. At this time in the early 70s, UMRCC had a controlled data
corporation, CDG 7600, which was pretty much a state of the art computer, mainframe computer.
It was front-ended, this particular one, by an ICL 1906A, which I'll talk a little bit more
on later, about later. The CDC 7600, quite an interesting machine. It was one of the machines
designed by Seymour Kray, who also designed the Kray 1 later on, and it was considered to be
the fastest supercomputer in the world at that particular point. I don't remember much about what
it ran in terms of an operating system. I think it was something called scope, but I have had
great difficulty finding any records of this, any stuff I had from those days I've thrown away,
so I don't remember much. It certainly was, there was very little interactive access to it as
I recall. There was interaction available through other machines, but basically it was a big number
cruncher sitting in the background that you got access to through other things. The 1906A,
the ICL machine, I know, ran an operating system called George. I'm not sure which version George
3 or 4, I don't recall, but it probably was George 4 because this model had paging memory,
which George 4 was designed for. I'm going to say more about the George operating system later,
so I want to go into a lot of detail here. So pretty obviously being a computer geek in a
biology department, I was keen to get access to these machines because I could as a student
and soon started using them and learning about them. The main workhorse, of course, was the 7600,
since this was the big number cruncher. Though the ICL 1906A was also a pretty powerful machine in
its own right, but was largely used as a gateway by me anyway. As before, programmes had to be
written on coding sheets and then punched onto onto cards and the main difference was that
at Umruk you could do this yourself if you wanted to or you could send in coding sheets and
it would be done by by staff whose job was data preparation as it was called. There were
teletypes available to us connected to the ICL machine, but I won't talk about them just now.
I'll leave that till later, maybe the next instalment, I don't know, in large on this, there's a lot
to say about this. So I've put a picture of the IBM card punches from those days. What we normally
did in those days was we would write things by hand on coding sheets, hand them in to be punched
up and we would ask for them to be checked. They would go through the card punch and then they'd go
through a checking. Another person would run through another device which was effectively retugged
it all over again, but it didn't punch them again. It just checked for errors. There would also be
sometimes I think there was a machine that did the interpretation. That is they typed the contents
of the card on the top of the card so you could see what it was and there were things like card
sorters. If you haven't had dropped all your cards on the floor and you had gone to the trouble
of asking for them to be numbered sequentially. I mean you have a number punched into in the
from column. Can I remember 78 onwards maybe? No, that wouldn't be enough with it. 76, 75, I can't
remember. Anyway, the tail end of the card would have a number on it, sequential number,
and that would be generated by device. It's part of the production process. If you'd done that,
you had a big deck and you dropped them, then you could ask them to be collated and I'd be
sorted back into order again. One of the things that fascinated me about the computer center was
the viewing gallery. Access to the the unrupped part of the building was through the ground floor
entrance and on the way in you walked through a corridor with a glass wall looking into the
computer room and in it was all of the hardware, all the main frames, the tape drives, the card
readers, the line printers and so on. There were computer operators in and out of their
putting cards in, taking printouts off, etc. You could see them, they were white coats to
seem very odd now in these days. There are two videos I discovered which are available on YouTube
that I've linked to. They were made a bit later on in the 80s. At the time these videos are made,
there were two 7600s and the ICL 1906A had been replaced by an amdow machine as a front end.
There's quite a lot of superfluous stuff in those videos but you can see quite a lot of
of views into that machine room which is big and it's not that different from the way it looked
in the 70s when I was there. One of the things that fascinated me about the building was
it was heated by the computers that stage. They had I think they had free-on cooling or something
on the on the big machines but the waste heat was used to warm the building and I was there during
the minus strike in the 70s where there was the government put a three-day week in operation
where a lot of businesses shut down, people were made to turn off their lights and turn
off electrical equipment. While Umrup was not shut down because it was more than just a building
with computers in it was actually driving a lot of facilities, a lot of services for universities
in the north west of England. So it kept going and there was one of the few buildings that was
warm because it was heated from these machines. Remember people coming in and complaining about
the waste of heat in there but it wasn't really a waste it was actually quite an efficiently
design building. So at this point I found that the programming language is available to me
were how called 60 was there as before and I did use it it was it was different um it was this
was on the 7600 on the CTC machine. Our goal was pretty much like a common language across
many systems in those days but um I also discovered Fortran which was available there and uh
started thinking thinking that this would be useful to me as I tried to uh to carry on with my
research not having anything specific in mind in the first instance I thought it would be worth
at least learning the basics of uh of the language so I taught myself Fortran found it to be very odd
compared to alcohol 60 statements have to go into particular positions on a card start in column
seven up to column 72 yeah 73 and 70 to 80 the ones I didn't remember before other the the
collages for sequence numbers if you want you didn't have to do that but you could do if a
statement had to be continued onto a second card and then you needed to get something
punched any character punched into column six that was a continuation column and columns one to
five of the card contained a numeric label which was used for um if you used a go-to statement
that was the target of the go-to and it also contained um numbers for uh format statements
I'll talk about in a moment if column one contained a C and let a C then that made the card a
comment card and this was Fortran four um you can see an example of Fortran four program and the
wiki book site that it was quite primitive compared to what Fortran became this this was like
the earliest version of Fortran I think or at least one of the earliest versions one of the
weird things about Fortran and the IO stuff this this was in my opinion you can see format statements
in this example that define input and output all of the format statements are collected at the top
in the example on the wiki book site though most people that I or most programs that I saw they
were placed after the right statements they were associated with or indeed the read statements so
I've got an example just to talk a little bit about what it what it does and um in my example in
the notes I've got a format statement which has got a label of 601 on the front of it and uh it
defines how stuff is to be written is followed by a right statement and the right statement
is followed by is the word right followed by a bracketed pair of numbers the first one is the
output device which the actual devices tended to be sort of semi-standard or they were
they could be configured on the particular machine you were working on I don't remember much
about this now I know there were job control statements that you could put around your program that
said associate channel x with a file or the line printer or something of that sort anyway this
one is writing to to to channel six device six I suppose you'd call it and the second number is
six or one which is the format statements to be used this is then followed by four variables abc
and area then the format statement that does it that that controls it is a bracketed list of
things are separated by commas the first one says four h space a equals space comma so that's
that's a thing known as a um holerith format and this was a way in which you simply defined
some text that you wanted to be written out the four before the h means this is holerith this is
some text holerith was one of the inventors of punch cards I think and it's quite why h was chosen
for this I don't know anyway sure there's a there's a deep history there here which I don't know
about the form defines the number characters that are to be written out so we've got a space and
a and equals in another space so that's what a holerith statement does then the next thing is
i5 now i5 is an integer you don't guess that I'm sure which will be five columns wide and
that should correspond to the first variable that's being output and after that five h two spaces
be equals space then another i5 and so on I'll leave you to examine it a bit more detail but
the real the real point of it is that there are i formats for integer numbers there are f formats
for floating point numbers so f ten point two means ten columns wide with two decimal places the
holerith thing he had always had to count a number of characters there that followed the h and
was always a pain so one of the things that always used to catch me out and I've seen so many
people fall into this one so I thought I'd just mention it here the first character defined in a
format statement when you were outputting stuff had special significance so these were the days
when you were using line printers for your output and it actually had an effect on other devices as
well but let's think about line printers line printers received strings of characters which are
most cases 132 columns wide most line printers were that wide they needed to be told what to do prior
to printing a line so a line was printed on the fancy printers all in one go there were there were
there were print 132 print positions all of which went bam and printed simultaneously pretty much
and they the first character of the line that was sent has this special significance to indicate
how to position the paper prior to printing the line so there were various characters that had
particular meaning so a space as the first character meant to advance to a new line before
output a zero in that position advances two lines so you got double spaced output a one
advances to the top of a new page and a plus character won't advance at all so you could overprint
so the first thing that you wrote in an output statement would not be visible on the paper because
it was interpreted by the the firmware of the printer to determine how to position the paper
and one of the pitfalls that that I certainly fell into and saw many many many students do this
later on in my career using Fortran was to output a number as the first thing where the first
digit was interpreted as this printer print a feed thing if it was you know two to zero to
to nine or excluding the one then would have certain effects sometimes there were other effects like
I can't remember them now two three or whatever might have controlled the number of lines
it skipped or something like that it depended on the printer I think the convention the standard
convention was if you if you had a number which began with a digit one then every line would be
thrown would would start on a new page so you the printer would could be seen throwing
huge amounts of paper out putting one line of numbers on the top of each page which would drive
the operators completely nuts you know they go through a whole box of paper just to print something
out because you'd forgotten to do this business of starting the the output line with a with a space
so very very strange stuff it seems very odd by today's standards one of the reasons why
you'd want to use Fortran but from the fact it's a pretty damned efficient in the scale of things
very efficient language was that there were many many libraries available so in particular the
numerical algorithms group known as NAG had a library which did lots and lots of numerical stuff
I gave them a link to to their current incarnation so we had things like random number generators
and statistical methods and matrix manipulation things in it so you'd want to use these
to avoid reinventing that particular wheel obviously so that was the reason why I was
tending to use Fortran so I could do this type of stuff so also around that time I don't remember
precisely when I started getting into it I discovered the language Pascal it had only recently come
out it was only two or three years old it's quite similar to our goal 60 and in particular the one
of the early implementations of it was written for the CDC machines not the 7600 I think there was
a precursor to that there was written for but obviously it was available on the 7600 I got hold of
the very early book written by Jensen and Werth Werth was the Inventory Pascal and this was
I just remembered no it was a very old book which looked like it had been printed on a
on a typewriter or even a tele printer and somebody had gone through and hand written in various
bits and then I've left it I've got another book here in the house which was a later book in the
in the 80s I think it was which also about Pascal which also has looked like it's printed on a
teletype and it seemed to be a thing about cheaply produced books produced in that sort of way
in in that era along with that but it's just something you tend not to see quite so much
I don't seem to have the Jensen and Werth book anymore I think I must have lent it to somebody
and it never came back or possibly I am so amazingly untidy it's lurking
under a pile of books somewhere other in a corner somewhere shame because I would have liked to
put up a photocopy of it a picture of it in the in the notes anyway Pascal was an interesting
language at the time because he had some quite innovative ideas in it even though similar to
our goal 60 in many ways had some advancements which which our goal 60 didn't I did learn how to
use it so taught myself how to do stuff with it and wrote some programs in it but it didn't seem
to be very practical in relation to Fortran no libraries available for at that time and you couldn't
do many of the things that you would have expected to be able to do from the design I thought I'd
just digress briefly to talk about Pascal I won't go into a huge lot of detail because that could
be a whole series in itself one of the weird things about early Pascal was that when you declared
stuff in it that the whole the program started with the the statement program and a name and Ben
was followed by declarations and the declarations had to be in a particular order labels you get to
define your labels which were targets of go to statements though you were strongly discouraged
from using go to in Pascal it's meant to be a structured language therefore no go to then there
were constants where with identifiers which had permanent values associated with them we couldn't
change constants once you'd declared them with types which allowed you to define new data types
variables which are identifiers which are of the various types standard types and ones that you'd
created earlier and then functions which were subroutines that return a value and procedures that
subroutines that don't return a value and they had to be in this order these restrictions were
lifted in later versions of Pascal but that's the way it was when I first encountered it you can
define types based on existing types of Pascal so I've got an example where there's a type bite
which is being defined as an integer in the range 0 to 255 and there's a subrange declaration 0
dot dot 255 available so you you can define subranges of the type integer this particular one was Pascal
also contained sets which was something of an innovation at the time nothing else had this
capability so I've given an example here of a variable declaration of a set capable of holding
any lower case letters so it's the name of the variable letter set I called it which is declared
as set of a as an a in quotes dot dot z in quotes so it's defined as being able to hold anything
in that set and then you can do expressions like if a in letter set then so a is in quotes again
so you it's a quite an efficient way of determining whether a set a certain value was in a set
and there were other other things that you could do unions and and that type of thing all the
various set operations that you that exist in the language and that's actually quite powerful
the word issues with the implementation of this in the early days it wasn't possible to define
sets containing very large numbers of members since underneath a set was defined as a as a sort of
bit array of bits so you would be represented as a bite so you could have eight eight eight bits in
there or a word depending what your word length was or a long word or something of that sort
different length of words but there would be hardware limits most cases to how big these things
were and there was an assumption that the the thing representing the set implementing the set perhaps
could be loaded into a register and bits could be then be checked or set or unset or whatever
within that that data structure so sounds great it looks good but the implementations are a little
bit lacking of that stage because I tried to use it and found no it wouldn't do what I wanted to do
can't remember exactly what I tried to do but certainly found that there were limitations and there's
also capability to define more complex data types called records in Pascal this is
similar to the way that you could find similar things in in C for example so I've got an example
here of defining a type called dates which is defined as a record a record begins with the word
record and ends with an end and in it there are three numerical items one is called day which is a
sub-range of integer in the range 131 month which is another sub-range in the range 1 to 12
and year which is another sub-range of integer in the range 0 to 9999 just as an aside there you'll
see that statements are separated in Pascal with the semicolon Pascal was quite fussy about
probably still is to some extent fussy about pointing out that these were statement separators they
weren't this wasn't a thing that showed the end of a statement it was merely a separator so you
weren't supposed to put one at the end of the the last element in the record as you see the 9999
is not followed by a semicolon it wasn't actually wrong and I don't know why anybody made such
fuss about it to be honest with you but it's a bit like you don't put a comma after the last
thing in the list if you're writing English so it's that sort of thinking went into it and in
example there's a variable called today which is set to define as I should say a type the type we
just declared dates so you could then access elements of this today record I think I'm not going
into detail in that you can find quite a lot of useful information about the structure Pascal in
the Wikipedia article I've pointed to so if you want to dig deeper into Pascal and you can get
to it at least have a look at it check the flavor of language through that route again there were
issues with data types like this in early early iterations of Pascal for example you could
declare files you can say a file declare a file which contains date records so the syntax
is something like file of dates that would be acceptable but when it came to actually implementing
that if you say okay here's a file of dates I want now to open it and write stuff to it read stuff
back there were issues in whether the underlying operating system could actually implement these
things in a sensible way and there were certainly issues with some of these file types and data
types within them being really difficult to to implement and not available in some instances of
all these sort of wrinkles were there in the early dates that mostly smoothed out as the language
developed the Pascal became popular for teaching which is where it was originally designed for
and later became much more effective as a as a language as it matured and the definition changed
and better more comprehensive implementations became available I didn't use Pascal much this time
but later on my career made pretty heavy use of it for many years actually so I'll talk a bit
more about Pascal later on so that's pretty much it for this episode this is Gotters is from Aberysteth
to the guts of the computer systems in Manchester I'll talk a bit more about this the computer systems
and what I did with them in the next episode but otherwise that's us for this time okay goodbye
you've been listening to hecka public radio at hecka public radio dot org we are a community
podcast network that releases shows every weekday Monday through Friday today's show like all our
shows was contributed by an hbr listener like yourself if you ever thought of recording a podcast
then click on our contributing to find out how easy it really is hecka public radio was found
by the digital dog pound and the infonomican computer club and it's part of the binary revolution
at binrev.com if you have comments on today's show please email the host directly leave a comment
on the website or record a follow-up episode yourself unless otherwise status today's show is
released on the creative comments attribution share a light 3.0 license
