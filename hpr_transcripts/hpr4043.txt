Episode: 4043
Title: HPR4043: Uncommon Commands, Episode 1
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr4043/hpr4043.mp3
Transcribed: 2025-10-25 18:57:21

---

This is Hacker Public Radio Episode 4,043 for Wednesday 31 January 2024.
Today's show is entitled Uncommon Command's Episode 1.
It is hosted by Delta Ray and is about 10 minutes long.
It carries a clean flag.
The summary is a summary of the three command line commands, look, shove, and X orgs.
In the Unix world, we are mostly familiar with core commands that we use daily, such as
LSCD and perhaps with more fear commands like RM and Vi.
But there are hundreds if not thousands of commands that will help you accomplish
nearly any task.
Hello, I'm Delta Ray, greater of the CLI Magic Social Media Account, which you can find
on Mastodon and Twitter under the name CLI Magic.
In this series titled Uncommon Commands, you'll hear about lesser known commands and
how they can help you your workflow and make the terminal a more enjoyable environment
for regular use.
The first command I'm going to look at is called Look, L-O-O-K.
The name is a little bit misleading because the command is often used to help find words
and they're spelling.
You can give the look command an argument of just a few letters and it'll give you all
the words matching that start with those letters.
This way, if you're not 100% sure of the spelling, you can start with just what you are
sure of and hopefully find the word that you're looking for.
I guess that's why it's called Look as in Look Up.
However, although the command is often associated with looking up words in the dictionary, its
man page tells a different story.
The one line description simply describes it as display lines beginning with a given
string.
Basically you pass a string to it to search for and one or more files to search as arguments.
What the man page doesn't really tell you is if you pass just the argument of a period
character as a string argument, it will print out all the words in the dictionary.
This can be useful in certain cases I'll talk about later.
The look command was originally written for AT&T's Unix version 7 back in 1979.
The modern version comes with the BST Manutils package and the source code indicates that
it was originally written in the late 1980s, early 90s, by David Hitz of OSPEC Systems Inc.
OSPEC Systems was the first company to make a NAS device and David Hitz went on to
found a well-known storage company called NetApp, so this little command has quite a history.
The look command is a great little utility and of course doesn't involve using a search
engine or website with advertising to use it, unlike a lot of other word look up dictionary
sites you find on the web.
The next command that you might not see a lot of usage of is the Schuff command spelled
SHUF.
The Schuff command shuffles lines of input randomly.
Let's say you have a list of people's names in a class and you want to randomly order
them to see who the lucky person is that's going to be the first to present their book
report.
You can run Schuff on the file that contains the names and generate a random order of
students.
Like most Unix commands you can also pass the names on standard input instead of providing
a file name to it as an argument.
It also provides some options including the ability to generate a random list of numbers
using the dash i option.
The dash i option takes a number range starting at low and going to high.
So for instance the range 1-20 would give you a list of numbers 1-20 in random order.
You could easily generate a digital 20-side dice by piping this into head, dash 1, to take
the first number that appears on the list.
Oh, 20, critical strike.
You can also use Schuff's dash n option to simply print out the first name by using
dash n space 1.
Now whenever I talk about the Schuff command, someone usually brings up the point that
the sort command has a dash capital R option that will randomize the lines.
However it is important to understand that this dash capital R option to sort works differently
and that it will group together identical lines.
So if you have two lines that say Fred, it will always keep those two lines next to each
other regardless of where Fred is placed among the other names.
So you'll always have two threads in a row.
This behavior might not be what you want, but could still be useful and isn't something
that the Schuff command does on its own so they both have their uses.
The GNU version of the Schuff command was written by Paul Egert and is part of the GNU
Core Utils package.
So you're very likely to already have it if you're running Linux.
It first appeared on the scene in mid 2006 and was part of the Core Utils version 6.3.
So it's not that old as far as command line tools go.
And finally in this episode we have the XArgs command spelled XARGS.
Sometimes you find yourself in a situation where you need to pass lines of input as arguments
to a program.
But limit the number of arguments that is passed each time.
This is what the XArgs command is used to accomplish.
Have you ever tried moving a bunch of files in a directory by using an asterisk as a
wildcard only to have bash tell you that there were too many arguments?
Well this is one of the reasons why XArgs exists.
You can instead pass those arguments on standard input to XArgs and it will divide up the data
according to the arguments limits of the shell.
This is often used in conjunction with the find command which is why XArgs is included
in the fact find Utils package.
So for example if you want to run the file command which is used to identify the type
of file you have like whether it's a jiff file or an image or jpeg or some media file.
If you want to run the file command on each file you find that is larger than 10 megabytes
then you might run it the following in order to increase the efficiency by decreasing
the number of times you need to run file.
So the command would be find space dot like a period, space dash type, space f, space
dash size, space plus 10 capital M for megabytes and then pipe XArgs space file.
Now this is a bit simplistic and you'll run into problems with this on files that include
white space in the file name.
So the recommended way for running find is to use the dash print zero, that's the number
zero option to find and then use the corresponding option in XArgs of dash zero.
This will separate the output of each line printed by file with a null character which
can't be used in a file name anyways but can act as a separator in text.
This avoids issues with white space or other strange characters and file names.
If you're on a beefy machine with multiple cores and fast storage you might want to take
advantage of that extra power to do more things at once.
For instance, if you're using a compression program that doesn't take advantage of multiple
CPUs you may want to compress multiple files at once to speed things up.
So you can use XArgs dash capital P option which stands for parallel to set the maximum
number process that XArgs will run in parallel.
You do need to consider shared resources and also if the program can handle multiple
file names, arguments at once and can run more than one instance of that program at
the same time.
So there are limitations to it.
There's also another program called GNU Parallel that does something similar and is more
robust for running things at the same time.
Another interesting use of XArgs is a kind of undocumented feature that you can use
to join lines of text together on a word boundary.
For instance, if you have a text file with lines of text broken across lines, you can
join them back together by simply catting the file into XArgs.
Or you can limit how many words end up per line with a dash end option.
So if you pipe a text file into XArgs space dash 10 you'd end up with an output of 10
words per line with each word separated by a space character.
These three commands I've mentioned can be combined for many other purposes, but I find
them useful for generating a list of dice where pass phrases, which is basically a password
that has four random words placed together.
You can use the look command first to generate the list of words by simply using lookspace
period.
This will print out all the words in the dictionary as I mentioned before.
Then pipe that output into the grep command to match only those words that are between
four and eight characters long.
The exact syntax using regular expressions is include in the show notes.
Then pipe that output into the shuff command to randomly order the matching words.
Now you can group those words into four word pass phrases using the XArgs command and
its dash end option to control the number of arguments.
So pipe it into XArgs space dash n4.
Then finally we limit the number of pass phrases it outputs to just take the first 10 lines
using the head command.
So we get 10 sets of randomly generated dice where pass phrases that we can choose from
or maybe mix them up.
Just be sure to use something random please.
Thanks for listening today as we cover some uncommon commands.
If you have a favorite use for one of these commands, I'd love to hear about it in the
comments on the HPR website.
Take care and I'll talk to you again soon.
Bye.
You have been listening to Hacker Public Radio at Hacker Public Radio does work.
Today's show was contributed by a HPR listener like yourself.
If you ever thought of recording podcasts, then click on our contribute link to find out
how easy it really is.
Using the HPR has been kindly provided by an honesthost.com, the internet archive and
our syncs.net.
On the Satellite status, today's show is released under Creative Commons Attribution 4.0 International
License.
