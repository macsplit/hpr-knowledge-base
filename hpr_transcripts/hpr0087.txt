Episode: 87
Title: HPR0087: Compling a Kernel
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0087/hpr0087.mp3
Transcribed: 2025-10-07 11:20:31

---

.
Hacker Public Radio. My name is Klaatu and I'm going to be compiling a kernel.
Kernel compiling has obviously been covered. A lot of places already, magazines, websites,
podcasts. I am not an expert, but I thought that perhaps sort of a generic kernel compilation
episode could be good. Dave Yates recently on his podcast, Lotta Linux Links, covered
compiling a kernel. It was somewhat specific to a Debian system, so I'm going to be doing
what I would call more of a generic version of that. It's compiling a kernel simply because
my experience has been on either Slackware or Fedora, so the end result is not going to
be ending up with a .deb file, for instance, it's just going to be kind of a more manual
way of doing it, perhaps. This is also going to be based quite a bit on some conversations
in the Lotta Linux Links IRC channel with Monster B and Peter 64. If you want to talk
about kernel compiling with a couple of guys who compile kernels every other night, those
are the two guys to talk to. Although that's not an invitation to go in and ask them all
kinds of questions all over the place. I don't want to volunteer them for anything, but
certainly if you want to chat about kernel compiling, they do know a lot about it.
First, you'll need the, well, first, you should ask yourself why you're compiling a
new kernel. Obviously, if your system is not broken, you may not want to fix it, especially
if this is an important machine that you rely on, so keep that in mind. But a lot of times
you'll want to compile a new kernel because you'll need hardware support, and that's a
great reason to go get the latest kernel from kernel.org, where they have the latest
stable version, they have the latest snapshot of the stable tree, they've got the older versions
of the kernels, should you need for some reason, an older kernel. You know, all the source
code that you're going to need is at kernel.org. Now, if you know the link of the source code,
you can also use just a wget, and that's how I usually do it. So I usually cd into my
slash usr slash src directory, and then I simply type in wget space, and then I paste
the link of the source code that I'm looking for. So usually that's like http, colon slash
www.cernel.org slash pub slash linux slash kernel slash v2.6 slash linux dash 2.6.25, it
happens to be 2.6.25 right now, dot tar dot bz2, and that will simply download the source
code as a be zipped file to your slash usr slash src directory. You'll then want to untar
that. So it's t-a-r space dash xjf space linux dash 2.6.25 dot tar dot bz2. That unzips
whatever the source code as a standalone directory. And it's customary, and I'm not really
100% sure why this is, but everyone always tells people to do this, and so I've always
done it, but you make a symbolic link from the from this directory that you've just untard
to a directory called linux. So it's just ln space dash s, space slash usr slash src slash
linux dash 2.6.25, space linux. Okay, so now we've got a symbolic link of a directory
called linux to the source code of our kernel, of our new kernel. So actually I do know
the reason for that. It's, I believe if you're, if you've got any kind of scripts or something
like that that needs to act upon the kernel source code, then no matter what, we always
have a symbolically linked folder called linux, which always is referring to the latest
kernel source code. And that's why that is. So then you can change directory into the
linux directory. So just cds, space, space linux. So here you are, you look around, you
can LS, and you see all the, uh, the different files that the kernel maintainers have packaged
into the latest kernel package. At this point, you are actually able to patch your kernel.
So if there is something that you know specifically, you, you'll need as a kernel patch for whatever
it is, whether it's a security patch or some kind of driver patch, uh, you can do that
right here. So if there is, uh, for instance, a kernel patch that you have downloaded, let's
call it, um, patch one dot bz2. And you would move that to the slash usr slash src. And
then you would simply type in be zip to, that is spelled out. So it'd be the ip and the
number two, space dash dc, space slash usr slash src slash patch one dot bz2, space type,
space patch, space dash p1. And that will patch the kernel so that whatever, like security
patch or hardware patch or driver patch, whatever that you needed to apply is now applied.
Okay, so you'll want to kind of to make sure that you're starting from a fresh, a clean
slate. You're going to type in make space mr proper. That is make space mr proper, easy
enough. That basically just clears out any kind of little binary bits that might have been
leftover from either a previous, uh, compilation effort or anything like that. Once you're
ready, I mean, you're kind of ready right now to technically you could start compiling
the kernel. If you did that at this point, you would be starting really, really from a very
clean slate, maybe too clean because you would have to basically start from the very beginning.
And the very, and if you're, if you're configuring, you're, you're basically going to start
generating a configuration file so that when you type in make or make busy image as the
case may be, the, the comp, the compiler will look at the configuration file for what
you have, for what you've set for your system. And we'll use all those settings to compile
a kernel appropriate for your system. What does this mean? Well, this means that you need
to know everything on your system. You need to know the CPU type. You need to know, uh,
what kind of drive controller you've got, a hard drive controller, uh, controller. Do
you have scuzzies, uh, IDES, uh, SATA, basically everything about your system. What kind of, uh,
Wi-Fi card you have, what kind of graphics card stuff like that. So this is significant
because if you don't know these things, then you're really going to be compiling a kernel
without any kind of clue as to what you're doing. So before you really do this, you need
to really read up on your computer, figure out what exactly your components are that you're
going to need to use. Luckily for you, uh, if you've got a working system as it is and you
probably do since you're able to at least go and download the source code for the kernel
in the first place, uh, you already have a configuration file on your system. And this
is somewhere in your slash boot folder. So it's kind of going to, it's going to be a little bit
different depending on where your system came from and who built it and, and how they built it.
Sometimes the configuration file that you're looking for is, uh, like dot config. So you
won't really see it right away. Uh, sometimes it is, uh, config dash huge dash s m p dash two dot
six dot two one dot five dash s m p. It just really depends on your system. So have a look just
LS space slash boot and you'll see in there that this is your current boot directory. So you'll,
you'll see in there all your all the system maps and all the configuration files and all the
VM linus files, uh, that your system basically is right now having available to it. So have a
poke around in there, find the config, the current config file for the current kernel that you are
using. Uh, if you don't know what kernel you're using currently, simply type in you name that is
the letter u in a m e space dash a v. And this will tell you what kernel you are actually running.
So I do that and I get two point six point to one point five dash s m p, uh, and a lot more
information. But so now I know that that's the kernel version that I am currently running. So if I
use the config file for two point six point two one point two, uh, point five dash s m p, I'll know
that I'll be using the, uh, proper configuration file. So how do I use this old configuration file?
Uh, well, since I'm in my slash usr slash src slash linux directory, I can simply type in
cp to copy cp space slash boot slash config dash huge dash s m p dash two point six point two
one point five dash s m p. So that's just the old configuration file that I've identified, right?
And then I'll type a space dot slash dot config. So what I've done is I've copied the old
configuration file into the current directory. That's the dot slash. And then I've named it dot
config. So I've just basically copied it and I've renamed it to be dot config. That's just an
easy way to grab everything that the kernel already knows about your system and put it into the
current, uh, kernel source code directory so that we can start from where we've left off, you know,
so it's where we're instead of building the kernel configuration file from total scratch. Now we've
at least got, um, basically at least a system as good as what we've got already and we can just
uh, configure the new options. And to do that, you can simply type in make space old config.
Okay, so this will attempt to make a usable, uh, configuration file based on your old kernel,
but there will, there might be differences because obviously the new kernel will have perhaps new
new options. Maybe it will have removed certain options. You'll still have to configure, uh,
something probably, but like I say, it's a lot less work than starting over from scratch. And that's
a great way to do it, especially if you've never compiled a kernel before. That's a great starting
place. All right. So after you've gone through and basically it's just going to ask you a couple
of questions and you can usually type in question mark, uh, return that will give you sort of a clue
as to why it's asking you and what the significance of what it's asking you is. But, um, it's just
going to ask you questions about, you know, whether you need certain, um, certain things enabled,
like groups CPU scheduler, do you want that enabled? And it will have a, a yes or a no or a question
mark. And you can, the, the default option will be capitalized and where it might ask you to,
you know, whether you want to create deprecated, cis, fs files, um, just all these different questions
about like the new options that the newest kernel has available that your old configuration file
didn't have. If you don't know what it's asking you, the safest thing and, you know, read the help,
help the help screen, but also I guess the safest thing would typically be go with the default.
Once you're ready, once, once you've answered all the questions that it throws at you with the,
the make old config, you will want to then make menu config that will bring you into the main
configuration menu. You can navigate through this. It's an incursive screen. So it's, it's graphical,
a little bit low five, but it is a graphical interface. There's a lot of help files available
within that. And, uh, you can simply kind of go down to the, uh, load an alternate configuration
file option and hit return. And it will, it will load up that dot config, which, uh, obviously is,
is what we just renamed the configuration file too. And so this will use exactly what you've
configured to make the new, um, the new kernel configuration. It will give you some options
in, in terms of the, the many, many choices that it gives you. You can either build the choices,
the, the different aspects of the kernel into the kernel. Uh, you can make it a module so that you
can lay it, you, you can load it, you know, after the kernel is, is running, uh, or you can just not
include it. You don't build a certain, a certain option into the kernel. And it really depends on
what you need, what you think you need, uh, as to what, what you're going to do in each case.
If it's something that, um, you know, there's, there's options for like amateur radio, support,
things like that. Those kinds of things, you probably just don't need to build, but certain,
other things you're going to have to really kind of think about, think about your system,
and, you know, choose accordingly. At this point, you are ready to actually start the compile.
So you will type in make, be the image that is make beta z image with a capital i. And that
starts compiling the code. That could take a while depending on speed of your computer. Uh, and after
that's finished, you will type in make space modules, which obviously makes the, uh, the options that
you would chose to not build into the kernel, but build as modules. That'll do that. Now,
once that's finished, that won't take as long. Once that's finished, it's time to start moving
some files around. Now, the idea here, if you, it's pretty simple, if you think about it,
and you just have to kind of think about it because moving all these files, listening to me, say,
the paths of all these different files gets kind of confusing after a while. But if you think about
what's happening, you're basically taking those old kernel files like the VN Linus that represents
the old kernel and the system map that goes along with that old kernel. You're just going to rename
those so that for yourself, you know that that's the old kernel. And then you're going to move in
the new stuff that you've just done, like the bz image and the new system map, you're going to
move that into the boot directory because the boot directory is obviously what the boot loader
is going to need to boot up into a certain kernel. So the details of that would be MV, like move,
MV, space slash boot slash VM Linus, space slash boot slash VM Linus dot old or whatever,
whatever you want to name the old kernel so that you can recognize it as the old version.
Okay, so you've just moved the old kernel into a backup version of itself.
So take the new kernel and put that into the VM Linus. To do that, you'll type in cat,
space arch slash i386 slash boot slash bz image greater than sign space slash boot slash VM Linus.
So you're just taking everything out of bz image and sending it over into VM Linus.
The reason I'm giving the path arch slash i386 slash boot slash bz image is because that's
what it is on my computer. On yours, it might be arch slash x86 underscore 64 or something like that.
Just kind of depends. Just looking right where you are, the slash usr slash src slash Linux.
There's an arch directory there. And in that arch directory, you'll see architecture that you
have available to you. So now that you've moved the new kernel over to VM Linus, you'll need to
take the old system map and rename it so that you know that's your backup system map.
So again, it's in the space slash boot slash system dot map, space slash boot slash system dot map dot
old or whatever you want to call it. So you're just renaming the old system map to something
to denote that is the backup system map. Now you'll want to copy the system map that you've
just created while compiling your new kernel into the boot directory. And that is done quite
easily. CP space system dot map, space slash boot slash system dot map, easy enough. Now you'll
want to make modules underscore install that is make space modules underscore install. And that
takes care of all those modules, make sure that they're where they need to be. And you're pretty
much finished in terms of dealing with the kernel files and everything like that. The last thing
you need to do is configure your bootloader so that when you reboot your computer, you'll be able
to go into either the old or the new kernel. So if you're running Lilo as your bootloader,
you will open up in the text editor slash Etsy slash Lilo dot comp. And you'll take the existing
entry, which was probably auto generated by what you know when you were first installing your
distra. You'll take that old entry and you'll make a copy of it. And on the old one, you will
append, for instance, where it's pointing to VM Linus, you'll make that VM Linus dot old. And on
the new one, you'll leave that as it is because it's still pointing to VM Linus, which you've
just updated with your new kernel information. You will probably want to change the label as well,
otherwise it'll both say Linux. So make one say like Linux old and one Linux new or Linux dash
2.6.21 versus Linux 2.26, 2.6.25. Just something for you to recognize, which is the old kernel,
which is the new one. And since it is Lilo, you need to update it after you've finished editing it.
So to update Lilo, you just run slash S bin slash Lilo and that updates Lilo. If you're running
grub, you just open up in a text editor slash boot slash grub slash menu dot LST. And again,
copy the existing entry that was probably auto generated by your installer. Make the old one VM Linus
dot old and make the new one VM Linus and change the label so that you can tell them apart.
You don't need to update grub, it will update itself and you just reboot. And once you reboot,
it'll get to your bootloader and you can tell it to boot into the new kernel and take it for a test
drive, see if it works. Now if it doesn't work, never fear you've got that old kernel available to
you via your bootloader. So you can just reboot, go back into your old kernel and you're good to go,
you can try to recompile the new kernel and see if you can get it working properly. In my experience,
when you use your old config file, usually the new kernel just kind of works. But if not,
you know, just boot into the old one and try to recompile the new kernel. Remember before
recompiling the kernel, you'll want to type in make space MART proper so that it kind of starts
back from from ground zero that also deletes that little config file. So you'll need to recopy
the old config file from your your boot directory back over into the source code directory so
that you can try to reuse it. That's it for kernel compiling. Thanks for listening. Next time,
I'm going to cover compiling a kernel over a cluster network, a little bail wolf cluster. And in
the meantime, if you have ideas for hacker public radio, like episode ideas or cool tips or
tales of Linux adventures or hacking adventures that you want to relate, contact the admins
over at hackerpublicradio.org. This is obviously a show by the community for the community. So the
more contributors we have, the more variety we'll all have. And making an episode easy, it's fun,
so give it a shot. Thank you for listening to hacker public radio. HPR is sponsored by
caro.net, so head on over to C-A-R-O dot E-C for all of your community.
