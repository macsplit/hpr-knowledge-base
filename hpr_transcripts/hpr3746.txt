Episode: 3746
Title: HPR3746: Cpuinfo
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3746/hpr3746.mp3
Transcribed: 2025-10-25 04:53:38

---

This is Hacker Public Radio Episode 3,746 from Monday the 12th of December 2022.
Today's show is entitled, CPU Info.
It is hosted by Klaatu and is about 15 minutes long.
It carries a clean flag.
The summary is, How to Get CPU Info on Linux.
Hey everybody, how do you get information about your CPU on Linux anyway?
Well, actually there are a couple of different ways, as it turns out, and I kind of got curious
recently of all of the different ways.
Can't guarantee that I've found all of the different ways, but here are some that I've
run across, which some of these are you're going to know off the top of your head as well.
But the first one I guess is maybe the most obvious, possibly, it's you name.
You name can process a bunch of different information or parts, a bunch of different information
about really your system.
And I think a lot of us use just you name dash A or you name dash A V kind of by habit.
The dash A is really dash dash all you name dash dash all that prints everything that
you name has access to almost the V is what is the V V actually isn't any, oh no, it
is a kernel version.
That's what it is.
Current kernel version.
Okay, so that's you name A V, but and that gives you a lot of information.
I mean, like dash dash all dash dash kernel dash version.
That gives you that you're on Linux.
It gives you your host name.
It gives you the kernel version, whether it's an SMP kernel or not preempt is active or
not the date that that kernel was compiled on.
And then the architecture X86 underscore 64 in my case.
And then the CPU vendor ID AMD Ryzen 5 5 6 series or X and then some details about that.
That's not the vendor ID is it.
That's like the model or something and the vendor ID is authentic AMD, I think.
So that's a lot of information from you name A V. So what you can also do is according
to man you name, there's the dash I or dash dash hardware dash platform.
So if I do that you name dash dash hardware dash platform, then I get authentic AMD returned.
There's also the dash P, which dash dash processor, that's going to give you the processor
type, you name dash dash processor AMD Ryzen 5 5600 X 6 core processor.
That's what it says.
And then finally, there's dash M or dash dash machine, which provides the architecture.
So you name space dash dash machine in my case returns X86 underscore 64, that's the architecture
of that CPU.
Okay, so interestingly, there's another tool called arch.
And that's also distributed within the GNU core utles package.
And it does exactly I think one thing and that is returns the architecture of the machine
you are running on.
So it is exactly like you name dash dash machine, except it's a different command called arch.
So type in ARCH into your terminal, hit return and you get what architecture you're running
again on this current machine that I'm recording this episode on and typing stuff into a terminal
on X86 underscore 64, so it's you name and then arch.
And then the other way that I could think of to get this kind of information and I'm assuming
I haven't actually looked at the source code of you name or arch, assuming this is where
it's getting the information from.
It's the virtual file system under slash proc slash CPU info.
If you do a cat on that, you get all kinds of information about every single different
core on your machine.
So that's probably overkill.
You're probably going to want to pipe it through grip for it to be very effective, but
the kind of information you're getting is the vendor underscore ID.
So that's authentic AMD in my case model space name AMD Ryzen blah blah blah.
So that's it for the slash proc CPU info at least I poked around and proc a little bit
more and couldn't find anything directly related to it.
I did find some other things that I'll get to in a moment.
But first before I go into the absurd, I want to go to the more practical, which are the
desktop applications that you might use to find out this kind of information.
And this can be useful, you know, when you're when you're helping, I mean, they can be
useful in general.
I use K info center all the time.
I love that application, but it can also be a really useful way to help someone else
get the information that maybe you need in order to support them better.
So KDE, the KDE desktop provides K info center.
It is a system summary application.
It pops up all the information about your system with information about the kernel that
you're running, the hardware that you're running it on, the amount of memory that you
have, the energy consumption or available, whatever it's called ram and so on.
So it's very useful.
It's kind of I guess a front end technically to solid KDE solid.
So that also means that you can get CPU information and there's a lot of information about
that actually on in the devices section.
But the the general overview, the quick just like after you've launched K info center,
the first thing that you see there is a system summary and it may not immediately be
obvious where the architecture information is, but it just so happens, at least on my
systems, it says kernel version and then after the kernel version, it gives you that it's
a 64 bit processor or 32 bit processor or rather it tells you whether you're running a 64
bit kernel or a 32 bit kernel.
So that is there on the main screen.
You can also go down to devices and go down to in the left column CPU and that gives you
a pretty good representation I think of well really most of the stuff at a slash proc,
but it also it right up at the top it says architecture x86 x86 underscore 64 CPU op modes
32 bit comma 64 bit.
So it tells you quite a lot of information about just sort of how you're able to use that
CPU.
Of course, I'm just I'm being very biased here towards like x86, not because I want to
be biased by it, but that's just the computer that I'm on right now and that I've kind of
poked around long enough to to do this.
The same kind of information would be available on a pie of course, but you're going to see
different different sort of output and I'll go over that in a moment as well.
So then the the Gnome version of this information is in settings the applications just called
settings and go down all the way to the bottom of the of the list about on the left.
And sort of near the bottom of the resulting list, you can find the what they what they
call is the OS type and that'll tell you whether it's 64 bit 32 bit, whatever.
So that's the Gnome version of K info center.
Now on some other architecture, I mean, really all the same things apply, it's not really
that different.
I mean, you've got a name you name dash a for or dash dash all for all of the information
about your kernel, which by default does include the architecture.
So for that is on this Raspberry Pi for a arch 64, there it is.
You could do you name dash M for just the a arch 64.
You can do a you name dash I for a arch 64 you name dash P for a arch 64.
Pretty consistent to be honest, arch returns a arch 64.
And then of course cat CPU info gives you a lot of the information that I've already talked
about, including the hardware version, which is listed as BCM 2835 and the model, which
is listed as Raspberry Pi for model B rev 1.4 in this particular instance.
And then so I couldn't find any other tools really, I mean, there are, you know, there
are half a dozen tools out there that'll just query slash proc slash CPU info.
So just going over everyone could be get a little bit redundant.
But it occurred to me that there got to be other things you could query to get this kind
of information.
I didn't do a whole lot of looking around.
I did find some C++ boost libraries that have what it's the architecture series.
If you look in boost it has a bunch of header files in there that can that that provide
a bunch of data about what architecture it is running on.
And that that seems really, really useful.
But I'm assuming once again, if you're at the point of dropping down to writing code to
try to figure out whether you're at 32 bit or 64 bit system, you probably don't have
boost installed.
It's probably not even safe to say that you have C++ installed.
And yet that's what I'm going to assume.
So if you do something like hash, include left angle bracket, IO stream, right angle bracket,
that just gives you see out.
I mean, you could do without it.
You could just dump straight to standard out, but I'm just taking a shortcut and using
see out.
So using name, space, standard, semicolon, and then int main parentheses, parentheses, curly
brace, see out, no, not yet.
Let's do if if parentheses size underscore max and size underscore max is a, you have
to have C++ 11 or greater installed, but I think that's relatively, if we're saying
you have C++, you probably have a recent dish version of C++ maybe.
So size underscore max tells you the maximum value of what a variable can hold, like what
the maximum value integer size of a variable can be.
So size underscore max, that's all capitals equals equals 0x, FFF, FFF, FFF, FF, FF,
close parentheses, curly brace, see out, left, yeah, left angle bracket, left angle bracket,
quote, I don't know, 32 bit, close quote, semicolon.
And then you do it, close the curly brace, else space if parentheses size underscore max
equals equals 0x, FFF, FFF, FFF, FFF, FFF, FFF, FFF, FFF, FFF, FFF, close parentheses, curly
brace, see out, left, angle bracket, left, angle bracket, quote, 64 bit, close quotes,
semicolon.
And then just in case I guess curly brace, else curly brace, and then see out, left,
angle bracket, left, angle bracket, quote, I don't know, close quote, semicolon, curly,
close curly brace, returns your semicolon, and then close curly brace.
And then if I do a C, a G plus plus, CPUArch dot CPP is what I call this, dash O CPU arch,
that seemed to compile.
And then I hit return, and yeah, I get 64 bit, it's right before my prompt, because
I didn't put the left, you know, the backslash in, or in the L, if I wanted to, forgot
that, but that's fine.
So 64 bit here, and then if I run that on Raspberry Pi, of course, actually I'm not going
to go to the trouble, I did it before, it would return a arch 64, or rather, it would
detect that it was 64, you know, this is just a test of literally 32 bit, 64 bit, it's
not telling you the actual architecture, it's not saying whether it's an x86, or a risk,
or an, you know, arm, or whatever, I guess arm technically is risk, but you know what I'm
saying is it doesn't tell you the architecture so much as it does the, um, bitterness, there's
probably a better, more official term for that, uh, of the CPU.
So this is just a simple example of, of querying data that maybe, you know, indicates to
you the thing that you want to know, if you're not able to get to the actual thing that
you want to know, just an interesting exercise, and I'll leave it up to you to think of other
ways to do it, because I didn't put a whole lot of thought into this, to be honest, and
like I say, lots of other languages, or I guess arguably I put too much thought into this,
and this is where I am now, but I didn't, I didn't go into depth in the, in like, okay,
what kind of code could we write, because obviously there are existing libraries that actually
do this already a lot better anyway, so it's not that useful.
It's just I think the exercise was interesting because it forced me to think around the
problem and get to a solution through a different avenue than I would have initially thought.
So those are the different ways I personally can think of to get the architect, uh, the,
the, the, the, the kind of CPU that's powering the system that you are on.
I don't know when that would be useful.
I mean, it might be useful a lot.
There are lots of, lots of other different ways I'm sure of getting this information,
like I said, there are probably, well, there are definitely a bunch of other commands that
will query slash proc slash CPU info.
There are programming libraries that are aware of the hardware underneath them after you compile
them, or if they're, you know, interpreted languages, then they probably already have access
to that data.
So there's a lot there.
You could also just query the file system, you know, like look in user share or, or slash
var slash something or another and see, see if there are files there that betray as it were,
the, the architecture that, that, that things have been installed for.
So that's yet another way.
Think of some more ways.
It's a fun exercise, actually, and also kind of useful because, uh, people do need to know
this kind of information.
They do sometimes need to know what kind of CPU they're running.
And if they've listened to this episode, then they know how to find it in a couple of different
ways.
Thanks for listening.
Talk to you next time.
You have been listening to Hacker Public Radio at Hacker Public Radio does work.
Today's show was contributed by a HBR listener like yourself.
If you ever thought of recording a podcast, you click on our contribute link to find out
how easy it really is.
Hosting for HBR has been kindly provided by an honesthost.com, the internet archive,
and our things.net.
On the Sadois stages, today's show is released on our creative comments,
attribution 4.0 international license.
