Episode: 428
Title: HPR0428: FreeBSD Ports for Beginners
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0428/hpr0428.mp3
Transcribed: 2025-10-07 20:21:28

---

.
.
Let's talk about something fun.
FreeBSD's port system comes to mind.
The FreeBSD port system is a package management system
and a FreeBSD user uses it in tandem with packages
to install, remove, and otherwise manage software
on their computer.
The port system installs software from source
applying the patches that make the software viable
in FreeBSD.
While the alternative packages gives the user
the option of installing using a pre-compiled binary,
if you're unfamiliar with the various BSDs,
but ports sounds familiar,
remember that Gentoo's portage was based upon
FreeBSD's port system.
So let's look at a thumbnail sketch of FreeBSD's port system
by installing a piece of software,
and then let's look at what is happening
with an eye towards the details.
First, on FreeBSD, it's a good idea
to have already obtained the port's collection,
the simplest way is during initial installation.
When installing FreeBSD, you might be asked
if you want to get the FreeBSD port's collection,
and it's a good idea to answer yes.
Simply put, you'll then have a series of directories
in slash USR slash ports
that will contain the make files,
description files, and other miscellaneous things
that make this such a usable system.
And let's say you've got a fresh insulation
of FreeBSD and you're in the terminal.
As a side note, you'll notice that the command line
is slightly different than what you're used to.
If you type Echo Dollar Sign Shell,
Shell Bing and all caps, of course,
you'll see that instead of Bash,
your default shell in FreeBSD is called TCSH.
This is the Tenix C shell,
and has a somewhat similar relationship
with the original C shell,
as Bash does with the original Born Shell.
It might not feel entirely the same,
but you can rest assured that it has all the features,
such as Command Completion,
that you've come to expect from a thoroughly modern shell.
So, you're in the shell,
and you want to install an application
using FreeBSD's port system.
Since I already know that it's a small application
and it'll compile very simply and quickly,
I'll use Sudoku as an example.
Sudoku is a program that, as you can expect,
allows you to play a game of Sudoku
right there in the shell using in-curses.
It's a nice little diversion,
and most importantly, it'll compile quickly.
A good method for installing an app in FreeBSD
is first to do a where is on the application.
So, I type where is Sudoku in the prompt,
and I'm told that it's in the slash USR slash port slash game
slash Sudoku directory.
So, I navigate there,
typing CD slash USR slash port slash game slash Sudoku
into the prompt.
While in that directory,
if I list its contents,
I'll see files such as make file with a capital M,
dist info,
package description,
and package playlist.
I'll also see a directory called files.
Let's get back to installing Sudoku.
First, while in the same directory,
I type make.
Then, I'm given some output.
Then, I'm returned to the shell.
I type make install.
Again, I wait a while during which
the terminal spits out some text.
Eventually, thanks all down,
and I type make clean.
I've now installed Sudoku,
and if I type Sudoku into the terminal,
I'll present with the familiar 9 by 9
grid of squares that catches the eye
of any long times Sudoku player.
So, what exactly happened there?
Let's go over installing an application
via Portrait FreeBSD,
but let's place some emphasis on the details.
I don't want to use Sudoku as an example again,
since it's already on the system.
But, I mentioned that the default shell was TCSH,
or the Tenix C shell.
Maybe I'm stuck in my ways,
but I'm used to bash,
and I'd like to run it as my shell.
However, typing bash does nothing.
Because, by default,
bash is not installed on a fresh FreeBSD system.
Well, let's remedy that.
First, I'll do a where is bash,
and I'm told that the only location bash has
on this system is in the slash usr slash ports slash shell slash bash directory.
I navigate on over to that directory.
By typing, of course, CD slash usr slash ports slash shell slash bash.
Take note how nicely the ports categories are organized by logical groups.
Games in one directory text errors and yet another,
shells in yet another.
It's another happy little fact
that makes FreeBSD worth your attention.
Well enough.
I see that I'm there in the directory,
and I do an LS.
I see make file with the capital M,
dist info, files,
pkg-d install,
pkg-dESCR for description,
pkg-install,
pkg-p list.
Now, this pkg-dESCR package description
is of course a text file,
which is the description of the package.
I'll use the less command to read its contents,
and I'm quoting here.
This is GNU Bash.
Bash is the GNU project's implementation
of the POSIX.2 shell spec,
but also with interactive command line-edding,
job control, and architectures that support it,
CSH-like features such as history substitution and brace expansion,
and a slew of other features.
That's a nice verbose description,
and it gives the uninitiated a brief little taste
of what to expect from things in the BSDs.
They typically do have wonderful documentation.
So, I'm in this directory, and I want to install Bash,
which is, as I quoted earlier,
the GNU project's implementation of the POSIX.2 shell spec.
My first step is typing make into the terminal.
Make will fetch source from distance servers
by means of FTP,
will run check sums,
and all the while will be printing to the display.
Installing applications via this method
is very verbose indeed,
and you might want to consider piping the output
of the first few times you install applications via ports
and free BSD to a text file
for your later peruzon or for you to learn a bit more
about what free BSD is doing,
all in the blink of an eye
while you're waiting for your new application to be installed.
Anyway, make is grabbing the source coding
and filing it for your system.
Make knows where the source code is
because of the dist info file,
which contains information about where to get the source
for the app and the check sums to verify
that you're not downloading corrupt or incorrect files to be built.
Of course, the file called make file
has information about how that source is to be compiled
after you've gotten it,
and this is along with where it goes during installation,
though that's a little ahead of where we are right now.
For something like bash,
depending on both your network speed
and your processor speed,
this could take some time,
but after that time has passed,
you'll be returned to the prompt.
If you try starting bash now,
of course nothing will happen.
You have brand new bash binaries,
but it's not installing your system.
This is the job of the make install command.
To anyone who has compiled from source,
this will all sound familiar, of course,
but it's still nice to keep in mind what exactly happens
after you type make install.
This action moves binaries around
and makes the executables that previously can both use
and recognize in your system.
After this step, you're done.
Try typing bash to the command line,
and if all went well,
you'll be dropped into a bash session,
which you'll notice from the change in appearance
your prompt undergoes.
And while installation is done,
it's still best if you don't stop here.
Use the command make clean.
You see, it deletes all the working sub-directories
in temporary files that are generated
during the make and make and stock process.
You want to use make clean
in order to keep a maximum of this space free,
and to avoid problems that might occur during updates
if those temporary files are still there.
Personally, I've never experienced these problems
because I always run make clean
when I install software via ports.
So I can't really describe what exactly those problems are,
except they're most likely messy
and not so much fun to deal with.
Now, if you look at this make make install
and make clean process,
you'll realize quite quickly that this is an ingenious
and dropped at simple method of installing applications
from source code.
And far from being the scary and unfriendly OS
that some people advertise it as,
FreeBSD can, in fact,
be quite user friendly, quite easy to use,
and quite suitable for either the novice or the hobbyist.
And if you happen to actually be in your first FreeBSD system,
and you've been following along and have just done
your first two application installs via ports,
then here's a short list of other programs
to install that you most likely don't already have
on your system.
Assuming this is a fresh install of FreeBSD.
Vim, my personal favorite text editor,
all apologies out to the EMAX people.
WGet, which is especially useful
when you have a slower in a connection
and want to batch download files in your sleep.
ZS8, or the Z shell.
I think everyone's got to use this at least once in their lives.
Fluxbox.
And while it's nowhere near the size of KDE or NOME,
it's still a bit of a doozy to install from source.
Especially considering you'll have to get X.
And, otherwise, go out there and explore ports.
Go to slash user slash port slash games
and see what interesting the versions you can find.
Navigate over to slash user slash port slash mail
and see what email clients and utilities you could make use of.
With over 20,000 ports, FreeBSD gives you a very wide offering
of software to try out and utilize
in your day-to-day computing experience.
All in all, explore.
Thank you for listening to Haftler Public Radio.
HPR is sponsored by Carol.net.
She'll head on over to C-A-R-O dot-A-T for all of her team.
.
.
.
.
