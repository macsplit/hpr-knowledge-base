Episode: 1531
Title: HPR1531: How I use Linux  
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1531/hpr1531.mp3
Transcribed: 2025-10-18 04:44:07

---

...
...
...
...
Hello NPR listeners, my name is Jezre and I'm here today to tell you about how I use Linux.
Now, there are three main ways that I use Linux.
One work, two at home, three for play.
So I'm going to go through these one by one.
How I use Linux at work?
For the most part, my work consists of software development.
In this sense, I'm mostly using Linux to run Genie and Genie is a text editor that has
code syntax coloring, it has project definitions so that, for example, if I'm working on
nano-rimo, I can open up my nano-rimo project and all of my files and methods and functions
are all right there for me.
And if I'm writing something else, I switch projects and then all of my files for that project
are open.
It's really nice.
Recently, I discovered that there is in the preferences for Genie, the ability to remove
chilling white spaces.
And for some reason, this was totally awesome to me.
And so now I have that enabled for all of my projects, yay, yahooie.
Now Genie is a graphical interface program, meaning that it requires X or in the future,
it will require Wayland or possibly even Mer to be running on a Linux box in order to
use it.
There will be, however, times when I am on the command line and I need to edit a file
from the command line.
And for that, I use a small program called nano.
Now a lot of people seem to think that nano is a feature-free, useless, simple text editor.
And while it is a simple text editor, it is certainly not feature-free with the use
of a well-crafted configuration file.
It is quite possible to get syntax coloring and other features that one might expect from
a feature-rich text editor in nano.
Go check it out, you might find something that you like.
When I'm developing code, I am developing on my work machine, or I should say my development
machine, which is running Arch Linux.
Quite often, the code that I will be writing is supposed to be running on a production server
that is Debian and probably has Apache MySQL, that sort of thing.
And I would love for my development machine to be very similar to my production machine.
I need to, in some way, run Debian Linux.
And in this sense, I use VirtualBox.
And on VirtualBox, I have set up Share Directory.
And in this way, I can have my code directory on my native machine, but that code is also
getting run on Apache in a virtual machine that is running Debian.
And it helps me debug and set up things, configure things, very close to production.
And I don't like when things get a little too far off.
Along with doing all of the coding for software development, there's also comes time when
I need some graphics.
Maybe I need to resize an image, maybe I need to do a batch of images, maybe I need to
make a GIF, or who knows what, design a logo even.
And for this, I will use a combination of GIMP, the GNU Image Manipulation Program, and
IncScape, which is a very nice vector graphics application for Linux.
So there you go, that's me using Linux for work.
I also use, and I just made quotes with my fingers, I use Linux at home.
And by use, I mean, I have many machines in my house that are running Linux.
And most of these actually are running Arch Linux, because I find it to be a very nice
operating system, until it breaks.
So here's a breakdown of the machines I have running at home, and they are purpose.
Most of the machines are a single purpose machine.
Duh-duh, crumb off such a full wins.
Wind is my primary machine for running Mutton Chop.
And Mutton Chop is a media player with a web interface, which means that wind, which
happens to be connected to my stereo and to my television, is also going to be playing
my music and videos, and all of this will be controlled through a separate device using
a web browser, or by using curl or WGET to call specific actions and APIs and whatnot.
On the other side of the room, I've got wall bone, and wall bone is running one of the
first beagle bones.
On wall bone is the Willow the Whisp program, which is a web interface for controlling
three LEDs.
It is a little experiment that I ran more of an art piece than an actual required functioning
home usage machine, but still damn fun.
Also on wall bone is the Ruby Web Alarm project, which surprise, surprise has a web interface.
And the Ruby Web Alarm project allows me to write scripts, put them in a script folder,
fancy that, and through the interface, I'm able to select scripts and select at what
times they've run.
Now these scripts are normally turned on the lights, turn off the lights, get the weather,
play something specific on the Wind Mutton Chop machine, that sort of thing.
For example, 7 a.m. play a random Iron Maiden file, wonderful, perfect, that's what
I want.
Also in the Menagerie is Shitbird, Shitbird.
Shitbird is a second-gen Raspberry Pi, it actually has the mounting holes, whew, fuck,
finally, even though there's only two of them.
And Shitbird is running Glimmer, which is the Glimmer light manipulator, regulator,
or some crap like that, some stupid recursive acronym name, well like a Crapron M, that's
a great name for it.
Connected to Glimmer is a 50 LED WS-2801 pixel LED, bunch of shit, well whatever, yeah,
some LEDs that I can control, and it's nice to have lights on, the lights turn on, lights
off, lights turn off.
There is also in the Home Machines, more of an art piece, but still has some sort of
use, and that's the Toaster.
I toast, therefore, I add.
And the Toaster has a Raspberry Pi, the first one with crappy memory, crappy everything
and no mounting holes.
And for sensors, the buttons, there's the Raspberry Pi's in the Toaster, there's a motion
detector connected to the Raspberry Pi, when motion is detected, the Raspberry Pi will
look through a directory full of audio files and play one at random, when some of the
files are played, other things happen, for example, when John Boy says, dude, you should
listen to more Iron Maiden.
The Toaster uses the API for wind and sends the command to queue a random Iron Maiden track.
How awesome is that?
I'm walking around the house, Toaster says, dude, listen to more Iron Maiden, next thing
you know, I'm listening to more Iron Maiden, that right there my friend is some sweet shit.
Also running on the Toaster is a little something I call TTSListner.rb.rb, it's written in
Ruby, and TTSListner, it is a web server that is listening for text to speech commands.
This allows me from any other computer in the house to send a specifically crafted curl
or W get request to the Toaster and have it speak a specific string.
For example, there's an alarm on Ruby Web Alarm that is running on wall bone that is
called Petaluma Forecast.
Petaluma Forecast, when it runs, downloads the Forecast for Petaluma, which is the city
in which I live, and parses that data and then pipes it into the Toaster so that I could
say at 8.30am set in alarm for Forecast Petaluma at 8.30, the data gets pulled, gets parsed,
sent to the Toaster, and the Toaster will speak to me or to whoever is listening what the
Forecast will be in Petaluma.
Everything has an API.
Also at home, and usually with me on my person, is one of my most used Linux machines,
and that is a Nokia N900.
My Nokia N900 is my music player, well, my portable music player, my camera, and my remote
control for my digital interactive home.
On the N900, I have obviously a web browser, and with that web browser I can access the
web interfaces to Shitbird, or Wind, or Wallbone, which allows me from my N900 to control
the stereo, set alarms, change lights on the Willow the West project, change the colors
of the LEDs, make the Toaster say stuff, that sort of thing.
Also running on the N900 is Blather, and Blather is a speech recognizer that will listen
to what I say, see if there is, when I speak a sentence, see if there is a command that
goes along with that sentence, if there is, that command will be run.
Since everything in my house runs on an API, I will have a command such as Niali lights
fade on, which will send to the Glimmer machine, which is Shitbird, the command to fade the
lights on, or perhaps I want to skip to the next track when I'm listening to music.
Or Niali volume up, which will raise the volume, there's also a volume down command.
And so through voice commands, I am able to adjust the volume, adjust the playing tracks,
adjust the lights, that sort of thing, sitting around the house.
Damn, I love that machine, I love my N900, and it's very sad that there are no other
GNU Linux machines that are capable of fitting in my pocket and are currently available
for sale on the market.
I'm looking at you, all you cell phone manufacturers, and finally, that brings me to using Linux
for play.
And what do I mean by play?
Play to me is having fun, the way some people do a crossword for fun, or Sudoku for fun,
I like to play with computer code and learn things about computer code and code in various
different languages.
And that's one thing that Linux is phenomenal at, Linux is a great tool for inquisitive
people curious about software development.
If there's a language you're interested in, it probably runs on Linux.
If it doesn't run on Linux, it's probably a piece of shit that you want to avoid.
That's just the way it is.
Also in there with playing is the piece of software called Lillipond.
Lillipond is a music engraver, and by music engraver I mean that the Lillipond software will
parse a text file and convert it into beautiful sheet music in PDF format.
So sheet music is obviously for learning to play an instrument or playing music with an
instrument.
And in that sense, Linux mixed with Lillipond is a great tool, a great resource for learning
to play new songs.
Actually, I should say tunes because songs are sung, tunes are played.
That is the difference.
And that is how I use Linux.
I'm sure there are other ways that I use Linux that I'm not touching on right now, but
I made some cracked little notes, and I'm reading them, and that's all I've got on them.
So that's all you're going to get.
At least until next time.
Oh, oh yeah, and I'm also using Linux to record this episode of Hacker Public Radio.
So eh, eh, eh, wow, I had a lot of coffee today.
Now, keep shit sweet, and I will catch you on the flip side.
Laters.
You have been listening to Hacker Public Radio at Hacker Public Radio.
We are a community podcast network that releases shows every weekday on Deathly Friday.
Today's show, like all our shows, was contributed by a HPR listener like yourself.
If you ever consider recording a podcast, then visit our website to find out how easy
it really is.
Hacker Public Radio was founded by the Digital Dark Pound and the Infonomicom Computer
Club.
HPR is funded by the binary revolution at binref.com, all binref projects are proudly sponsored
by Linux pages.
For shared hosting to custom private clouds, go to luna pages.com for all your hosting
needs.
Unless otherwise stasis, today's show is released under a creative commons, attribution, share
a line, lead us our lives.
