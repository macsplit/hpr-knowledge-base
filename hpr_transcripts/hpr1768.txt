Episode: 1768
Title: HPR1768: An Intro To C Episode 1 : Introduction and Types
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1768/hpr1768.mp3
Transcribed: 2025-10-18 09:05:00

---

This is HBR Episode 1768 entitled, An Intro to Sea Episode 1, Introduction and Types,
and in part on the series, Programming 101.
It is hosted by first-time host CKM and in about 32 minutes long.
The summary is, I go through the basic types and the basic introduction of myself.
Colin.
This episode of HBR is brought to you by AnanasThost.com.
Get 15% discount on all shared hosting with the offer code HBR15, that's HBR15.
Better web hosting that's honest and fair at AnanasThost.com.
Alright, hi, my name is Colin Mills or you might know me as C.J.
I did a show not too long ago, probably in September of 2014 for Hacker Public Radio
and it was how I found Linux, but unfortunately that was under a different alias.
So that was under Gofer and some might ask me why I switched.
I just felt that CJM was more or less where I fit in terms of how I feel like my initials
really do identify me more than a Gofer does.
And to be honest, it was more or less a pawn, you know, so go for NYX.
So that's enough about me, actually, maybe if you want to find where I'm at, I frequent
the NYXer forms quite a bit and the Arch Linux forms, so you can find me there.
Okay, now that's enough about me.
Alright, okay, so let's get started, where are we going to begin?
I'd just like to maybe talk about the show I'm looking to present, I'm looking to present
an introduction to the C programming language.
Now you might be wondering because this has been done forever and ever and ever, I mean
there's so many things, you got the K&R book, you've got all of these different resources
out there, you've got umpteen video tutorials on YouTube, but the big thing about me is
it's more or less a learning exercise because I don't know who said it, I'm sure there
was some big philosopher, but if you can explain something to someone else, then you know,
you know, you know, better yourself.
So I hope to provide a platform for beginners that they can go to and you know, just talk
about C in terms of, hey, here's this language, would you like to learn it?
And I hope I'm an adequate teacher for what I'm looking for.
Now there's a big thing we have to remember, I am still only a first year software engineering
student.
I've built quite a few things in C, I've built a chat program using sockets, I've built
a word game using, well I was actually using C++, but that's a whole other story.
Now there's another big thing about my background, you have to kind of remember, I'm a big
Unix guy, so I'm really into Unix and I'm into open source and I'm really a big promoter
of that.
So in terms of C versus any other languages, I like to keep the philosophy simple and I
also like to follow a specific, the specific Unix philosophy itself.
So what is the Unix philosophy?
Well it says create one tool and let that tool do everything, do one thing well, right?
And then make everything around it in terms of, okay, I want to read my PDFs, well I should
have a tool that converts my PDFs before I read them and then another tool to read them
or maybe that was a bad example, but we could use word processing.
That's a good example.
So if you're word processing, okay, so you have one tool to actually write, you have another
tool to maybe modify the text in terms of bold and italics and it's just a great philosophy
that means make one small part, a great part and then in terms of that, make that one module
will fit together in a bigger ecosystem.
So I really, I personally agree with that as a programmer it makes sense to me.
So let's get started shall we, this is enough rambling on, I contend to ramble sometimes.
So I've explained who I am, you know, I'm a big, I'm a big Unix geek.
So that's, that's the way to go.
So just so we start off on the same page, we should probably get maybe the history of
C and if you look in the show notes, I've got, I hope I've got some adequate documentation
that you can use if you ever need to look things up and I mean the internet is your best
friend.
A lot of these notes are just culminated from the internet so I mean whatever you would
like to use, I would definitely go to the internet first but hopefully my notes can kind
of help you out with making sure that you have at least some place to start to look.
So I have the history of C here.
So who was C originally developed by, it was developed by Dennis Richey between the years
of 1969 and 1973 at AT&T Bell Labs.
So that's a pretty big one.
They also created Unix.
So C was created before Unix or maybe even during the process of creating Unix and the
reason it was was because Richey really needed a systems programming language that was robust
enough and that could reach enough platforms and maybe even on the PDP 11, you know, which
is where they originally developed the Unix operating system and he needed to be able
to create a language that was more or less higher level than assembly language because
who really wants to write an OS in assembly and also just provided a robust API to be
able to do small things or big things in terms of memory allocation and just a lot of
features that were very much both new at the time and a little bit revolutionary.
So AT&T Bell Labs has a really good reputation in terms of kind of pushing the boundaries
and C was one of the most, I would argue that C was one of the most revolutionary parts
of our modern computer history without C wouldn't have even all the things that you have.
So when you think about that, I personally, as myself, I think that Richey and Kernahan
and Rob Pike, I mean those are the pioneers of our computer generation so that's where C came
from and the most important part was that it was provided to be one of the most high level in terms
of the time. So if you look at C right now, there's a lot of people that say, you see, I don't want to
have to deal with that because there's no automatic garbage collection so you have to do all your
memory allocation yourself. It's kind of like walking to Toronto. Why would I walk to Toronto when I
can take a car? Well, it's really important to you see in situations where you need to have
the precision of walking. You know, a good way to put it is maybe if I'm going to longitude and
latitude in a car, it's really hard to get a precise location. But if I'm walking, I can get there
right? So I, to be honest, I'm not very familiar with longitude and latitude and I hope that's
an adequate example. But I think having that precision of going to that specific place
is really important and C gives you that opportunity. If you treat, if you treat your computer's
memory like a map, you can go anywhere the hell you want using C. So where is C mostly used?
A lot of embedded applications. So if you look at Roger's boxes, if you look at
I'm from Canada. So if you look at your television providers boxes or if you look at any embedded
software traffic lights, I mean C kind of runs our world in a lot of ways. So
it's also used. I mean, every OS is written in C. Look at windows, look at Unix, look at
you know, and and I think that really just kind of shows the robustness of C, right? Because even
right now, if you look at open BSD, free BSD Linux, the whole, every kernel is written in C.
And what's that? That's like 60 years in the making or 50 years in the making. Sorry, excuse me,
it was 1969. So I'm not going to do the math right now. I don't, it's something probably 50 to 60
years. Sorry, I'm just kind of focused on talking here. But I mean, it really does show the
maturity of the language. And personally, I mean, it really shows how well the APIs were developed
and how needed it actually was if we're still using it. And there's a lot of people that would
argue that there's other solutions. And I mean, there are, but in another way, um, C's been here
forever. And I mean, you've got your C sharp, you've got your, you've got your Python, you've got
your Ruby. But I mean, those are kind of come and go languages. C has stayed here throughout the
ages. So maybe that's, maybe I'm a little bit biased because I am so unix oriented. Maybe
that's my problem. But either way, that's my opinion. And that's why I chose C to teach you.
Now, once again, just maybe to preface this a little bit. I am nowhere near a master. I have had
to do a lot of Googling. I've had to do quite a bit of things just to prepare some documentation for
this. Um, and I mean, that's, that's that. But overall, I think that you can't really take my word
as, as perfect, but you can take as close as it can be, right? So I, uh, I really hope you enjoy.
Let's get started learning the C language. And what kind of types are in there? Okay. So
we're talking about types. Now, what is a type? When you're talking about a computer programming
language, you've got this thing called the variable. Now, in some languages, higher level languages
than C, you've got something that's called, uh, interpreted language, which means, okay, I can,
I'm going to type in this command and run it. So that's how Python works. If you look at Python's
architecture, you have a .py file. And the interpreter runs through that file and executes all the commands
in there. And that's how you program in it. Now, there's a different type of language. And this
is called statically typed. Um, sorry. Uh, if we go back to the Python example, we're, uh, we're going
through this file and line by line, we're interpreting it as such language variables are not statically
typed. There's something called dynamically typed. So what does this mean? It means, okay,
if I have the variable X variable X could be a number, it could be a character, it could be,
you know, directions to two, two, Tim buck two, it could be anything. It wants to be. And there's
no restrictions based on that. Now, C is of the different types. C is of something called
statically typed language. That means to use variable X or variable Y or variable Z,
we have to define what those are before we use it. As such, we use types to define what type of
variable is. So it's actually pretty simple. Um, there's only a few core types. And there's a
couple things that, uh, that we have to go over when it comes to types. So the first thing is,
you're going to, you're going to hear me talking about signed and unsigned. So what does
signed means? What does signed means? Sorry. It means it can hold either a negative or a positive
value. So that means that my, my variable, whatever it is, if it's a number, it only, it actually only
applies to real numbers. But I'm going to be talking about integers. Okay. And integers can either
be signed or unsigned. So signed means it can hold either negative or positive values. And unsigned
means it can only hold positive values. Now, that's the very basics. Now I've, I've included in
the show notes a Wikipedia unsignness. And I mean, you can go really into the bits and you can go
to two compliments and do all of these different things. But for our purposes, I'm just going to say
that. Okay. So what kind of types do we have? We have an int. So an int is a variable that is at
least 16 bits in size. Um, it is actually the most efficient for the processor itself. So if I
compile on a 32 bit machine, then my int will be 32 bits or four bits. Sorry. If I, uh, compile on
a 64 bit machine, it will be a different value. So basically when the compiler goes through and
starts to compile, um, my program. So as I said, with the interpreted languages, um,
sorry, I'm going to just backtrack a little bit for, uh, from my integers. Okay. So I'm, I'm
going to go back one step. I apologize. I got a little bit ahead of myself. But I'm going to say
continue with my interpreted versus compiled languages. So as I said, C is statically typed.
That means we have to define our variables and the compiler, what is called the compiler,
is it goes through, it goes through the process, it compiles down to object files and then those
linked together into your executable. So every time we change a C program, we have to, um,
recompile. So coming back to the int, when, when we compile through this program,
an int is actually compiled down to the most efficient size for the processor itself. So, uh, yeah.
So on a 32 bit machine, I can tell you, uh, it's four bytes in size because that is the most
efficient, um, for a 32 bit and it's capable of storing. According to Wikipedia, it's capable of
storing negative 32,767 to 327, uh, 32,767 once again. Okay. So if I apply the signed to this,
that means that it could hold that whole range. Okay. That means it can hold either negative or
positive values. If I put unsigned into it, it means it can only hold from zero to 300,
or 32,767. Sorry again, um, about those mishaps. Okay. So again, we have another thing called
specifiers. Now, now, what are, what are in specifiers? Now, um, they're, they're basically a way to show
the size or the amount of an integer you're holding. So if you have a short, um, that's 16 bits in
size. So that means, okay, I have a short in germ, not holding a large number. Okay. And then there's
another one called a long. A long is 32 bits in size. And a long, long is 64 bits in size. So if
you're looking at the show notes, I've got some quite interesting code snippets there.
And, uh, yeah. One important thing again is that these types can actually be used on their own.
So I could say, I want a short, okay, or I want a long, or I want a long, long, and you could
actually define variables that way. Or you could go, I want a short int, I want a long int,
I want a long, long int. Okay. If that makes sense. Okay. So a char. This is our second data type.
So we went through an int. And we now know what an int is. So we have a char. Uh, a char is actually
one byte in memory. So that's eight bits. It holds a character, but also can hold a number. So one
important thing to note about C, um, that's a little bit different than most languages. Um,
is that characters are actually just numerical values. So if you look at something called the
ASCII table, which is, I included in the show notes, it's got a mapping of all characters that
it can look at. And, um, now I'm just going to stick with the simple character set, which is the
ASCII. I mean, there's, there's different ones. There's the UTF and all of these different things.
But for our purposes, I'm just going to say you have your, uh, specific values, uh, dictated in
the ASCII values are in the ASCII table, sorry, that correspond together. So for instance, um, A is,
let me just do a little quick Google search for ASCII table here. So,
sorry about this. Okay. All right. Um, okay. So for instance, we have lowercase A.
Lowercase A is 97. So if I did a, uh, if I went to print 97 to the screen as a character,
it would be A or the same could be said for printing A as a decimal or an integer, sorry, and it would be,
uh, 97. Or yeah. So it, it all just works out. So that's one important thing to note about the ASCII
table. Um, now what else could we look at here? We could look at a couple other things. So our
char is basically just a way of denoting, like the char name itself is just a way for the programmer
to know that this is a character, you know. Um, and it's really important to know that
char's, you, you define a character using the single quotes around it. So if I, I can make a, uh,
char variable that held the letter X with single quotes around it, or I can make a char value
that held the number 72. So like I said, they're just numerical values. Now what else do we have here?
We have floats. Now one or big, now float floats, uh, they hold as the name suggests, floating point
numbers. Okay. So floating point numbers, they're a little bit iffy when it comes to programming
languages. I don't know if you've had any experience with them, but especially when you get low level
as, as low level as C is, floating point becomes a little bit more risky and, uh, it becomes a
little bit harder to use overall. Um, but you can, you can have floating point numbers in a float
and support is becoming much more available for that. So if you compared it to from now until like
75 or however many years, you know, it's our, our improvement for floating point has definitely
got better with GPUs and whatnot. So not, it's not really as big a concern right now. So, uh,
floating point as the name suggests, you just define float with X equals, uh, 72.2 or whatever
the case may be. Uh, now a double is like a float, but it can hold a larger value. So those are
your forming types in C. You've got your int, you've got your char, you've got your float,
you've got your double, and there's a couple other things that I want to talk about. Now,
what are arrays? Now arrays are a very important subject in C, especially because, uh, arrays are
basically collections of multiple things. And they have to be a set size. So when I'm defining an
array, I put the data type and then I put a space and then I put the name of the array. So in this
case, I'll call it array of numbs. Okay. And then I put an opening square brace and then the number
of things I want to store. So if I want to store a hundred inns within this array, then I put the number
a hundred. And then I close that brace and then I hit the semicolon. Oh, that, I guess that would
be an important thing. I don't have it in my notes. Um, to end a line as such with English,
you would use a semicolon. So anything that we're doing, we're using a semicolon for. Okay. All
right. So it'll be almost like writing a sentence and putting a period at the end. You throw a
semicolon on the end and you're telling the compiler this line is finished. Mr. compiler,
you can go ahead and move on to the next one. Okay. So back to arrays. I'm sorry. I'm a little
scatterbrained, but like I said, we're just moving along with this. So I'd like to get some feedback
on my show overall. So if you wouldn't mind taking the time, that'd be great. So we're array,
back to arrays. Arrays are collections of multiple things. Uh, they have to be a set size. So if I
want to say I got to, I got a hundred arrays of numbs or a hundred inns, a hundred numbers within
this array or a hundred integers within this array, then I have to say 100 in the declaration.
Now I can't change the size. I can't go around adding 101, 102. Um, and that's the most
important thing there because you know, memory is not willy nilly. I can't just throw blocks of
memory around like it's Minecraft. I've got to uh, make sure that my memory is protected where
it needs to be protected. And then I'm using the best thing possible in terms of how I uh, how I
uh, make sure my memory isn't being uh, treated like it's just something to throw away. And that's
the difference between a garbage collected language and this sort of language. So in most
languages, there are something called strings. Now if we use this concept of arrays that we just
learned, we can say that strings, um, we can say that what are a string mostly like what in
terms of understanding what a string is. Well, let's think about it for a second because we've got
our, we've got our char data type, which is just a character. So then a string. So the name
call in mills, for instance, well, isn't that just an array of char? I mean, it's a multiple set
of char's. Okay. So then in C, uh, strings, and I have strings and quotes in the show notes,
um, are made up of multiple char's. So, um, if you think about it, it really does make sense.
Um, an important thing to note about this is that as with any array, you can't go messing
around with the, with the numbers of things in that thing. So you can't be like, oh, my string
actually needs an extra character. So I want that string to hold, uh, call in mills,
R, R on the end. No, that can't happen. When you define a string in C, it's got to be, uh,
it's got to be a fixed size. Now there's an important thing that determines for the compiler to
know when that string is finished. And that is the null termination. Um, so the null termination
is a slash zero. So I've got, uh, I've got it here, but it's, it's a slash zero, okay?
And that slash zero, it tells you that, uh, the string is finished. It tells the compiler,
this string is finished. I don't, uh, this is where I want to end the memory that I'm using here.
And it's added to everything as such. Um, it's really best to, well, it's not best. It's a must
to define your strings with an extra character on the end to hold the null termination,
because that's added every time a string gets defined. So that's really important to know. Okay,
I'm just going to take a sip of my coffee here.
At the null termination comes up to the end. Okay. So we don't want to go past this null termination.
Okay. So I know that it was kind of a whirlwind tour through the sea types.
And I mean, I probably could have recorded this a little bit better,
but I'm doing this as a test run and to make sure that I, I know what I'm doing and make sure
I want to continue this because I on, I personally do. I enjoy podcasts and most of all,
I enjoy listening to podcasts. And, uh, I mean, HPR is run by people like us. So I want to be
part of that movement, obviously. Um, so I will be back in the next couple days, probably.
I will actually, I don't know when you'll be listening to this. So I'm going to record,
let's say the date is, uh, the sixth of May. I'm going to record a couple episodes
for the rest of this week and we'll have a good old time. Next time, I'm going to do maybe a
little bit of a recap through, uh, through some types and make sure we understand that. And then
we will go into, um, control flow because that's really important. So, um, yeah. Thank you very
much for listening to my rambles, but, uh, I hope you have a great night and I really do appreciate
it. Okay. All right. Until next time. Keep on, uh, keep on seeing. Bye.
You've been listening to Hacker Public Radio at Hacker Public Radio. We are a community podcast
network that releases shows every weekday Monday through Friday. Today's show, like all our shows,
was contributed by an HPR listener like yourself. If you ever thought of recording a podcast,
then click on our contributing to find out how easy it really is. Hacker Public Radio was found
by the digital dog pound and the infonomican computer club and is part of the binary revolution
at binrev.com. If you have comments on today's show, please email the host directly, leave a comment
on the website or record a follow-up episode yourself. Unless otherwise status, today's show is
released on the creative comments, attribution, share a life, 3.0 license.
