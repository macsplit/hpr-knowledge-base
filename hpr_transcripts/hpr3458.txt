Episode: 3458
Title: HPR3458: Living in the Terminal 2: The Obligatory Sequel
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3458/hpr3458.mp3
Transcribed: 2025-10-24 23:51:34

---

This is Hacker Public Radio Episode 3458 for Wednesday, the 3rd of November 2021.
Today's show is entitled Living in the Terminal 2, the obligatory sequel.
It is hosted by Black Colonel and is about 61 minutes long and carries an explicit flag.
The summary is, a very tired Black Colonel, tries to handle feedback from the previous episode.
This episode of HPR is brought to you by Ananasthost.com.
Get 15% discount on all shared hosting with the offer code HPR15. That's HPR15.
Better web hosting that's honest and fair at Ananasthost.com.
Hello and welcome to Hacker Public Radio. My name is Black Colonel and today I'm going to be going
over sort of the obligatory sequel to my Living in the Terminal episode. I didn't expect that
episode to get as much feedback as it did. Kind of was expecting more feedback from
the rest 101 series. But that shows how much I know about any of this.
I'm just going to try to get into it because this is the 3rd time I've tried to record this.
And I keep going off on really wide tangents. While I'm okay with going on tangents,
as I'm doing now, I want to try to keep it a little bit closer to reality.
So, starting out with the email feedback, I got some feedback from Dave Morris.
A lot of feedback from Dave Morris, actually, because apparently I can't write HTML.
I've tried writing it in VimScript or not VimScript, Jesus. I've tried to write it in VimWiki,
tried to write it in Markdown, tried to write it in Restructured Text, AskyDoc.
And I even, even though I don't know how to use it, I even loaded up Emax to try doing it in
org mode and none of it worked. All of it had, or rather, none of it worked automatically.
All of it had problems once I ran it through PanDoc. Mostly when it comes to,
it wants to wrap code blocks in span tags, rather than pre-tags, which I don't know why.
So, and then even when I did it manually once, I misordered the nesting lists.
And apparently that all flagged his Validate HTML, PerlScript.
And so, I've been getting a lot of feedback from him at regarding that.
I ran this one, the show notes for this episode, through that Validate HTML PerlScript.
So, it should be good, because it didn't give me any errors.
And so, I'm eagerly awaiting to hear, to get your email, Dave Morris, about how this episode
still failed and how I suck at writing Markdown languages that aren't based on latex.
We also talked about something which I put on the Hacker-Pull-Cradio mailing list
and Ken Fallon told me to write an episode about it. I have, I'm not lacking for ideas for episodes,
so I'm just going to put the idea that I had there here, because it's not even production,
it's not even like beta testable, like I haven't written any code for whatsoever.
I just have an idea and sort of pseudo code for how I would want to structure the project.
I'm calling it Project Wellermann, because it's a podcasting sort of application, podcast
deployment application, that I want to, that I'm modeling off of the auto tools workflow.
So, the idea is essentially, you would have a, you would have your source files,
you'd have your raw, like your intro music, you'd have your transitional music, you'd have your
different sections of your podcast, maybe, or maybe there's just one section.
Maybe you have ladspa effects, or any other things that you would have in
the sort of the editing of your podcast. You'd have those in an XML file, or rather,
you'd have those all in like a source folder, and then you have an XML file which tells,
or which sort of outlines how you would edit it together. So, like, apparently there's a
file format called SESX, which is done by Adobe Premiere, I think, but it's XML-based,
so I've been told. And apparently it does a lot of the same type of thing.
And heck, if it's good enough for Adobe Premiere, which everyone apparently thinks is like the gold
standard for everything anyway, then it should be good enough for this if I can figure out how it
works. But the idea is that you'd write it all out in the XML file there, that's how you'd
want to edit it, which means that your initial files can be unedited with all of your mistakes
and all of that in it. And then you would have your XML file which would say how to edit it,
like it would also be divided up into the different sections of the show, so you'd have your music
as a certain tag, you know, of your sections, a certain tag, all of that kind of thing,
in your fixes, a certain tag, and then you would have a make file which would take in that XML,
run it through, like, ffmpeg, and then spit out your edited podcast, as well as maybe having a
make trigger in it, like, make publish or something that would write it to a, that would upload it to
a server and write the content to a Adam feed and stuff like that to sort of automate the publishing
process as well. And then you could, this is the thing that really sort of made me want to do this,
because so far this is just more work rather than less work, but there also could be a configure
shell script, which would allow for you to configure the way your output was, so you'd be able to
output it to, like, if you did configure dash dash opus, then you'd get an opus file, if you did
configure dash dash m4a, you'd get an m4a file out, if you did a configure dash dash mp3,
you get mp3 out, if you really needed to have an mp3 or whatever, which I'm not necessarily condoning,
but, you know, people, that gets back to sort of the reason why I would want to do this,
because, like, the idea that I first had, like, the thing that made me have this idea was having a
configure dash dash no music dash dash speaks. So it would give you a speaks file without any music in
it, because speaks historically and famously does not handle music very well. But this will let you
be able to, first of all, you could automate this into having multiple different feeds
from the same source file, but then in addition, you could host the source code itself,
which would allow people to not only kind of run their, like, custom compile it themselves,
if they're one of those people that needs an mp3 file or something, they could compile it themselves,
or it would also allow them to look at your unedited files, presumed providing you actually
don't edit them, which I understand that there are some reasons why you might want to do it anyway,
because you might edit it on the fly, or you might be in a situation where you're doing a live
podcast anyway, so it's not really edited to begin with, so you don't really need to edit it even
in post. But they could look at your unedited files and sort of get a feel for how people
sound before they process their audio, which would help people sort of realize that this isn't,
like, you don't need special training to do this type of thing, you can just
pick up your phone and record into it if you want. You can record into your laptop microphone,
you can do whatever, it's just, it's not that big a deal. Yeah, so this is sort of the idea
that I had behind Project Willermen, and I will work on it myself at some point, but I'm in the
middle of a lot of different projects at the moment, in addition to being up to my waste in ideas
for more hacker public radio episodes that I am struggling to have time to record as it is.
But so if anybody else wants to work on that, feel free. I would prefer if you didn't use the
Project Willermen name, or if you, no, I would prefer if you didn't necessarily use that name,
because I would like to use that for my own project. And then if we have like,
although I might just, like, if yours is infinitely better than what I would ever do, then
like go for it, and I'll let you use the name, but it was one of those things that's like,
I do like that name. I mean, I'm not going to like sue you over it or whatever. I don't really
care that much, but just, I would like to use that for my project just because I like the idea
of it being a podcast, and it being a Willermen who casts towards pods, it's kind of a cool thing.
And at the risk of making this tangent too circuitous, I'm also going to say that a whimsical idea
that I had that I wanted to add to Project Willermen was while it is quote-unquote compiling,
because I know that FMPEG can take a long time to render files. If you don't have a fast computer,
I was thinking about trying to write a using co-proc like Dave Morris went over in one of the
episodes back in Hacker Public Radio. Using co-proc to use the beep command to play
the Willermen, the C-Shanty out of your computer while it's compiling, I think that would be fun.
Anyway, moving on to the next email got from Hacker Defo,
who sent a lot of really good suggestions, one of them which I was blown away by was something
called Less Term Cap. So apparently, everything you can do in most, which is like the
pager that I mentioned last time, which has a lot of pretty colors, it has a lot of very good
visual feedback for your terminal provided you can utilize that visual feedback to begin with.
Like apparently you can do all of that at less with environment variables. So Hacker Defo sent me
a bunch of, well, really it's one file and then a way of sourcing that file into your bash
rc. And this is going to be in the show notes in pre-tags so it shouldn't flag the validate HTML
Dave, but it basically exports a bunch of Less Term Cap environment variables to add in the bold
and all of this kind of stuff. And I don't know how any of this works at all, like all of this
is Greek to me, but I do know that it works because I've tried it out and it makes it look good
in less. So you don't need to use most, you can just use less, use all of the stuff that you're
used to from last as far as keyboard shortcuts and moving around and all that kind of stuff.
And I actually like it a little bit more just because it's a little bit more minimal where most has
a lot of really big flashing lights and it uses like red and gold and all this kind of nonsense,
which is kind of straining for my eyes. Whereas I think that this uses your terminals
like whatever color scheme you have set up in your terminal, which is a lot nicer for me at least,
because I mean there might be something else to it. As I said, I have no idea how this works.
I will have to look it up at some point, but for now it makes your less
page your look really pretty and then the BasharC basically just checks to see if you have that file
and if you do, then it sources it into your BasharC so that it loads up all those environment variables
when you start your terminal. Hackadepho also sent me a list of three more terminal-based podcatchers.
Pocca and G-Potter CLI are fine. They're not my style. I don't particularly like their layout.
I can't remember why off the top of my head. I think I still have Pocca installed. Let me see if I
do... I do not. Okay. Well, the point is, Castoro is good. I like Castoro a lot.
Castoro has that CMuse-like feel, which is something that I really enjoy like that. That is the
type of two-way interface that I like for a music player. I would say that it reminds me of Midnight
Commander, but I'm going to get why that would not be a compliment coming from me. But it does
kind of remind me of Midnight Commander, but it's a music player, so it makes sense as an application
that I would use. But yeah, I think Castoro is my favorite of these three, and I'm probably going
to use it more in the future. I mean, that's really all I have to say. I'm going to try to... the
problem that I've been having is just not having time, so I end up using the podcatcher on my phone
rather than trying to transfer it over to my phone for my computer. I mean, I have ways of doing
that. It's just takes more time. I have less access to Wi-Fi for a lot of reasons, so I end up having
to use data and all that, so I'm not going to use Castoro as much as I would like, but it is a very
good for people that need it for their computer. There's also a thing that came up about why I don't
like Python or also Java's in the same category, and it isn't for any kind of like rational reason per
say, so when I learned about programming, you can listen to my Journey in Technology episode one
for more information on this, but when I was taught programming, I was taught op code assembly.
Like the whole concept of an operating system didn't exist for me as a kid, like when I thought
about a computer, I thought about the individual transistors switching and flipping and the way
that the op codes in that are hard coded in the processor operate in order to give you hardware
output. That was sort of my understanding of computers, and the more you abstract away from that,
the more uneasy I get about it, because it provides more chance for failure, it provides more chance
for unintended behavior, and this has been shown in like the early days of Python and Java,
there was a lot of memory issues, and a lot of just weird things, which I've heard that they've
gotten a lot better, and I know that Python is apparently super secure now, and Java is apparently
also super secure now, but I just it makes me just isn't sit right with me, and it's not like it
doesn't it's not that it's slow, which I've heard that people say like I don't care about that,
because it's going to be in the matters of milliseconds really, and for like an application you're
running on your desktop doesn't really matter, it's not an embedded system, but like that memory
leak issue, and those sort of security concerns do kind of bother me a little bit,
and it's just when I'm using a program that I know is written in Python, or I know is written in Java,
it's something that I can't help but think about sometimes, and just for full disclosure,
Castero is written in Python, I'm trying to do sort of better with that because I know it doesn't
matter as much as I think it, well, it matters probably precisely as much as I know it does,
but it doesn't, it feels like it matters a lot more to me because it's just like, I don't know,
it just seems weird to me, I guess, I mean, I know why it happens, I know it's important,
because it allows for it to be more portable and allows it to be moved around between
more systems, but just feels a little bit uglier, which I don't know, maybe I'm being too judgmental
about the programming languages, but either way that's sort of the reason why I don't prefer to use
Python or Java programs is because they just aren't an elegant programming language in terms of
operation, and that is something that I think about while I'm using the program, and it does impact
the amount that I enjoy using the program, and as I said, it's not a rational explanation,
it's purely an emotional thing, but that's the reason why I don't prefer Java or Python,
it's just too abstracted from the hardware. I haven't actually gotten a chance to try this one
out yet, but Hagridepho also sent me a link to a way of using the proton male bridge with mutt.
So a bunch of people did send me the stuff about proton male bridge, which I have used in the past,
but the thing that I've had problems with is I have like five proton male email addresses,
and it's difficult for the bridge to handle all of them at once,
and I've even had situations where the bridge would crash, and then when it rebooted,
it would re-duplicate all of my emails in my inbox and stuff like that,
and it just wasn't really working out very well, which is why I stopped using it,
but maybe it's gotten better since I used it, I don't know. I'm going to go back and check that
at some point, but let me know if anyone else has had that problem before, or if that's just a
methane, and if there's anything I can do to fix that, before I end up with that problem again,
hope preferably. That's pretty much all the email that I got, so I also got a lot of comments,
a lot of comments actually, on the last episode, which is kind of weird to me because,
well, I mean, I guess it's not kind of weird to me, but I don't prefer that because I,
the comment systems on websites are really clunky, and I know that it's a little bit better
on hacker public radio with the anti spam question and all of that kind of stuff, but it's just
one of those things that I would prefer to just get email about it because it's easier for me
to respond to email, it's less per barrier to entry, I can respond to email on my phone,
it's very difficult to, well, not very difficult, but it is very slightly inconvenient,
like the least amount inconvenient, but like it's very, it has that tiny, tiny barrier to entry
that I just can't be bothered with while I'm at work, or something, to reply to comments on my phone.
But I will go over all of the comments that I did get and sort of respond to them in audio form
here so that I am responding to them. So the first one is from Operator, which said,
kids these days, I'm going to read out the whole comment, I know that they do this on the
community news as well, but I want to be able to read out the whole thing so that I can
respond to it properly. So Operator said, wow, I didn't think people like you really existed,
mad props. Me four days ago would have asked you about playing music through an SSH tunnel,
but I switched to Plexamp for music because my wife uses Subsonic too. I think Subsonic is dying,
another thing is I really enjoy the highlighting in my Windows mobile X term terminal. I've tried
a few times get my entire terminal set up with syntax highlighting and keyword stuff like
MOBA does, but it is app specific. So for example, in six, I can have nice colors,
then I can leave the terminal and I get black and white, or leave,
that is what it says. I believe that he means leave to the terminal and you get black and white.
One is everything highlighted everywhere. Now, I don't use Windows because if you've heard my
second episode of my journey into technology, I hate talking about Windows and Windows has
done me wrong in a lot of ways, mostly just because I'm not used like as a kid, I didn't
like an operating system doesn't make sense to me as anything other than a convenience.
And Windows is not a convenience. Windows is a hindrance. I would rather not have an operating
system on my computer at all and type in raw up codes in order to like do functions and load
programs via their up codes like via the actual machine language rather than use Windows. I mean,
honestly, I probably wouldn't rather do that anymore because nobody writes in up codes anymore,
so I would need to have some kind of operating system. But I would rather use that,
what is it? There's a Linux distribution that can fit on a single floppy drive or floppy disk.
I'd rather use that than Windows. Like, then Windows 10 because I can't. It's sort of like with
the Python thing, but like so much more because it actively prevents you from doing things,
but it's like one of those things that even when I'm able to do what I need to do, I just know that
it's under duress and it's very viscerally emotional for me as far as that's concerned.
But if what you want is syntax highlighting and colors everywhere and all of the flashing
lights and everything to be super pretty and interactive, I will recommend Fish to you,
which is the friendly interactive shell. I'll put a link to it in the show notes.
I used to use it a lot more. I've switched back to bash because of POSIX compatibility.
But hey, if you're using Windows anyway, you probably don't care about that as much as I do.
And you will get all of the colors in the rainbow. You can still use bash scripts as
long as you have bash to install and the magic cookie line, the hash bang or the shebang at the
beginning is there. It'll run through bash instead of through fish. And then you'll get all
your POSIX compatibility and all that. But that has all of the colors and it has
really robust tab completion, like really robust tab completion. It also has a much nicer
scripting language than bash in terms of actually being a programming language and not an
ASCII text stream with pre-processing applied to it, which is kind of what all bash is really.
But yeah, so fish would be my suggestion there. I'll put a link to it in the show notes.
I actually don't have it in the show notes at the moment, so I'm going to have to add that and
then rerun the valid HTML to make sure that Dave Morris has a reason to yell at me rather than
no reason because I'm just an idiot and that's not a reason. Anyway, next one is from BeZ,
which is plus one for scene use. I don't really know what scene use is, but he explains in the
comment that he meant to say CMuse. He says, thank you for this great show. I also use CMuse.
It is the only program that doesn't choke on my extremely large music library that I have on an
NFS mount. I will be trying out most and I encourage you to try out Ranger. So, okay, I'm going to
try to take this one step at a time because you'll find out. But first, just to talk about the
large music library, my brother has a music library that is, oh geez, I want to say it was almost
300 gigabytes of music. It might actually have been more than that, but I'm remembering it was
at least 300 gigabytes of music. A lot of instrumental stuff, a lot of weird, like
progrock, power metal, down to lowercase and country and pop and just all kinds of crap.
And it was 300 gigabytes on his hard drive. And he used XMMS. So, I would suggest trying out if
you're looking for graphical like replacement as it were for CMuse. If you want to use graphics,
I would go with XMMS. See if that works for you. And if it doesn't, then let me know about it because
that's what I'm remembering that he used. And if you have more music than 300 gigabytes,
also let me know because I would like to download all of it at some point, although I don't know if
my bandwidth would talk to me after that. But I would like to download it, whether or not I
actually could. In relation to most, I also talked about the that you can make less look like most.
I encourage everyone to try out most anyway just to see what it is and to see sort of
compare it to less and less with the less term cap and all of that kind of stuff.
Just to see what you prefer because, I mean, really that's also about.
And I would like that to be the end of the comment. But no, he encouraged me to try out Ranger.
Now, I'm going to double check. I'm pretty sure I know what Ranger is.
Because it's part of this group of things. Yeah, no, it's what I thought it is.
So I hate file managers. Like I hate them. I hate file managers. I never use file managers
when I can help it. Like for very few things, I will use a file manager when it fits the particular
workflow. But that is going to be a graphical file manager because that's sort of the workflow
that I need to do. Like the last time that I used a file manager, we're actually wanted to use a
file manager was because I needed to I needed to restore a bunch of things for my trash can.
And so I opened up a file manager. I used control to click through
and select all of the files I wanted to restore, right clicked and then restored.
Like that kind of stuff I can do with a graphical fire manager.
I don't understand Midnight Commander. I don't understand Ranger because it's text-based.
And I won't, like, I can't, like, sure. I don't even know if I could do that in Ranger or in,
I mean, I guess I should look into it maybe. But yeah, no, it looks like it does have a
no, it doesn't because this is just moving it to the trash.
Although it does apparently match up with GIO, which is nice if I was using GNOME, which I'm not.
So I don't even know if this has GIO or KIO for that matter.
So the problem is is that if I do something like this, unless I'm not reading something
correctly, is that it wouldn't handle my trash info files or my directory sizes file,
which is annoying because then I'll just have these trash info files clogging up my info directory.
And I don't want to deal with that. And my graphical one handles all of that because it has
integrated trash can nests. But I just hate file managers. Like, even the graphical ones, I don't
use them very much at all. Like, usually, if I need to select a bunch of files, I will just
move them on the command line or I will copy them from the command line or whatever as far as that's
concerned. I'll just CD into the directory. And let's say I just want to look at my, at an
overview of all of my file system, like I want to get that visual feedback. Well, I have this
wonderful program that I'm sure everyone here, like I think everyone listening to this has probably
seen whether or not you know that you've seen it is up for debate, but it's called, where is it?
It's called FSV file system viewer. And the place where your file system visualizer.
And the place where you might have seen this is if you've seen the movie Jurassic Park,
and you remember this line that I'm terrible with names, but it is the young girl in that movie,
the hacker. Beautiful character. She says it's a unique system. I know this. And the thing that
she is using is FSV. I think it was probably, I think it was called something different at the time,
but it's the same program. And it does the same thing where it lets you view your file system.
Now, it doesn't really let you open the files because reasons, I guess, but it lets you see sort
of give that visual feedback of the file system. It's actually kind of useful if you want that
sort of visual feedback and you want to sort of get a sense for what is taking up space on your
computer. But yeah, besides that, I just don't like using, I don't like using file managers in
general. And when I do use file managers, I would use graphical ones because text-based ones
don't make any sense to me. Like, why wouldn't I just, if I wanted a two-pain setup,
okay, Control-B, Control-5, or should I Control-B, Shift-5, which is vertical split on T-mux. And
wow, I have split panes and I can see the end of one directory on one and see the end of a
different directory on the other. Now, if I want to have that sort of experience of watching
my files hoop over to the other directory, I'll just do like, let me make sure that I'm not
making up that I can do this. A bit of a terminal. T-mux, so let me do get that split-pain view.
Go over to downloads in this one. And what can I move over to somewhere?
Yeah, I'll move over to those. So if I then CD over to my pictures directory,
on this one, then I do watch, LS, watch space LS. Yeah, so I have an LS, I can see the contents
of my pictures directory there. And then if I do a move,
um, separ-separalling.png, two pictures, or two till-day slash pictures,
then I can see it pop up in the other other pane like that. If I actually like want to do that
for whatever reason, so you can just do that. I don't see the point of a text-based
file manager. File managers are intrinsically gooey-based to me because you have the commands
on the command line to do all of those processes. You can move files, you can copy files. If you
want to get into selecting certain files, you can use RegX, utilizing like parallels or find
whatever you can use, or even LS and GREP. You can use pushD and popD if you want to get like
different, if you want to like organize different directories to put things into. You have all
of these tools on the command line that I just don't see the point of a file manager on the command line.
Like I feel the same way about midnight commander about all of those. It's just not
something that makes sense to me. Um, I thank you for encouraging me to try something.
I just- I believe I have tried Ranger years ago, but I didn't see it as anything particularly
different from midnight commander if I'm remembering correctly. All the time that I'm saying about
yeah no it's- it had the same feel as midnight commander to me which was just like confusion
mostly of why this exists. I'm sure it works great for some people and if you want to tell me
why you like it, I would be happy to hear about it. It just doesn't have any special place for me
at all. Um, so moving on, we have the text by Sasami Mucho, which says thanks for the show.
At one point I used Emax on the console because it didn't have enough RAM to run X windows and
compiler at the same time. Uh, never set up. Uh, sat down and got the Linux console to use a
good font. To these days I run the i3 window manager. Uh, so I get a lot of terminal windows and
graphics apps as needed. If you're looking for an improved sort of end curses, you could look into
the textual framework. Uh, figured there'd be more comments here about six. Uh, I kind of did two
about the more comments about six. Uh, a lot of people don't really know what the the origin
story is behind six. I told this to hacker Defo in an email. Um, but basically as I'm sure we're
all aware that, um, there's this thing called sysv in it back in the original Unix days, uh, which
was the init system RC file RC dot DRC files, all that kind of stuff. If you, if you slack wear BSD,
now you should be pretty familiar with the sysv type of system. Um, but it seems to be like the
init system seems to be the sort of thing that people just kind of want to keep tacking things
onto. And one of the first things that they tacked onto it was was the text out of their six,
which is why it's called that because it's after, uh, sys 5 or sysv in it. Um, and then later on,
you ended up with people tacking on so much stuff to it that they ended up calling the whole
conglomeration, uh, system 500 or I've heard some people call it system D.
Uh, but yeah, just the, the D for 500 in Roman numerals like how sysv in it is actually system 5 in
it because it came after system four. Um, and then you have six as sort of the thing that was tacked
onto system five. I don't really know if they kept the text editor portion of in system D,
which would be surprised because they kept everything else and then more. But that'd be an
interesting. If, if anyone knows what the text editor component of system 500 is, uh, please let me
know. Um, as far as the textual framework goes, I actually didn't, I actually forgot to look
this up. So let me look it up really quick. Uh, see if I can get some screenshots of the very least
textual framework. Oh wow, this looks really cool actually. Really cool. Maybe. I might use this
in a project that I'm working on. Um, but I'm not entirely sure. Looks like I might be a little
too heavy for, for what I am actually wanting. But maybe I'll, I'll think about it. I'm,
I might just use dialogue and encurses because it's a little bit lighter weight than what this
looks like it is. Yeah, and it looks like it's a Python based. So it is kind of on the heavier side.
Um, I think I'm just going to stick with encurses for now, although this is a very good thing to
know about for if I wanted to make a more heavyweight application. But I'm just, I'm usually not a
fan of heavyweight applications. Or if I'm going to make something that heavyweight,
I mean, if you don't have enough, uh, ram or processing to run X, I don't really see exactly
why you would work run textual. And that totally sure. I'm not, I mean, I can see that it's saying,
um, that it has like a more web UI type of syntax, which is, it does nothing for me because
I never was into web UI as I'm going to get into in the next episode of my, um, my journey into
technology. But it just, I'm not really seeing where this really excels where, uh,
end curses is concerned. Uh, let me know what I'm missing because my, my idea is that if you're
writing an end curses, your idea is maximum affordability. And this doesn't seem to be
maximally portable because it's based on Python. And it seems to be sort of a little bit like,
heavier weight, like everything, like most Linux distributions come with live end curses,
which is based on C, uh, and uses the traditional framework for, um, GUI applications as far as
it's the way that it structures its, um, API handles. Or as this seems to be more web based,
which might be good for some people to write it, does nothing for me really. And it seems to be
a lot heavier weight, like not GUI levels of heavy weight, but heavier than end curses weight.
Uh, and it looks like it only has Python bindings. If I'm reading this correctly,
yeah, only has Python bindings, which is not particularly interesting to me, although I,
I should probably get back into Python because I, I did use it for a while. And I think I might
just be being too judgmental towards Python, the more I think about it. So I might get back into that.
Uh, anyway, so it's a good, uh, suggestion, but I don't really see the point to it.
Really kind of in the same way as text-based file managers, it just seems to be
bloat, I guess. Like I'm at least for me. Like if somebody has some kind of really, really good
reason that it isn't bloat, let me know because I do want to use more of that kind of stuff. It's just
like, I want this to be able to run on anything that can run end curses and it seems like that
would not be the case. And I know you might be thinking of, well, oh, everything is a 64-bit
machine now with at least two gigabytes of RAM, but I actually might be in the process of acquiring a
Windows 95 computer or Windows or a computer whose original operating system was Windows 95.
And I, I don't believe that it is a 64-bit computer with at least two gigabytes of RAM.
And I would want for my applications to be able to run on it. So that's kind of what I'm,
where I'm coming from as far as that's concerned. So about the I3 window manager, I like the idea
of tiling window managers. I really do because, I mean, of course I do. I like doing everything.
I just got through how I don't like window managers very much. I don't really like graphics. That's
kind of what this whole thing is about. And a tiling window manager is like the least of minimum
viable graphics as it were. But I do like tiling window managers, but there are sometimes where
when I'm using a tiling window manager, because it's graphical, because I'm using Graph Collapse,
I kind of have this hardwired thing of like, okay, then I want to just drag this window over here,
to have this sort of floating window staggered view and then drag this over here and then do it like
that. Maybe I want to drag a window onto the top of the screen and have it clip like snap into
full screen or I want to drag it to the side and have it go to a different virtual workstation
or those kind of things. And I just do that sort of instinctively. And on a tiling window manager,
it doesn't work. And I mean, I could get used to it. Of course, I could use to it, but I'd rather not.
I'd rather just be able to do everything that I can do with the tiling window manager
and everything I can do with the floating window manager. The ones that I've kind of set up for
this at the moment are XFCE, which is my preferred one. It's the easy one for me. I'm not going to
necessarily say it's my preferred desktop environment because I would like to have time to
configure flux box, which is my other one. I would like to be able to configure or have time to
configure flux box to be perfect to have that kind of melding of tiling and floating windows and
just like that's my that would be my perfect type of setup is having most of the things be able to
be done through tiling. So with all my keyboard shortcuts and all of that, but then not punish me or
not break my workflow if I default to floating window manager behavior. So it'll still operate as
a floating window manager anytime that I accidentally try to use it as one. It's kind of what I like about
that. But I do really like tiling window managers. And usually I'm using my
my computer like a tiling window manager. Like I never I almost never actually use the
applications menu. I usually just open up a run prompt and then run it from there. But
there are sometimes where I will use the application menu to just look around to like look at
what's on my computer. See if there's something that I've forgotten about as far as like a game or
an application or an accessory or as that what's called yeah an accessory or some kind of
graphic application like contrast. What is that? I don't know. It's definitely KDE app.
I need to work on figuring out what I'm going to be doing about all the KDE apps that come
by default on this computer. KDE I have a love hate relationship with. I like the idea. Like I like
I like a lot of the apps. I don't like a lot that they have so many dependencies. But that is what
it is I guess. Yeah great great comment and thank thank you for thank you for the comment.
Sesame Mucho. So the next one I have is very enjoyable which is sent by the master of the
validating of HTML himself Dave Morris where he said that he loved the show. I started on main
frames in the 1970s where all there was was teletape or physical terminal. I use X windows now
but spend the majority of my time in terminal emulators. Having spent today on in the Linux
console my deputy and testing system debugging a problem caused by the last update. I am appreciating
being back in KDE. The problem was due to multiple incompatible versions of the NVIDIA legacy driver
lurking in the system it's about wouldn't want to stay in the console though even with teamux.
Like you I'm a fan of end curses and I have a few ever in a few simple things in my time.
I'm a vim user and I'm contemplating moving to near them. I've written a few basic extensions
in vim script but they look of new vim's lewitt but I like the look of new vim's lewitt interface.
Finally you had me going for a moment calling six six having been an ed and x user in the past
versions in the past various Unix flavors. I remembered that six was abbreviated visual
command that gave you screen mode from x. Now I'm actually going to stop for this for the response
to this last part. I don't want to break the illusion but I also kind of do want to break the
illusion a little bit. Obviously I know that it's actually pronounced by and from NVI and all of
that. I'm not actually like it's a joke but it's a joke that I like so I want it to keep going
with it. But as far as this concern I actually did know that it was for visual because
believed or not I actually am also a user of ed and x as well as you know set and grip which
are based heavily on the ideas in ed and x as well as a pearl and a few other things but like
those were sort of the thing because when I got into Linux which was in 2006 mind you
2005 the 2006 but it was well passed when everyone else had stopped using ed but it was one of
those things where I was mostly like all right how am I like I don't care about how people are
using it now. How am I supposed to use this because I know that Unix was a thing back from the 70s
so what are the applications that they built into the system to operate with the system when
they introduced the idea of this thing called Unix and so I did spend a lot of time when I was a
kid learning ed and x and said and Vi even before them like using just straight Vi which
I'm glad I don't have to do anymore as well as all of that kind of stuff and it was a very
nice experience because I have had experiences with dot matrix printers, line printers so I understood
why ed operated the way that it did like I it wasn't weird to me that it only allowed you to
edit one line at a time and why it printed out things the way that it did and the way that it
sort of gave you that feedback because it was meant for a dot matrix teletype printer and I got
that pretty easily and then x obviously is a lot more complete than ed as far as like feature set
and then Vi is for if you actually have a screen and don't have to do everything on a printer
which is why it's called the visual which I know a lot of people probably find it funny that
it's called the visual when it's text-based but that's why it's because you can actually use a
screen for it and you aren't doing it on a printer so that's why it's visual but yeah I did
actually know that but it's really cool that that there are still other people that know that I
guess it's not surprising that Dave would know this considering that he lived through the 1970s
and the whole beginning of this whole unix with teletype thing but it's still fantastic to hear
about it like it's it's one of the things that I love about using Linux and using computers in
general as sort of having this like it's having a connection to the past even if you don't realize
it like if you're using a any form of if you're using any computer you have this sort of like
legacy that you're that you're utilizing like if you're using a um an AMD or an Intel processor
those are even if they're 64 bit they're based on the x86 instruction set which ties you back
to that legacy of the 8086 processor and that sort of 8-bit programming and back in those like
it gives you this connection to the history of that processor and if you're lucky enough to be
using a um a power nine processor you have that sort of legacy to the power PC and the the risk
or the original risk architectures as well as if you're using arm or risk five you have that sort
of legacy built into it as well but taking slightly different directions and it gives you this sort
of history that's very fascinating to me um but it's just great to hear from people that actually
remember this stuff viscerally like this because like I used it but I didn't have to use it like I
wasn't using it because I had to even though I acted like I did like I purposefully used it before
I used VIM like the first text editor that I used to edit files in uh Linux Mint so I didn't
have the benefit of starting actually I did have the quote unquote benefit because x actually crashed
the first time I I turned on my computer but the first thing that I um used to edit a file was
I used to edit my config files and all of that on Linux Mint and I had to read the man page in order to
do that the man pages wouldn't have I don't know about the history of man page I don't know if you
typed in man ed on a teletype printer if it would have printed out the entire man page on your
printer that seems slightly wasteful but um like I would think you would just have the manual
separate from that that you would have to pull out and read through it that way uh but either way
I read through the manual for ed and was able to utilize it and it was really nice actually um
yeah it's just fascinating okay okay now from from now on if anyone else mentions
mentions six I'm gonna I'm gonna refer to it as such because it's funny joke I think and it makes
it lets me make fun of macOS 10 people um so and the final comment I have on this is from
gumnos which says using c2 pause and cmuse which I feel like I I knew at some point I mean I'm pretty
sure I did but he he they say gum gumnos says uh the controls and cmuse are laid out like a
traditional vcr tape player from left to right on the bottom corner of a traditional query keyboard
so that z for previous x for play c for pause play v for stop and b for next I can't say this
helps me remember much but at least it's the reasoning behind the non-nemonic keys and that
actually really kind of helps me sort of remember it a little bit I mean same same boat as you
man uh it doesn't only remember it much but it's the way that I remembered it which is really dumb
but I remember just c for cmuse was how you paused because pausing and playing is basically all I
ever did in cmuse I didn't really go back or go forward because generally I have it on shuffle
anyway it's kind of just how I roll but that's really good information and thank you for reminding me
about that it's keyboard layouts for things are just not great sometimes um but that's all the comments
so now I have the two other topics that I wanted to go into a little bit one of which is something
that is a response to uh a conversation I had with um some guy on the internet which I
spent way too long trying to get this out because I should have responded to this like a month ago
or something uh but it's called a here document on the text line or on the command line
which is a way of very quickly and efficiently putting text into a file so you don't have to use
grip every single line on your files or not grip but it was it echo you don't have to echo pipe
or echo redirect it into a file every time that's just it's very difficult to read actually because
it all sort of melts together in your brain if you're looking at it for too long or if you're
very tired and I think that this is a little bit more readable so what you do is that you do the
command cat and then you do a redirect it's a greater than symbol and then the name of the file you
want to uh sort of cat everything into and then you do two less than signs so an internal redirect
into uh whatever file you want to append to and then EOF or actually can be anything but
traditionally it's EOF or end of file and then what you can do is you can
hit enter type in whatever you want and it will retain all of your styling so if you do a tab
it'll do a tab your space it'll do a space if you do a bunch of spaces it'll do a bunch of spaces
it'll it'll maintain your formatting and then after you write everything you want to write into
the file you just end it with EOF and then that'll put all of that except for the EOF it won't
put EOF at the end it'll just put everything between the cat statement and the EOF into the file
and you can use variables inside of this and it will expand out it will do variable expansion
you can do brace expansion you can do uh what what sub shell expansion you can all of
all of the bash expansion things inside of this as well as so what this will do is this will
overwrite the text file if you want to append to a text file you do cat redirect redirect so
it's greater than greater than than the file then less than less than less than than EOF and then
the same type of thing and that will append all of that to the end of the file in a very similar
way that you would do in echo then a double redirect for appending and then a single redirect for
rewrite same type of thing but this lets you write it without all of the echo statements
very good thing to know about makes your code a lot more readable lets you get rid of all of the
echo statements at the beginning of every one of your lines so it's saving you a whole like
what six characters five characters and it's just just a lot better
forgot the thing that I was supposed to link to at the end of this video at the end of this episode
and I forgot to add it so whatever I was talking about at the beginning of this episode
that I was going to add into the show notes it's probably not going to be there
I'm going to relisten to it after I finish recording so if it is there that's what I did if it's
not there then I was lazy and you can let me know that I'm lazy on mastodon or on email or whatever
and just yell at me because I deserve it anyway the last thing I want to talk about is
probably the most important use for your terminal like of anything like
more important than writing files more important than using the internet more important than
doing your taxes doing spreadsheets or any of that like this is the most important thing you can
do with your terminal and it's net hack which is which is beautiful I haven't played it in a long time
even still because I just haven't had time to relearn the movement commands which I know
wouldn't take a whole lot of time but I just don't have a whole lot of time to learn it at all like
every every time I have a spare minute I'm either catching up on my sleep working on my programming
projects or recording HPR episodes or dealing with other things that I don't want to talk about now
so I don't have time for net hack but it's a shame that I don't have time for net hack because it is
I really should be doing nothing else with my life besides playing net hack
because it is just so good it's such a good game and everyone in the universe should learn
how to play net hack and that's just how I feel about it um so that's about it for
this episode I will try to remember to uh relisten to this to put all the things that I
wanted to put in the show notes in the show notes as well as um I do have a bunch of stuff in there
at the moment anyway but let's talk to you guys next time bye
you've been listening to Hacker Public Radio at Hacker Public Radio dot org
we are a community podcast network that releases shows every weekday Monday through Friday
today's show like all our shows was contributed by an HPR listener like yourself
if you ever thought of recording a podcast then click on our contribute link to find out
how easy it really is Hacker Public Radio was founded by the digital dog pound and the
infonomicum computer club and it's part of the binary revolution at binrev.com if you have
comments on today's show please email the host directly leave a comment on the website or record
a follow-up episode yourself unless otherwise status today's show is released under creative
comments attribution share a light 3.0 license
