Episode: 932
Title: HPR0932: Programming languages 1 - Introduction
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0932/hpr0932.mp3
Transcribed: 2025-10-08 05:07:48

---

Hi, my name is Garjola.
This is the first episode on a series about computer programming languages.
In this episode, I will start by discussing why you may want to learn a programming language,
then I will give an introduction about what programming languages are, which are the different
types of programming languages, their history, and I will also give some pointers to resources,
which can be useful to get you started with programming.
Okay, so let's get started.
Why you may want to learn programming?
If you consider yourself as a hacker and like having control of what your computer does,
programming puts you on the creative side versus the consumer side.
I will adhere a section from Eric Reignanz, How to Become a Hacker SA.
This SA is available at HCTP.com, forward slash, forward slash, c-a-t-v, dot org slash tilde
e-s-r slash f-h-u-s slash hacker dash how to dot h-t-m-l.
Although a little bit old, it was written in 2001, this is a very interesting SA worth reading
completely.
Raymond lists the four basic hacking skills, which are one, learn how to program, to get
one of the open source unices and learn how to use it and run it, three, learn how to
use the worldwide web and write h-t-m-l, and four, if you don't have functional English,
learn it.
Eric Raymond starts by saying that programming is of course the fundamental hacking skill.
If you don't know any computer languages, he recommends starting with Python.
It is clearly designed, well documented, and relatively kind to beginners.
Despite being a good first language, it is not a toy.
It is very powerful and flexible and well suited for large projects.
Raymond continues by saying that he thinks it is probably best to learn C and Lisp first,
and then maybe Java.
I personally would recommend first Python, then C++, and finally Lisp.
Raymond says that there is perhaps a more general point.
If a language does too much for you, it may be simultaneously a good tool for production
and a bad one for learning.
It is not only languages that have this problem.
Web application frameworks like Romanian Rails, KPHP, Django may make it too easy to reach
a superficial sort of understanding that will leave you without resources when you have
to tackle a hard problem, or even just debug the solution to an easy one.
Raymond recommends that if you get into serious programming, you will have to learn C, the
core language of Unix.
C++ is very close related to C, if you know one, learning the other will not be difficult.
Neither language is a good one to try learning as your first, however, and actually the more
you can avoid programming and see the more productive you will be.
As Raymond puts it, C is very efficient and very sparing of your machine's resources.
Unfortunately, C gets that efficiency by requiring you to do a lot of low-level management of
resources, like memory.
All that low-level code is complex and background, and will soak up huge amounts of your time
on debugging.
With today's machines as powerful as they are, this is usually a bad grade of.
It is smarter to use a language that uses machines' time less efficiently, but your time
much more efficiently.
Thus, Python.
Raymond continues by writing other languages of particular importance to hackers, including
Perl and Lisp.
Perl is worth learning for practical reasons.
It is very widely used for active web pages and system and administration, so that even
if you never write Perl, you should learn to read it.
Many people use Perl in the way he suggests you should use Python to avoid superramming
on the jobs that don't require system machine efficiency.
You will need to be able to understand their code.
In my personal opinion, Perl has been losing attraction towards PHP on the web and Python
or Ruby on the systems administration side lately.
Raymond says that Lisp is worth learning for the different reason.
The profound alignment experience you will have when you finally get it.
That experience will make you a better programmer for the rest of your days, even if you never
actually use Lisp itself a lot.
You can get some beginning experience with Lisp fairly easily by writing and modifying
editing modes for the EMAX text editor or script-through plugins for the game.
He continues by saying that it's best actually to learn all five of Python, CC++, Java,
Perl and Lisp.
Besides being the most important hacking languages, they represent very different approaches
to programming, and each will educate you in valuable ways.
Raymond warns the wannabe hacker by saying, be aware that you won't reach the skill level
of a hacker or even merely a programmer simply by accumulating languages.
You need to learn how to think about programming problems in a general way, independent of
any language.
To be a real hacker, you need to get to the point where you can learn a new language
in days by relating what's in the manual to what you already know.
This means you should learn several very different languages.
Raymond finally says that programming is a complex skill, and that using books and courses
won't do it.
Many, maybe most of the best hackers are self-taught.
You can learn language features, bits of knowledge, as he says, from books, but the mindset
that makes that knowledge into living skill can be learned only by practice and apprenticeship.
What we'll do is A, reading code and B, writing code.
He recommends to read Peter Norvich's essay, teach yourself programming in 10 years.
His recipe for programming success is worth careful attention.
Let's continue with some definitions which are taken from Wikipedia.
A programming language is an artificial language designed to communicate instructions to a machine,
particularly a computer.
Programming languages can be used to create programs that control the behavior of a machine
and or to express algorithms precisely.
A programming language's surface form is known as its syntax.
Determs semantics refers to the meaning of the languages as opposed to their form.
That is their syntax.
A type system of a language defines how a programming language classifies values and expressions
into types, how it can manipulate those types and how they interact.
There are typed and and typed languages.
A language is typed if the specification of every operation defines types of data to
which the operation is applicable, with implication that it's not applicable to other types.
In contrast, an untyped language allows any operation to be performed on any data.
There are also static and dynamic typing.
In static typing, all expressions have their types determined prior to when the program
is executed, typically at compile time.
You can also distinguish weak and strong typing.
Weak typing allows a value of one type to be treated as another, for example treating
a string as a number.
A very interesting characteristic of a programming language is the availability of a standard
library and a runtime system.
Most programming languages have an associated core library, sometimes known as the standard
library, especially if it is included as part of the published language standard, which
is conventionally made available by all implementations of the language.
Core libraries typically include definitions for commonly used algorithms, data structures
and mechanisms for input and output, which are the different types or families of programming
languages.
Once again, I will just read some extracts from Wikipedia, from the Wikipedia page about
categorical list of programming languages.
The different categories of programming languages that I will list here are not exclusive.
First of all, we should have to define what is a paradigm.
A programming language paradigm is also known as a programming model, and it is an abstraction
of a computer system.
A programming language can support multiple paradigms.
For example, programs written in C++ or Python can be purely procedure or purely object-oriented
or contain elements of both paradigms.
Software designers and programmers decide how to use those paradigm elements.
In object-oriented programming, programmers can think of a program as a collection of
interacting objects.
While in functional programming, a program can be thought of as a sequence of stateless
function evaluations.
When programming computers or systems with many processors, process-oriented programming allows
programmers to think about applications as sets of concurrent processes acting upon
logical shared data structures.
Different programming languages advocate different programming paradigms.
Some languages are designed to support one particular paradigm.
Small talk, for example, supports object-oriented programming, Haskell supports functional programming.
While other programming languages support multiple paradigms, such as C++, Java, Common
List, Scheme, Perl, Python, Ruby, etc.
Many programming paradigms are as well known for what techniques they forbid as for what
they enable.
For instance, pure functional programming, this allows the use of side effects.
While structure programming disallows the use of the go-to statement.
Partly, for this reason, new paradigms are often regarded as doctrinaire or even rigid
by those accustomed to earlier styles.
Avoiding certain techniques can make it easier to prove theorems about a program's correctness
or simply to understand its behavior.
Imperative programming or procedural programming is a programming paradigm derived from structure
programming based upon the concept of the procedure call.
Several languages for imperative programming are C or Fortan, functional programming.
Functional programming is a programming paradigm that treats computation as the evaluation of
mathematical functions and avoids states and mutable data.
Examples of functional programming languages are Lisbon Haskell.
Object-oriented programming, OOP, is a programming paradigm using objects.
Objects are data structures consisting of data fields and methods together with their
interactions.
Programming techniques may include features such as data abstraction, encapsulation, messaging,
modularity, polymorphins, and inheritance.
Typical languages supporting object-oriented programming are small talk, Java, C++ or
Python.
Declarative programming.
Declarative programming is a programming paradigm that expresses the logic of a computation
without describing its control flow.
Examples of declarative programming languages are prologue or SQL.
Let's say some words about the implementation of programming languages.
An implementation of a programming language provides a way to execute that program on one
or more configurations of Harvard and software.
There are broadly two approaches to programming language implementation, compilation and
interpretation.
It is generally possible to implement a language using either technique.
The output of a compiler may be executed by hardware or a program called interpreter.
In some implementations that make use of the interpreter approach, there is no distinct
boundary between compiling and interpreting.
For instance, some implementations of basic compile and then execute the source align
at a time.
Programs that are executed directly on the hardware usually run faster than those that
are interpreted in software.
Examples of interpreted languages are Python, Ruby, or Bash.
Now again from Wikipedia, let's have a look at the history of programming languages.
In the 1950s and 1960s, the first three modern programming languages whose descendants
are still in widespread use today were design.
First fortune, which stands for Formula Translator, was invented in 1955 by John Bakos.
Then in 1958, Lisb, the Lisb processor, was invented by John McCarthy.
And then in 1959, Cobal, the common business-oriented language, was created by the short range
committee, heavily influenced by Grace Hopper.
Another milestone in the late 50s was the publication by a committee of American and European
computer scientists of a new language for algorithms, the Algole 60 report.
Algole stands for Algorithmic Language.
This report consolidated many ideas circulating at the time and featured 2K language innovations.
First, nested block structure that is to say code sequences and associated declarations
could be grouped into blocks without having to be turned into separate explicitly named
procedures.
And second, lexical scoping.
A block could have its own private variables, procedures, and functions, invisible to code
outside that block.
That is to say, information hiding.
Another innovation related to this was in how the language was described, a mathematical
exact notation, known as the Bakus-Norr form B&F, was used to describe the language's
syntax.
Nearly all subsequent programming languages have used a variant of the B&F to describe
the context-free portion of their syntax.
Algole 60 was particularly influential in the design of later languages, some of which
soon became more popular.
Algole's key ideas were continued producing Algole 68.
Some important languages that were developed in this period include AutoCode in 1952, IPL
in 1954, which was a forerunner to list, Flowmatic, which is a forerunner to cobble in 1955,
1957 Comtron, another forerunner to cobble, IPL in 1962, similar in 1962 also, and Snowball
also in 1962, CPL, a forerunner to see in 1963, basic in 1967.
The period going from 1967 to 1978 could be considered as a period establishing fundamental
paradigms.
This period brought a major flowering of programming languages, most of the major language paradigms
now in use were invented in this period.
Similar invented in the late 1960s by Nigger and Dahl, as a superset of Algole 60, was the
first language designed to support object-oriented programming.
C, an early systems programming language, was developed by Dennis Ricci and Ken Thamson
at Bell Labs between 1969 and 1973.
Small talk in the mid-70s provided a complete ground-up design of an object-oriented
language.
Prologue, designed in 1972 by Karl Merauer, Russell and Kowalski, was the first logic
programming language.
ML, built up a polymorphic type system invented by Rami Milner in 1973, on top of Lisp,
pioneering statically type functional programming languages.
Each of these languages spawned an entire family of descendants, and most modern languages
count at least one of them in their ancestry.
The 60s and 70s also so considerate debate over the merits of structure programming, which
essentially meant programming without the go-to statement.
Some important languages that were developed in this period include Logo in 1968, B, a
foreigner to see in 1969, Pascal in 1970, fourth also in 1970, C, small talk and prologue
in 1972, ML in 1973, Scheme in 1975, and SQL in 1978.
SQL initially was only a career language, and it was later extended with programming
constructs.
The 1980s highlighted consolidation, modules and performance.
The 1980s were years of relative consolidation in imperative languages, rather than inventing
new paradigms, all of these movements elaborated upon ideas invented in the previous decade.
C++ combined object-oriented and systems programming.
The United States government standardized ADA, a systems programming language intended
for use by defense contractors.
In Japan, and elsewhere, vast sums were spent investigated so-called fifth generation
programming languages that incorporated logic programming constructs.
The functional languages community moved to standardized ML and LASP.
Research in Miranda, a functional language with lazy evaluation, began to take hold in
this decade.
One important trend in language design was an increased focus on programming for large-scale
systems through the use of modules or large-scale organizational units of code.
ADA and ML all developed notable module systems in the 80s.
Module systems were often wedded to generic programming constructs, generics being in essence,
parametrize modules.
Although major new paradigms for imperative programming languages did not appear, many researchers
expanded on the ideas of prior languages and adapted them to new contexts.
The 80s also brought advances in programming language implementation.
The risk movement in computer architecture postulated that harbor should be designed
for comparers rather than for human assembly programmers.
Aided by processor speed improvements that enabled increasing for compilation techniques,
the risk movement sparked greater interesting compilation technology for high-level languages.
Language technology continued along these lines well into the 90s.
Some important languages that were developing this period include.
In 80s C++, which was first called C with classes and the name change in July 1983.
Objective C in 1983, ADA in 1983.
Common list in 1984, Aful in 1985, airline in 86, Perl in 87, TCL in 88, Mathematicals
in 88 and FL in 1989.
The 90s were considered the internet age.
The rapid growth of the internet in the mid 90s was the next major historic event in
programming languages.
By opening up a radical new platform for computer systems, the internet created an opportunity
for new languages to be adopted.
In particular, the Java programming language rose to popularity because of its early integration
with the net scape navigator Web browser.
And various scripting languages achieved widespread use in developing customized application for
web servers.
The 1990s zone of fundamental novelty in imperative languages, but much for combination
and maturation of all ideas.
This era began the spread of functional languages.
A big writing philosophy was programmer productivity.
Many rapid application development languages, AID, emerge, which usually came with an IDE,
garbage collection and were descendants of older languages.
All such languages were object-oriented.
These included object-pascals, visual-basic and Java.
Java in particular received much attention.
More radical in novelty than the AID languages were the new scripting languages.
These did not directly descend from other languages and feature new syntaxes a more liberal
incorporation of features.
Many considered these scripting languages to be more productive than even the AID languages,
but often because of choices that make small programs simpler but large programs more
difficult to write and maintain.
Nevertheless, scripting languages came to be the most prominent ones used in connection
with the web.
Some important languages that were developed in this period include Haskell in 1990, Python
in 1991, as well as visual-basic, Ruby in 1993, Dua also in 1993, Close in 1994, Close
was a part of NC Common List.
Java in 1995, 1995 also saw the birth of Delphi, which was object-pascal and JavaScript,
as well as PHP.
And what are the current trends in programming languages?
Praming language evolution continues in both industry and research.
Some of the current trends include constructs to support concurrent and distributed programming,
mechanisms for adding security and reliability verification to the language, extended static
checking information for control static credit safety, alternative mechanisms for modularity,
like mixing delegates, aspects, etc.
Component oriented software development, meta programming, that is programs to write
programs, increased emphasis on distribution and mobility.
Integration with databases also opens us as a developmental philosophy for languages, including
the GNU compiler collection, and recent languages, such as Python, Ruby and Quick.
Some important languages developed during this period include C-sharp and visual-basic.net
in 2001, F-sharp in 2002, Groovy, Scala, Factor in 2003, Closure in 2007, or Go in 2009.
We could also include in all these lists shell scripting.
But I won't go into details about shell scripting.
You can see HPR episode 45 if you are interested in more details about shell scripting.
Let me finish by giving you some resources for learning to program.
In the very easy category, you can have a look at the list of resources on Wikipedia.
So you should go to the page list of educational programming languages on Wikipedia.
You can also check the Python tutorial at docs.python.org slash tutorial.
This tutorial introduces the reader informally to the basic concepts and features of the
Python language and system.
It helps to have a Python interpreter handy for hands-on experience, but all examples
are self-contained, so the tutorial can be read offline as well.
If you already have some knowledge about programming, you may be interested in the book Structure
and Interpretation of Computer Programs, which is available at mitpress.mit.edu slash
sicp. This book can be downloaded for free online.
It uses the skim programming language for the examples, and there are also set of video lectures
which accompany the book. I will provide a link in the show notes.
Okay, I think this is enough for this introductory episode to programming languages.
In the next episode, we will start studying Python.
Until then, you can get in touch with me by email at garjolaatgarjola.net.
garjolaatgarjola.net. Garjola is spelled G-A-R-J-O-L-A. Talk to you soon. Bye.
You have been listening to Hacker Public Radio, or at Hacker Public Radio, those are.
We are a community podcast network that releases shows every weekday on day through Friday.
Today's show, like all our shows, was contributed by a HPR listener by yourself.
If you ever consider recording a podcast, then visit our website to find out how easy it
really is. Hacker Public Radio was founded by the digital dot pound and the
economical and computer cloud. HPR is funded by the binary revolution at binref.com.
All binref projects are crowd-responsive by linear pages.
From shared hosting to custom private clouds, go to lunarpages.com for all your hosting needs.
Unless otherwise stasis, today's show is released on the creative commons,
attribution, share a line, read those own license.
