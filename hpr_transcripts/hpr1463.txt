Episode: 1463
Title: HPR1463: Code Is a Life Sucking Abyss, Also My Story 
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1463/hpr1463.mp3
Transcribed: 2025-10-18 03:32:04

---

Yeah.
Hello, everybody. My name is SIG BLUB. SIG BLUB is in a slobble here, and I'm going to talk to you about how I wasted my life coding.
It's a play. I didn't waste my life on programming. I love programming, but there are certain things that are strange about it.
Before I explain what those things are, I want to set the stage.
I've been programming computers for a while now. I began when I was a kid. I think it was around 5th grade when I started because one of my teachers asked us if we had a computer at home.
I was the only person who said yes. I was pretty proud. I was programming small things on an Atari ST that my father picked up to do music with.
That was an Atari 1040 ST, which had many ports. He liked it because it came with Cubase, which is a music software. It worked perfectly with this synthesizer.
The Atari ST also came with a basic interpreter. That's what I got into right away.
We had no games. That's the reason I got into the basic interpreter. We had no games and no modem. I definitely wasn't aware of the Atari demo scene back then.
For me, it was all about basic. Basic being a programming language. I think it's a dance verb. Beginners all purpose symbolic instruction code or something like that. I couldn't be mistaken.
So it was all about basic for me. My father was all about music. So learning basic was up to me.
I started by typing commands I read in the basic reference manual that the Atari came with and eventually figured out how to type my first complex program as a complex of a program it could be for a little kid that is.
But it was like my first to crack. It was pretty awesome. And then after that, I met my dealer.
Soon after that, we got a couple years later. I don't know how many years later. Just a few years later. We got an IBM AT, which is a 286.
I knew that a lot of games were IBM, so I was super excited because I never really played computer games.
One of my friends had an IBM and their games looked fabulous. Fabulous.
Turn out the reason why their games looked so awesome was because they had a nice VGA card, which could display an overwhelming 256 colors at one time.
And I had a Peasley old EGA card that topped out about 16 colors per screen.
So none of the games that I got from my friend looked good with the exception of Commander Keen, which I didn't really play.
I think growing up at that crucial moment with our gameless Atari ST pretty much soured me on the whole gaming experience.
I never really gotten to games. So one day, while I was at my friend's place, I tried to talk.
I tried to start up a conversation about programming instead of the usual game talk.
And this was good because I was very fortunate to have his mother overhear me. She totally became my dealer, which is awesome.
Turned out she did programming for a living and had a whole library of books on the subject of computers and programming them.
So she warmed up to me and let me pick and choose books that I could borrow. It was awesome.
I already knew basic, so I wanted to learn about other languages.
I didn't really matter anyway because she didn't have any books about basic.
What she did have, however, was a Peter Norton book about assembly programming.
And that's what I picked up. That was the first book I borrowed from her.
And it was all about the IBM PC, which I had.
And I went through the first few chapters, which was bug using this program called Debug, which she could use to write assembly in.
And I had Debug. It was all coming together.
And so it was awesome. I taught myself assembler with it.
This book-barring relationship lasted for quite some time, and I'm totally grateful for it.
While at the same time I'm very angry because it's all a gateway material.
It's maybe lie, cheat and steal, just to give my fix for computer time.
Let's talk about the stealing. I was a kid. All right.
Hope you listeners forgive me for this.
I was with this other friend whose father did something with computers.
I didn't really know what he did with computers.
I just know he did something with computers.
When I'd hang out with this friend, we'd usually hang out in the basement.
And I'm in the basement. There were computer books.
But they had dust on them. They looked kind of used.
And even though I felt like shakes the clown, discovering booze on top of that bridge.
And a client's birthday party. It was tempting.
But I was okay. I could handle it. I knew my friend's father didn't really actually use the books.
They were just seeing their collecting dust. I didn't help.
But I didn't really send me overboard.
That is until I saw it sitting there.
Collecting dust with the books were a few floppy disks.
Labelled something like Microsoft QuickSea.
It was sea. I knew it was faster than basic and easier to do complex things and assembly.
So forgive me. I took the disks and I put them in my backpack.
I don't know how old I was, but my morals were different that day.
That back then. Later that day, I put them in my 3.5 floppy disks that I got for Christmas.
My 3.5 inch floppy drive that I got for Christmas.
And the disks came with examples.
And so I taught myself to see that way, which became very naturally.
Since I knew assembly before that.
I think seeing assembly are very close.
And if you're going to teach yourself, see, teach yourself assembly first.
That's my opinion.
And so that's the steelings of the way.
And now on to the lying.
I've told various white lies over the years to keep computer time.
I try not to these days because I have better morals.
And then my morals are a bit more relaxed.
What with skipping school and all.
So here's an example I was spending a night over a friend's house.
And I finally figured out how to fix one of my major bugs in one of my programs.
So what I did, and I won't do it again, I went to the bathroom when I tried to throw up
by sticking stuff into my throat, my finger into my throat.
So I could go home and work on my computer.
I couldn't make myself throw up, so I just pretended like I did anyway.
And they bought it, my friend, and their mother wished me well.
And I went out the door looking as sick as I could until they were out of sight.
And I had a big smile on my face.
It worked. They bought it.
And I went home instead of sleeping over.
And it worked on my computer.
So that's the lying bit.
Let's just say that's enough about me.
Now let's talk about how this is a life-sucking black hole called code.
In fancy smatchy, fancy smancy computer scientist A, fancy smancy computer scientist
will tell you that there are three main classes of machines that compute information.
There's the finite state machine that moves from state to state based off of input symbols.
There's push down automation, I'm sorry, push down automaton,
which is like a finite state machine, but with a stack that can have symbols placed on its stack
and take it away from its stack.
It's generally capable of recognizing syntax-free languages, sorry, context-free languages.
And there's the ever so talked about Turing machine that can do lots and lots of stuff
like compute Turing machine language and act like a real computer.
Well, sort of.
The Turing machine was created by Alan Turing with Halt instruction in mind.
It was created to compute proofs in such a way that if the Turing machine either halted or went on forever
that would tell you something about the nature of the problem you're trying to prove.
Take prime numbers, for example.
Mathematically, there's no proof that there's an infinite number of prime numbers.
It's just an assumption.
So if you write a program in Turing machine language that produces prime numbers one after another in succession
and see if it runs forever on this Turing machine,
if we can prove the runs forever then we've just proven that there are infinite number primes.
So it came from math, the Turing machine.
Do you see what I'm saying here?
It's not really like a general computer nowadays.
With the Turing machine you just have a program and it sits there moving its tape back and forth for a while.
And then it goes yes or no.
Modern computers aren't like that.
They have things like keyboards and either not jacks.
That's affect their internal memory, causing trups and whatnot.
They are far, far more variable in modern computers than in the Turing machine.
I think I said that right.
We've stepped away from pure math. It's no longer a math game.
It's more engineering now.
It's more now carefully considering everything at once, which is important.
If you aren't aware of everything, it's like digging a snow castle.
Only to have snow fall into your digs and then you accidentally digging into a water main.
The water main part is like debugging.
It's hard and it takes up most of your time.
And you got to fix it before your snow pants freeze.
But carefully considering everything is not the worst.
If you're like me, you're disabled and living off the government check.
And you have a lot of free time.
And you've kind of already decided to devote your life to understanding computers a long time ago.
So it's the idea of understanding computers, which is the problem.
Because it's an abyss.
There's so much to understand.
And there's so much history there.
I know it only seems like 60, 70 years of history.
Only like 60 years of history.
But there's far more.
Just there's so much information out there.
Like one cannot never stop acquiring more information about computers.
And the problem with it is I personally think the best way to understand the problems that other people have encountered with computers is to do what they did.
And the best way to understand how Windows Managers works is to write a Windows Manager.
The best way to understand how compilers work is to write a compiler.
The problem with this is it's addictive.
And soon enough you want to write everything.
And because you want to understand everything.
And it just gets deeper and deeper.
And you are slowly being hooked on that drug called programming.
It just makes you want to find deeper and deeper fixes.
Take of that first tie.
Pretty soon you're poking around the kernel.
And your partner hasn't seen you in three weeks.
Pretty soon you accidentally pee yourself.
Because you thought you could hold it just a little bit longer while you worked on that newfound bug.
And then what do you have?
What pants and a partner who may not want to see you anymore if you keep it up like this.
Now if you had a partner who understand your programming, understood your programming, that would be another story.
I'm not saying that programming is awful.
I'd love programming.
And I'm just saying that if you love it, be prepared to be prepared because it'll take you for a ride that will never end.
You're like traversing a giant tree from the root node from the top of it.
Or bottom of it, depending on how you think of a tree.
And every branch that you traverse is another program.
And you just have to write more and more and more and more to understand it.
And it will never end.
One problem exposes another problem.
And that exposes another problem.
And pretty soon you're exposing the whole damn thing.
And you understand why people don't do this in the first place.
And maybe you understand why the first problem isn't solved.
And maybe you can solve the first problem.
Who knows?
But yeah, just keep it cool and don't let programming take too much of your time if you socialize and have lives with other people.
Because other people are important.
I'm known to isolate on computers.
I isolate a lot on computers.
I'm trying not to do this because I have a partner now.
And they deserve to see me.
And so, just keep it easy.
Keep it balanced.
And enjoy programming.
Because it's a whole universe out there.
Take care everyone.
Bye-bye.
Thank you for listening.
You have been listening to Hacker Public Radio, where Hacker Public Radio does our.
We are a community podcast network that releases shows every weekday Monday through Friday.
Today's show, like all our shows, was contributed by a HPR listener like yourself.
If you ever consider recording a podcast, then visit our website to find out how easy it really is.
Hacker Public Radio was founded by the Digital Dark Pound and the Infonomicom Computer Club.
HPR is funded by the Binary Revolution at binref.com.
All binref projects are proudly sponsored by Lina Pages.
From shared hosting to custom private clouds, go to LinaPages.com for all your hosting needs.
Unless otherwise stasis, today's show is released under a creative commons,
attribution, share a life, details or license.
