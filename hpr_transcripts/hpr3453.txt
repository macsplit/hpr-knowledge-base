Episode: 3453
Title: HPR3453: Rust 101: Episode 1 - Hello, World!
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3453/hpr3453.mp3
Transcribed: 2025-10-24 23:43:55

---

This is Hacker Public Radio Episode 3453 for Wednesday, the 27th of October 2021.
Today's show is entitled, Rust 101, Episode 1 Hello World, and is part of the series
programming 101 it is hosted by Black Colonel and is about 22 minutes long and carries an explicit flag.
The summary is, in which Black Colonel introduces the cargo tool and goes into detail
on the Rust Hello World program. This episode of HPR is brought to you by archive.org.
Support universal access to all knowledge by heading over to archive.org forward slash donate.
Hello and welcome to Hacker Public Radio. My name is Black Colonel and this is
my Rust 101 series. Today I'm going to be going over how to write a Hello World program in Rust
as well as each one of the parts of the Hello World program. Now in order to get started you're going
to need something called Rust Up or actually what you really need is two programs which are cargo
which is the Rust build system as well as Rust C which is the Rust compiler both of which are
necessary to really have a development environment in Rust. And the way that you'd get these is
you would go to www.rustline.org slash tool slash install that is www.wiskeywiskey.romiouniform
Sierra Tango Dash Lima Alpha November Gulf dot Oscar Romeo Gulf slash Tango Oscar Oscar Lima Sierra
slash India November Sierra Tango Alpha Lima Lima. If you go to that URL then under the section using Rust
Up it has a bash script as one of those I don't really like them but it's a it's a cur- you curl
a bash script and then you run it through SH but what you can do is you can just run the first part
of it and redirect it into a file called installrestup.hsh or whatever you want and then you can read
the file to see what it's doing and then you can either make it executable with mod which is CH mod
plus X and then the name of the file or you can do or you can cat that file and pipe that to SH.
Either way if you run that then it'll go through a little graphical and while not graphical it'll
go through a little terminal based installer and let you customize it and all of that stuff and
as soon as that's done you're going to want to either restart a new bash session because it's
going to add something to your path or it'll tell you at the bottom you can either you can either do
that or you can add or you can source what is it I want to say it's home slash dot cargo slash
envy I want to say or something like that it'll tell you at the bottom of the installer what you can
source in order to in order to do that or you can just restart a bash shell and it should work
from there at this point you should have cargo and bash both installed oh sorry you should have
cargo and rust see installed and that's where you need to be for this so what I'm going to do is
I'm going to type in cargo that's C-A-R-G-O space N-E-W new space and then the name of the program
so for this I'm going to be doing rust 101 as the name but you can choose whatever you'd like
and then I hit return and it'll say created binary application rust 101 package and if I do
an LS in this directory there's a new directory now called rust 101 I'm going to CD into that
directory CD rust 101 and inside of it you have a file called cargo dot tumble and a directory called
SRC the cargo dot tumble file which is cargo dot tango oscar mic lemma is a configuration file
that'll say all of the dependencies that you need for the rust program as well as just various
options for when when you're building it you can kind of think of it kind of like your
configure dot i n file for auto tools that sort of thing is what's in cargo if I open it up in
I'm going to use them really quick we can do it in nano or emax if you must you can see that you
it's has a I mean it's a it's a tumble file if you know what that looks like I really do like
tumble as a as a serialization language so we have these two fields package dependencies
and inside of them you have these various elements you have name which has the name of the program
you have the version which is the version that the program is on then you have it addition now this
isn't the addition of your program it's probably going to say what mine does which is 2018 if it
doesn't say 2018 it's probably going to say 2021 because there's a new addition of rust coming
out this year well as I'm recording it it's this year it's going to come out in 2021 and there's
going to be a few changes to it but this will let the rust compiler know what version of rust you're
using can kind of think of this like C++ 11 versus C++ 19 that sort of thing underneath that you
have this a helpful comment that says that you can get more keys and their definitions at and then
it has the URL for the manifest.html and then under that you have a field called dependencies which
is blank because this doesn't actually require any dependencies so I'm going to quit out of that
and I'm going to cd into that src directory that we saw and then ls in that directory and we
have a main.rs file you can think of this a lot like your main.c file in c because this is
where all of the main stuff in your program is going to happen and then you can import various
other c files as modules or libraries into this main file so I'm going to open up this file in
your text editor of choice. I'm going to be using them and you can see it has a very short
three line hello world program already written for you which just has function main with
opening and closing parentheses and then open bracket and then print line exclamation point
and then parentheses double quote hello world and double quote and closing parentheses semi-colon
closing bracket and then that's your whole hello world program. I'm going to be going over what
each one of these elements is in order to kind of explain to you a little bit more about how this
program works. So functions which is what this is in Rust they're statically typed like everything
else. Now this the main function doesn't typically return anything you can generally
return anything that has a
so with with a function the way that it generally works is that you have your function name you have
your arguments and then you have your turn values main doesn't take any arguments if you want to
deal with command line options you're actually going to have to use a crate which we're going to
talk about in the next episode well maybe the episode after that we're going to be timing out soon
called clap Charlie Lima Alpha Papa if you want to look that up ahead of time just look up on duck
duck go or start page or whatever look it up look up clap and then rust and you should find it
I'll also put it in the show notes and then you can have have return values but the main function
doesn't have any return values the name of this function is main takes no arguments and has no
return values if we wanted it to have a return value because you can have main return a value but
it has to be a of type result which I talked a little bit about last time a result type has two
sort of values you can I it's like a unnamed boolean or a boolean with extra stuff in it you have
the okay type or you have the error type and the way you can make this return a type is that if we
add to after the closing parentheses we have fn space m a i n open parentheses close parentheses and
then we can put a space and then hyphen greater than symbol or closing triangular brace and then space
and then capital R result and then open triangle bracket so that's a less than symbol and then we
would do a closing triangle bracket no we would do an opening triangle bracket and then an opening
parentheses and then a closing parentheses and then a closing triangle bracket and this would
return a standard result of either a void type or of a error type if it erred out you can think of
this like the way you wouldn't see where you could have an int main void except for in this case
returning a void type is the the preferable option here whereas an error you can have that go
through some error processing to return an exit code or you can use the exit function which I
believe is in I know it's in the standard rust library but I believe it's in standard colon colon
ENV I'm going to talk about more what that means when I go over crates and modules later on
but for now what we can do is if we erase all of that and I'm just going to go back to the
way that the function was originally I'm going to quit out of that and go back to the
the main directory so that's where you have your cargo.tomel and your src file and if you type in
this directory cargo ca rg o space r un run and hit enter then what it's going to do is it's going to
give me errors I said oh I accidentally that's my fault I accidentally added something into the
source file so let me get rid of that what I did was I accidentally inserted a back tick in the
middle of one of the lines when I was trying to hit escape in them because I apparently don't know
how to use the text editor that I use on an everyday basis anyway so back in the main directory
we type in cargo ca rg o space r un run and hit enter and it's going to compile finish compiling
and then it'll run it and then you'll get your hello world line so this is your hello world program
so back in the source directory if I go back into main.rs that's sort of how a function works it'll
run the main function first and then it'll run any functions that are called by the main function
the thing about this that's a little bit interesting is that so we're not actually calling a
function inside of the main function print line exclamation point is not a function it's what's
called a macro and what a macro means is that it's sort of like it's almost like a lambda sort of
but not really it's it's like a more general type of function you can think of it as like a more
loose style of function so functions in Rust have to be statically type so you have to have
exactly the same amount of arguments you have to have exactly the same number of return types
and all that kind but macros are allowed to be a lot more flexible so we can it can have a
variable number of return or it can have variable number of arguments and it'll return something
utilizing function you can actually look up if I open up Firefox and I type in
Rust standard library
then I will get a result and if I'm the search bar that says all crates I type in print line
exclamation point it'll have this first result print line it has it says that it's a macro
standard colon colon print line and on the right hand side there's a part that says SRC this
is a really useful thing to know about so if you click that SRC button it'll take you to the source
code and here you will see actually how that print line function is defined so you see it says macro
rules exclamation point space print line this is sort of like your function declaration for a
function then you have an open bracket and then you have what this is is it's a pattern and result
style of sort of manipulation kind of think of this like something you would see and said with
rejects or something like that it is technically different it's like if you're familiar with
Haskell this is very similar to Haskell the way that functions are done in Haskell where it's
all done in that sort of lambda calculus like way and it's kind of honestly a pain to write
but that's sort of what this is and you can see that what it's doing is it's calling
IO underscore print that underscore by the way is because it's not a function that's normally
called by a like by the user so it's it's kind of a function that's meant for internally use only
mostly and then you see that it has that format args underscore nl and then it has the argument
so what this is basically saying is that if you have these arguments you see that has the dollar
parentheses dollar sign arg colon tt close parentheses asterisk that's saying that if you have
arguments in there then it's going to run this IO print it's going to print out all of that
arguments that have been formatted through that format args new line which means that's going to
format them kind of like a printf statement where you can have those sorts of characters in the
middle and it'll match those up with variables in like the way that you do with print line like
if you did print line percent s and then close quote or sorry print line print f open quote
percent sign s and quote and then you would have like I don't know v or I guess you would
call it num or something or some kind of not really a number because it's asking for a string but
if you had it like you could you'd have some message like msg or whatever for the message that
you would want to be put into that print f statement that's what this is doing with that format
args new line and then it also puts a new line character at the end of it so that you get an
automatic new line character with the print ln or print line macro now the other one the one
is just the two brace the two parentheses open parentheses close parentheses that's saying that if
you don't get any arguments then you can go ahead and just print the new line character and that's
exactly what happens in this if we were to mess around with a little more I'm not going to get
so much into the writing of the code yet I'm going to get more into that next time right now I just
kind of want to give you a feel for like the way that the code is written so you can sort of understand
the way that this is all being translated now inside of the parentheses after the
explanation point in the print line macro we have quote hello world end quote or hello world
estimation point end quote that this is a string literal it is a of type ampersand str like we saw
in the last time so this is a reference to a or it's a slice of a string and this is automatically
typed because that's sort of what that means is that it's going to have that value so if you ever
want something to be of that type then you can give it you can put it in double quotes and then
your off-the-races and then you got yourself an ampersand string type then you have your
closing parentheses which ends the arguments and then you have a semicolon then you have a closing
brace the semicolon ends the lines in very similar way as c and that's basically your hello world
statement right there I'm going to go I put a little bit more details into in the show notes
specifically about how about metafunction macros being like metafunctions let's see is there
anything else that I'm missing from here not really I'm going to go and go off script a little
bit and I'm actually going to because I've only been recording for only crap it's been 17 minutes
I guess I don't actually have time for this but I'm going to do it anyway I'm going to just show
you really quickly how the print line statement works with variables so I'm going to define a variable
I'm going to define a variable with a I'm going to let I know fubar equal and I'm going to do a
double quote and I'm going to do baz to end double quote and then semicolon so I define a variable
called fubar it's going to be of type ampersand str because you have the double quotes around
baz which is the value that's being assigned to it and then I'm going to delete the hello world
out of the print line statement I'm going to replace it with open bracket open curly bracket
close curly bracket and then I'm going to do after the double quote I'm going to do a comma
and then a space and then I'm going to type in fobo bar I'm going to type in fubar
that's foxtrot double oscar bravo alpha Romeo and then I'm going to save and quit out of
out of this see the back one directory to be in that root directory and then I'm going to type
in cargo run and it's going to print out baz so what's going on here is that it's replacing
it's replacing the brackets that we put in there with the value from that variable now a fun fact
is that if inside of those brackets because right now they're empty if inside those brackets I
put a colon question mark then what that'll do is that instead of running it through the default
displayer that print would normally or that format rather would want to display it as so it just
wants to take the value of the string and just print it out as a string sort of like pretty printed
this will print it out in debug mode so if I save and quit that and I go back one directory
and I run cargo run you'll see now there's a double quote around the baz because that's sort of
what it is that's what the literal thing is of it it kind of gives you more of a type
information and you can do this with all of your different variables like even ones that don't
have like a string component to them like an array or a or some kind of a weird structure that you've
created you can still print it out in debug mode which will give you a lot of information about
that structure which is very useful to know about I think that's going to be about it for this
episode next time I'm going to be starting on actually making the project that this
that I'm kind of going to be going over for this restaurant or one series it's going to be a
dice roller I'll allow what you would get like clatoon and a new world order does a lot of stuff
with dice rollers as his I'm going to be making it a little bit more fancy than just a basic
dice roller though in later episodes I'm planning on upgrading it with a rolling quote-unquote
at advantage which is something that is in the fifth edition of dungeons and dragons that means
your roll the die twice and take the better value as well as maybe possibly doing a 46 or roll
however many dice and then drop the lowest value which should be pretty simple to implement
even though I haven't done it yet so we'll find out together but that's basically all I wanted to
go over within this episode so thank you all for joining me and I hope to see you next time
you've been listening to Hacker Public Radio at hackerpublicradio.org we are a community podcast
network that releases shows every weekday Monday through Friday today's show like all our shows
was contributed by an hbr listener like yourself if you ever thought of recording a podcast
then click on our contribute link to find out how easy it really is Hacker Public Radio was
founded by the digital dog pound and the infonomican computer club and it's part of the binary
revolution at binrev.com if you have comments on today's show please email the host directly leave
a comment on the website or record a follow up episode yourself unless otherwise status
today's show is released on the create of comments attribution share a light 3.0 license
