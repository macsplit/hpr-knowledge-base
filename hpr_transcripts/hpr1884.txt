Episode: 1884
Title: HPR1884: Some more Bash tips
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1884/hpr1884.mp3
Transcribed: 2025-10-18 10:47:21

---

This is HPR Episode 1884 entitled Some More Mashedips and in part of the series Mashed
Crypting.
It is hosted by Dave Morris and in about 16 minutes long.
The summary is some information about race expansion in Mashed that you might not know.
This episode of HPR is brought to you by an honesthost.com.
Get 15% discount on all shared hosting with the offer code HPR15 that's HPR15.
It's a web hosting that's honest and fair at An Honesthost.com.
Hello everybody.
This is Dave Morris.
I've got a show today for you about Bash and I've called it Some More Bash Tips.
I did one earlier a month or so back, perhaps on similar subject today.
Today I'm going to be talking about the expansion of things within Bash.
I talked about parameter expansion back in Episode 1684 and that was all about how Bash
variables could be used and checked and edited and all sorts of stuff like that.
That seemed to be quite useful for people.
I'm hoping this one might also be.
There's many sort of expansions within Bash.
There's a whole section of the manual page about it and I'll probably cover some more of them at another stage.
But today I'm going to be talking about race expansion and I've put some extracts from the man page into the notes for reference.
I've got very short notes on the main page with some longer notes that you can get to from it.
So in race expansion, an expression which is enclosed in braces is expanded.
The expression can really be two main sorts.
It can be a list of comma separated strings or what's known as a sequence expression.
So the comma separated string option is simply a series of letters in braces.
So I've got my first example shows this.
Now just as an aside, what I've done is, in many cases, I've put the example of what you could type on the command line.
And then I followed that with what you'd get back and I indicated the returned stuff with a hyphen greater than like an arrow.
Just to make it clear that that's what it is.
So my example consists of an echo statement followed by space and then the letter C, open curly brace, a comma e comma i comma o comma u, close brace t.
So what that's saying is that the letters C and t are to be just to have interpolated between them, all of these letters.
And what you get is not just C A E I O U T, but C A T, then C E T, then C I T, then C O T, and C U T.
So there are five individual words output by the echo and each one with a different consonant in between, sorry, vowel in between.
Now if you were to do this in between quotes, often the argument to echo is quoted so that the the shell doesn't mess it up.
But in this particular case, you want the shell to get access to it.
So putting quotes around it, you just get it back in exactly the same form as you, you typed it in the first instance.
There's an example showing how putting double quotes around this string would achieve nothing other than to echo it back to you.
It doesn't, the strings you can have in this comma separate string form can be any length, it's certainly be longer than a single character.
So I've shown an example where I've used echo followed by double quoted vertical bar, followed by an open brace,
and in the words cow comma pig comma sheep close brace, then another quoted vertical bar, what you get back is the words cow pig and sheep each one enclosed in vertical bars.
I had to quote the vertical bars because they mean something to the shell, and in this particular case we're hiding them from the shell.
And the next form of brace expansion is the so-called sequence expression.
And in this case in the braces, you put what's referred to as a range.
So that would be x dot dot y where x and y represent numbers say.
So I've given an example here echo space open brace zero dot dot five close brace
and what gets returned is all the numbers zero one two three four five.
So what it's doing is simply incrementing through that range returning each value.
There's an optional third part to this sequence expression which I've shown as x dot dot y dot dot
increment I and CR, increment increment is a positive one net negative integer which indicates the size of the steps to be used between x and y.
So my example is echo space open brace zero dot dot 100 dot dot 10.
What that's saying is start at zero and then kind of to 100 but do it in steps of 10.
So what I get back is zero space 10 space 20 etc all the way up to 100.
It could also write in the braces 100 dot dot zero dot dot minus 10.
So in other words start at 100 go down to zero in steps of minus 10.
So not too surprisingly what you get back from that is 100 space 90 space 80 etc etc all the way back down to zero.
Another interesting feature of this is that if either of the values x and y my example begin with a leading zero then the leading zero is maintained to make sure that the resulting numbers are of the same width.
So if you in my example I've got open brace zero zero zero dot dot 100 dot dot 10.
And that starts counting with zero zero zero followed by zero one zero and so on all the leading zero is up to 100.
So that's quite useful interestingly as well the x and y parts can also be single characters with an optional numeric increment.
So if you were to put echo space open brace A dot dot J close brace you would get the letters A space B C D E all the way up to J.
So it's working through that range of letters in the current alphabet.
If you were to change that expression to echo space open brace A dot dot J dot dot to close brace what that saying is going steps of two letters.
So that would be a C E G I so it's missing B and D and so on.
You can also go backwards through the letters so in my next example in the curly braces it starts with Z dot dot T dot dot minus two.
So that starts starts printing out a Z space X space V space T. So what would you use this for?
Well it's often used when what you're trying to do is to specify file names which you might use in commands where you need to provide multiple file names to it.
So I've got an example where imagine there's a directory containing image files which perhaps are interspersed with other files and you want to just look at the image files with an LS command.
So you might type LS space minus L space and I've assumed that the directory is tilde slash pictures and then slash star dot curly bracket curly brace J P G comma P.
So that will return all of the it's specifically requesting all of the files which either end in JPG or PNG.
Another example is you might be wanting to grab a series of log files for a particular string but you you've got a directory containing a lot of log files where in the name of the file is the date.
And you want to restrict yourself to a certain range of days. So in my example I've got grip double quotes up arrow reset close quotes what that saying is grip for the word reset but starting at the beginning of a line then space minus capital A seven that means show me the seven lines after the line that you hit including that line.
And then the files are specified here as logs L O G S that's the directory contains log files slash star two zero one five oh nine.
So that's part of the date of after then break open brace zero one dot dot one three close brace star dot log.
So assume that the names can start with something or other.
They contain a date and I'm just interested in the dates in September the first to the 13th of September.
And so I'm I'm extracting those particular dates from the from the list of files and you notice I use zero one.
So that will maintain the zero for the the zero two zero three etcetera which will be part of the following because leading zeros will be added by whatever created the dates.
So there's a good useful for that thing we looked at earlier.
It's also useful way to generate sequences in a loop.
So you might write the bash loop for space I space in space then open brace zero dot dot 10 close brace semicolon do.
And then you'd have a statement in my case I've just got an echo echo space dollar I so bring out the value of I semicolon space done.
That's a one line loop and that will just iterate through the value zero to 10 printing them out one after the other on a separate line.
That's a you know fairly empty empty example but you get the point in that loop you could easily be generating numbers for whatever purpose you had.
That's quite a useful thing to do.
My last example is a little more complicated I was recently experimenting with the print F command which is a separate program within bash.
And it takes an argument it's for printing stuff out and it takes an usually a string argument containing percent character sequences which represent how it is to print various things out.
And so I was experimenting with this and I ended up with some statements I've shown here for it was an example.
And what I did was that there's actually three statements on the line here so it's a bit complex to read out but bear with me.
So the first statement is echo space minus n and then in quotes a greater than sign and the minus n means don't put out a new line at the end of the echo.
It's echo by default printer a new line after it's printed something.
Okay then that's followed by print F space then in quotes percent B then space then the arguments to the to the print F.
And what I've got here is double quotes slash back slash X double quote open brace 22 0 dot dot 29 close brace semicolon.
Then the final statement is echo again space and then in double quotes less than sign.
So what that's going to do is it's going to echo on the lot the output line a greater than sign just as a marker followed by whatever the print F generates.
Followed by a less than sign so the whole lot that's printed out by print F is enclosed in those marks make it clear where they are because some of the characters might not be printable.
That's the reason.
And the expression the brace expression with a range 20 dot dot 29 is actually generating the numbers 20 to 29 and but on the front of each one is putting a back slash X.
What that means is this expression is a is a hex number so and the percent B argument to print F takes a hex number as as its argument and puts out the character that corresponds to it.
So what this does is it prints out the character represented by hex 20 which is a space followed by the character represented by hex 21 which is an exclamation mark and so on and so on.
And so on and so on and so on. This is an asking for us.
So that's that was just experimenting with what this percent B does and because it's a little bit complicated but I was trying to use it in a script.
So just to show you the sort of things that you can you can do with this.
Now I thought I would add into this the fact that there is a command within bash SEQ which can do quite a lot of what the bash brace expansion stuff the sequence stuff can do and it can do a few things more.
I'm included a copy of the manual page for it in the in the notes just so in case you didn't know about it you can refer to it.
So what it does is it takes a series of numbers and treats them as floating point values.
So it it takes a format for the way in which things are to be represented.
So SEQ, the example is SEQ, space, minus F, low case F, space, then in quotes, percent 0.1 F, close quote, space, minus S followed by a quoted space, space, 0 space, 2.5, space 10.
That same is generate me the floating point numbers using the notation represented by 0.1 F that is whatever length the number needs but with one decimal place and print them out starting from 0 going in steps of 2.5 up to 10.
So that's actually quite powerful and the answer you get the result you get is a list of number 0.0, 2.5, 5.0, 7.5 and 10.0.
So there's not much else that can do that and that's quite a powerful thing.
However, unlike the race expansion stuff, it can't generate letter sequences. It's not really for the same thing.
It's the equivalent of the sequence expression in race expansion.
Right, I'm going to leave it there and come back to this subject and next time I do one of these, so I hope you found that useful.
Okay, bye.
You've been listening to Heka Public Radio at HekaPublicRadio.org.
We are a community podcast network that releases shows every weekday Monday through Friday.
Today's show, like all our shows, was contributed by an HBR listener like yourself.
If you ever thought of recording a podcast, then click on our contributing to find out how easy it really is.
Heka Public Radio was founded by the digital dog pound and the Infonomicon Computer Club and is part of the binary revolution at binrev.com.
If you have comments on today's show, please email the host directly, leave a comment on the website or record a follow-up episode yourself.
Unless otherwise status, today's show is released under Creative Commons, Attribution, Share a Life, 3.0 license.
You
