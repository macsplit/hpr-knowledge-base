Episode: 281
Title: HPR0281: Expressive Programming 6: How do you view programming: artistically, scientifically, or statically?
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0281/hpr0281.mp3
Transcribed: 2025-10-07 15:27:55

---

Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
Oop
I
Welcome to this episode of Expressive Programming,
an exploration into programming as an art.
Here I'll focus on programming, design, and development as an art form,
especially as a form of self-expression.
We'll look at open-source projects, the projects that I'm working on,
the code that others have written, and focus on how that
reflects what we feel, what we intend, and how we impact the world.
Special thanks for all episodes go to Pack of Health,
the Gradio, probably when we get this podcast off the ground,
especially enigma.
And also special thanks to HotBitchArson.
The bands will take me out at www.FatBitchArson.com
for all their wonderful, inspiring, and I apologize for
moving your creative community into the data.
So it's going to be comprised of the Cures for the Archon Non-Cali.
Now on to every day's episode of Expressive Programming,
about the last 20 years.
After my visit or rather stay in hospital, and I'm doing the best I can,
just get everything put together and hopefully record it and edit
just half a dozen at least.
Today's topic will be on computer programming as a science
versus artistic expression versus problems.
Now a lot of courses
will teach how to program.
I've noticed this a lot in a lot of the trade schools,
and in the current, I guess, flock of programmers,
especially I hate to single you out, but Python programmers,
where there is a way of doing things, a best practice,
and if you don't follow the best practice, God forbid.
Well, 10 years ago, the best practices that we look at now,
weren't the best practices then.
Many of the languages we use now worked around 10 years ago.
And still, many of the programmers I know today aren't even aware
that you can do object-oriented programming using the straight C.
Yeah, the kernel is built on object-oriented C,
and that's that objective C or a value
that's just C with an object-oriented approach.
I'll save that for a future podcast.
That's a little pet expression of mine,
and I'm going to what that means
and it tells an example of that in a future podcast.
But what I'm talking about here is the idea
of there being a way to do any given thing in programming
or to create a program a certain way,
whether that's user interface design,
whether that's algorithmic programming,
whether that's any area that you can think of
it seems nowadays with things like frameworks
that you take it to the extreme
where you think of something like browse
or some of the more lightweight or even the heavyweight PHP frameworks
or you take it to its far extreme of, say, content management system.
There will be ways that you have to do something
and ways of enforcing a standard or a coding practice.
Python does this from its very nature
and as you get into
from you like methods of programming Python,
whether it be Python 9 or Python 9C,
various other methods that people have come up with
standardizing a further restricted programming language.
They see a right and a wrong way of not only
what to create but how to create it.
To me, this is incredibly siphoning
and whereas I see the need for coding practices
as in agreeing on how indentation should work
where comments should go.
Obviously, if you're going to make a project
that's going to rely on Doxygen,
you need your comments to be able to be interpreted
so you can end up with a manual that works that way.
But to require
the use of specific algorithms and say,
this is the best and only way to do it
or require the use of a certain module
say an XML parser
and say this is the only way
or the best way to do it.
For example, floating state machines.
There are hundreds, if not thousands,
of floating state machines
that are available.
Now, to most,
would argue that the
Perl regular expression library
is probably the most advanced
and the most useful.
But yet, we don't see the Unix
POSIX regular expression getting replaced by it.
In order we see
simple string matching functions
getting replaced by it.
It's not the only way to accomplish that.
We also see
people continuing to
develop and write their own floating state machines
when it's not necessary.
A few years ago,
one would have argued that MD5
was the standard
for encrypting any content.
If you encrypted a password
using SHA1,
you would have been seen as absurd in any project.
MD5 was what we used.
That was where you stored passwords in the database.
And now we're at a time where
MD5 is almost laughable.
Not only a best practice
there are people scrambling to try to
convert their databases to use something else.
What has brought me to this is
numerous
I don't know if it's tech pundits,
but I also hear from other developers,
engineers,
programmers involved in model German development.
Which I can understand the efficiency
of model German development.
Developer flow chart outcomes the code.
But that removes any artistic
expression.
It removes the chance of making one iteration
more efficient than the other.
Where does it make gain reliability?
That's great for an embedded system
of aircraft engine.
And 20 years when aircraft engines
are running on different proportions
and different systems,
and we currently use
the code that's behind those models
will need to be rewritten.
And what happens when all the programmers
are model driven programmers?
Well,
there will be a new batch needed
or
as in the case of the Y2K bug
there will be a scramble for a bunch of old
programmers who can go back
and, in this case,
program the scene needed
to fix what's behind the model German development.
Same thing for domain-specific languages.
I think it's
awesome to develop a domain-specific language
as long as you don't get stuck in the idea that
once you come up with a way of solving a problem
that suddenly becomes the only way
of solving a problem.
I know many developers who
use the same MySQL
abstraction library that they've used
for more than a decade.
And MySQL has changed enough
that you should at least think
of rebacking your code
if not the fact that
the programming language you're writing in
is probably changed.
And that goes for whether you're using
PHP, or
PHP, or
Pearl,
or less so in Tython and Ruby as
there are much newer languages.
But I think there's
a lot of
restriction put on the idea of
re-evaluating your code
and redoing code.
A lot of people look down on
recreating the will.
Yeah, it's a will.
It's round. It does what it needs.
Use of sorry there.
Or in a more restrictive sense,
my way or the highway.
Many teachers from
computer scientists
to computer theorists
to professors
of artificial intelligence
and the value of genetic algorithms.
And the very nature of
a genetic algorithm is that it changes
itself. It grows and learns
and can modify itself.
Some of the code
for genetic algorithms started
with punch cards.
And they are without
about beautiful and gorgeous.
But go against the entire idea
of there being a right way
of one given thing.
They're both on the very idea that
they're constantly evolving,
emerging and
developing ways that are
better and improved over
what previously was done.
And again, as
with all my episodes
expressive programming,
except this time,
I'm trying to speak through
this topic.
So I can apologize
for any audio quality issues
that are resulting in this episode.
I can't speak at length
as I have for
or speak as loudly
without
serious risks of health
side effects.
But as with all my episodes
of excessive programming,
this is an attempt to get
the conversation started.
I'm going to edit
the website
at ubersheetgeagchic.com
where you'll find links
to the page
at HackerPublicRadio.
You can email me
at ubersheetgeagchic.com
and
I'd love to hear your opinions.
I'd love to get the conversation started.
What are your ideas
on computer programming
systems?
Can the scientific method be applied
to create a programming
rule set to say
this is the rule
for now until
disproven?
This is the best way to do it.
Is that an acceptable way
of doing algorithms
or problem solving?
Or
is it better to
with each project
than be synced
user interface
back-end design
and very algorithms being used?
Or is there some
does the approach you take
more that I'd say
balanced middle?
Where your back-end may
change far less often
than your user interface
or your user interface changes
less often than the back-end?
Does this change
the application versus
web
applications?
Obviously with the web
development side
technologies on the back-end
are evolving quickly
but much less so than
the technologies on the front-end
with Ajax
and XHTML2.0
XSLT
or XHTML5.0
JavaScript 2.0
numerous browsers
user interface
may evolve
faster than the back-end
but the problem with those technologies
is they need to be handled
by the back-end.
So are they now
evolving at equal speeds
or are you just hacking on
something to the back-end
but okay
now it accepts an Ajax response
instead of just
spouting back XHTML
or you spouting back
your standard XHTML
hoping JavaScript can parse it
and use XPass to get it out
is that the most efficient way
does efficiency even matter
to you anymore?
To me, efficiency is one
of the most beautiful things
it can be accomplished with programming
to make something
respond beautifully and elegantly
in as few lines of code as possible
and
it's something I always
have as a goal
it's not something I always succeed at
and definitely not the first pass
but it's always a goal
it's also a reason
that C is still
to stay
one of my
favorite programming languages
this was not the topic I originally
had
episode 6
had originally intended on
episode 6 being on
graphical user interface design
both web-based
and desktop-based
and that's what I'll be covering
in episode 7
I'll be covering
a rapid application
development environment
for Linux called
Gambus
which can be found at
www.bas.org
I'll be obviously
reviewing
grade 2 and grade 3
to the extent that I find
grade 3
useful
I'll be discussing
a few other topics as well
I'll also be including
a new segment
this will not be an open-source
or Linux new segment
this will be
an open-source
and development new segment
on what changes are happening
in the languages we use
the tools we use
the releases of those
projects
and very nature
of using open-source tools
to develop
and being an open-source
developer
I will also
hopefully be doing
number 7 with
a co-host
and I'm very excited about that
due to medical issues
that did not occur with episode 6
but that is
one of the many changes
that I've been working on
there will also be
a redesign of the website
that more closely reflux
the actual programming aspect
of expressive programming
and there will also be
highlighting more
on the 3D inches
like I said
this was originally intended for episode 6
but due to medical issues
unfortunately
that did not occur
to be honest
I'm lucky to be getting this out at all
if I do one time
that said
I will also
probably be discussing
hopefully with my co-host
what happens when real life
gets in the ways of goals
and programming
so in closing
please let's start
the discussion
send an email
visit the Hacker Public Radio page
to what everyone has to say
or of course
meet me in IRC
and until then
whatever obstacles you have to overcome
whatever roadblocks might be in your way
open up your ID
good luck
and happy hacking
I hope that you've enjoyed this episode
of expressive programming
if you'd like more information
about me, my projects, my podcast
or anything else
please feel free to visit my website
at ubersheetgeekcheck.com
if you have any questions
comments or feedback
please feel free to email me at
feedback at ubersheetgeekcheck.com
morning
I'm flaky and I suck at email
I'm also a member of the phpwomen.org community
any women involved in development
please join us there
also another wonderful community that I'm involved in
is devchicks.com
all the development principles are welcome
please come along
and lastly, I'm a proud member of both LinuxChick.com
that's
www.chickchchic.org
that's www.chicchic.org
that's www.chicchic.org
and
there you'll find opinions
and topics
anything you could want
so any women out there please
you're not alone
come join us
lastly, I'm on Identica, Twitter
and on IRC
free notes server
I add ubersheetgeek
feel free to pop in, say hi
find me in a room
PM me and a polyblocking
other than that until next time
express yourself
you
you
you
you
you
bike
.
