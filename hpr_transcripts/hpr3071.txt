Episode: 3071
Title: HPR3071: Bash snippet - quotes inside quoted strings
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3071/hpr3071.mp3
Transcribed: 2025-10-24 16:11:25

---

This is Hacker Public Radio Episode 3,071 for Monday 11 May 2020.
Today's show is entitled Bash Snippet, Quotes Inside Quoted Strings,
and is part of the series, Bash Scripting. It is hosted by Dave Morris,
and is about 13 minutes long
and carries an explicit flag. The summary is
How to add Quotes to Quoted Strings in Bash.
This episode of HPR is brought to you by An Honest Host.com.
Get 15% discount on all shared hosting with the offer code
HPR15, that's HPR15.
Better web hosting that's Honest and Fair at An Honest Host.com.
Hi everybody, this is Dave Morris. Welcome to Hacker Public Radio.
Today I am doing a quick show, which I decided to do yesterday
when I was faced with a slight problem,
found myself struggling a little bit with it. I thought,
oh, I know how to solve this, if I think,
but maybe other people fall over this just like I do,
so I'll share my solution with everyone.
The issue that I hit was that I had in Bash a Quoted String,
and I wanted to use that Quoted String in another command
where I had to enclose it in Quotes, so how you do that?
So as I said, this is probably the umpteenth time I've stumbled over this issue,
and I've solved it in the past and then forgotten how I did it.
I've always been a bit vague about how Quoted String's in Bash work,
because it's a little bit counterintuitive to my form of intuition anyway.
I thought others might have similar confusion, so here we go.
So the problem that I was encountering was in relation to Ken's show,
3052, where he was looking at locating computers on a network,
was what it was called, and he was using the endmap command.
I've used the endmap a lot for many years at work particularly,
and I was trying to make an alias in which I could put this endmap command,
where the endmap command also consisted of a pipeline piping stuff to org,
so it would format it nicer than the standard way.
Now an alias command, if you don't know, is used to store an arbitrarily complex command.
Not too complex, you'd better write a function for that.
If you want to have lots of decision making and loops and stuff,
but one line of command can be stored as an alias,
you can put it in the .bashrc file in the top level directory in your home directory,
and it gets added to every bash shell that you start up on.
I made the note here that I'm going to talk about all this stuff,
the configuration files for bash in bash tips 22, which I'm currently writing.
Only when a standard alias definition looks something like word alias,
followed by a space, then the name of the alias and I've got LA as one example here.
That's one that you normally get by default in your bashrc.
Follow that by equals, then in quotes, single quotes in this particular instance,
we've got ls, ls command, space dash capital A, lowercase l.
So capital A means show files with dots at the start,
but don't include the single and double dot files that get you tuned from directories.
The quote closes at the end there.
So LA is the alias, so typing LA is the equivalent to typing ls dash al capital A.
So how to turn this end map sequence that's in the listing here,
because it's quite long and complex.
How to turn that into an alias?
So digress a second to look at bash quoted strings.
I think bash is a little bit weird about this.
It's logical within itself, but its logic is not my logic.
And this is not the way that high level languages tend to quote and quoted strings and stuff,
but there are many ways to achieve this, I guess.
There are two main sorts quotes in bash, and I'm ignoring the back tick for the moment,
not going to cover that in this show.
So the first type is the single quote, which has the name hard quote.
You probably won't see that used much these days, but it was very much the way it was referred to
and I first started learning unix.
Anything between the quote, the literal value of the characters is preserved.
Nothing means what you think it means.
You can't put single quotes in that single quoted string.
There's no way of saying, here's a single quote which I want you to use.
In some languages you can proceed a single quote, a single quote of strings,
string with a backslash, but you can't do that in bash.
Then there are double quotes, which are called soft quotes in the old fashioned way of describing them.
And certain characters within these quotes have got special meanings.
Things like a dollar.
So you would use that to indicate the start of a variable or other type bashesms.
And backslash is another one. There are several others.
So you can put double quotes inside a double quoted string,
so long as you proceed it with a backslash.
So it acts as an escape.
If you want to put a backslash and you put two backslashes, that's sort of thing.
There's a much more comprehensive treatment of this stuff.
I didn't want to put an entire bash reference manual page into these notes.
I wanted them to be fairly short.
And there's linked to the section where you can see this in the notes.
So how can you do this stuff of having the quote in closing your string inside the string?
So say you want to, and this is a very artificial example I admit.
Say you want to generate something that is string, the actual word string one,
followed by a single quote, followed by string two.
And you want that enclosed in single quotes.
Now like I say, that is pretty artificial.
But there are a real examples where having to do that sort of thing might be the case.
And this particular show is talking about the one that I was trying to solve.
Anyway, you would do that.
I'm setting it into a variable, putting it into a variable.
So it would be x equals, the variable is called x, because save me a bit of typing.
x equals single quote, string one, closed single quote, double quote, single quote,
double quote, then single quote again, string two, closed string, single quote.
And if you echo dollar x, you get back string one, single quote, string two.
Now what was done here, and it's very confusing to look at, I will admit,
was to close string one with a closing quote, start a new string,
and enclose that in double quotes, so you can put a single quote inside it,
then append a second string in single quote string two.
Bash treats the three strings as one, so they're being concatenated,
but they have to be contiguous.
You can't put spaces in between them.
I put an apologetic footnote in here to say,
vector wire just said that this is not a very realistic example,
but I thought keeping it simple, this stage might be the best.
So you can also do this using Bash's explicit string concatenation,
where you say x plus equals, and then some string, which appends some string,
the end of what's already in x.
So I've got exactly exactly where x is set equal to string one,
and single quotes, then it's set equal to double quote to enclose single quote,
using x plus equals, then x plus equals in single quotes string two,
and then echoing that gives the same results before.
It's easier to read.
You could put those three x's on one line separated by semi-colons if you wanted to.
It might make it easier to read.
So you're thinking, well, what about double quotes?
Well, you can concatenate two double quoted strings with a single quote to string in the middle.
So if you started with x equals, double quotes string one, closed double quotes,
single quote, double quote, single quote, that's a single quoted string containing just one double quote.
Then again, going back to double quotes, double quotes, string two, double quote.
And echoing that, you get back string one, double quotes string two.
Now, you probably wouldn't want to do that.
It works, but you wouldn't want to do it.
I'll come onto that.
Why and how you could do this better now.
So using backslashes inside double quotes, you can escape a double quote character.
So you might be better to write the previous example as x equals,
double quote, string one, backslash, double quote, string two, double quote.
To my mind, that's a bit easier to read.
You get back string one, double quote, string two.
So you can use backslash to allow the embedding of the enclosing quote character in such a string.
But it only works with double quotes.
You can't do it inside a single quote.
Now, this business of backslashes is quite important because
it's the way that outside strings bash can be told to treat a particular character as itself.
So for example, if you have files that you've got spaces in their names,
which personally I try and avoid as much as possible,
I do get files in that format from elsewhere.
So I've got an example here where ls dash l is applied to a file called a space,
file space with space spaces dot org, just a simple example.
And in order to make that work, I have used a backslash before each space.
So it goes a backslash space file backslash space with backslash space spaces dot org.
And when that runs, you see the file being echoed back.
It's a zero length file.
It was just for testing purposes.
And it's actually quoted by ls by putting single quotes around the whole thing,
which is obviously the other way you can do it.
You wouldn't be typing all those backslashes I would have thought.
So here's another way in which you can do this embedding of the quote character within a quoted string, four single quotes.
So here we have x equals single quote, string one, close single quote.
Now we're outside the string backslash quote single quote that is that was telling bash put a single quote next.
Then open quote string two, close quote.
So if you echo that contents of x, you see string one quote string two.
So come out of the first string told bash to include a single quote, then gone back into another quoted string.
So given that that last piece of information, you could use the other other ways of doing things.
My alias, which I wanted to call the alias show underscore network.
So I start an open quote in map and then the in map parameters vertical bar for a pipeline orc.
Then I now need to give orc its arguments.
It's a little one line program on the same line in single quote.
So here's where I need to insert a single quote.
So the way it's done is close the single quoted string that we started earlier on.
Put in a backslash quote, then resume the single quoted string.
So we've got single quote backslash single quote single quote.
And then we've got all the the the orc program.
Then at the end, we need to also include the closing quote for the orc program.
So we need to do a single quote to close the string to bash insert a backslash quote.
And then slightly oddly put in two single quotes.
The two single quotes at the end mean that you're concatenating that single quote,
which you've given to bash the bash environment with a null single quoted string.
And that seems to be a thing that bash needs in order to to work.
I haven't experimented with this fully, but the one test I did do,
I tried declaring the ali so without the double, the two single quotes at the end.
And bash put them on.
So yeah, I think it's necessary for the bash string parser to work.
So I put an epilogue in the notes here.
There's more to be said about the subject and yes, there is quite a lot to be said.
But too much of this stuff is not healthy.
So I'm going to shut up.
All right.
That's it.
Then I hope that you found that interesting and possibly useful.
OK, then.
Bye.
You've been listening to Hacker Public Radio at HackerPublicRadio.org.
We are a community podcast network that releases shows every weekday, Monday through Friday.
Today's show, like all our shows, was contributed by an HPR listener like yourself.
If you ever thought of recording a podcast, then click on our contributing to find out how easy it really is.
Hacker Public Radio was founded by the Digital Dove Pound and the Infonomicon Computer Club,
and is part of the binary revolution at binrev.com.
If you have comments on today's show, please email the host directly, leave a comment on the website
or record a follow-up episode yourself.
Unless otherwise stated, today's show is released on the Creative Commons'
Attribution ShareLite 3.0 license.
