Episode: 1593
Title: HPR1593: Why C++?
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr1593/hpr1593.mp3
Transcribed: 2025-10-18 05:35:00

---

It's Wednesday 10th on September 2014.
This is an HDR episode 1593 entitled YC++.
And is part of the series, Programming 101.
It is hosted by Gajola and is about 12 minutes long.
Feedback can be sent to Gajola at Gajola.net or by leaving a comment on this episode.
The summary is, Introduction to the C++ Programming Language Main Features.
This episode of HDR is brought to you by Ananasthost.com.
Get 15% discount on all shared hosting with the offer code HDR15.
That's HDR15.
Better web hosting that's honest and fair at Ananasthost.com.
Hi, my name is Gajola and you are listening to a
contribution to HDR.
This is episode 4 of the Programming Language Series and this entitled YC++.
In the previous episode of this series, HDR1330, I introduced the C Programming Language.
C++ is described as a better C by its inventor, Bjerner's true strupp.
So many of the things presented in the episode about C apply also to C++.
Actually, most of C code is valid C++ and can be compiled as such.
C++ was first introduced in the late 70s and was first called C with classes.
Since C++ was designed to provide similar facilities for program organization together
with C's efficiency and flexibility for systems programming.
The class concept with derived classes and virtual functions was borrowed from the
similar programming language.
C++ supports different programming styles, procedural and imperative styles due to its closeness
to C, object orientation with classes, virtual functions and inheritance, generic programming
through templates, functional programming through function objects.
Let's have a look at these different items.
Procedural and imperative styles, the C style.
C++ has the same tools as C for imperative programming.
So there are the classical control flow mechanisms such as for and while loops, if statements, etc.
C++ supports procedural programming via functions, which are like C functions but with more strict
type checking of the arguments.
Unlike C, function arguments can be passed by reference, which is like passing a pointer
to the object, but using the same syntax as if the object itself was passed.
This allows to pass large objects without copying them as with pointers, but the programmer
can choose to declare the reference as constant so that the object can be modified inside
the function.
Object orientation, C with classes.
C++ has classes, which are composite types, that is, they can contain other objects
like C structs, but they can also have associated methods or member functions.
At first, object orientation in C++ can be seen as very similar to javas or pythons in
terms of what a class can contain and how it is used.
The main difference is that C++ uses value semantics.
In clear, when a variable of a given class is created in C++, it is a value like an
integer or a double.
In java or python, this is not the case.
In these languages, when you get, it's a reference to an object, not the object itself,
and therefore, you can't manage memory as you would want to, and the garbage collector
is needed in order to free memory when the object is not used anymore.
In C++, you can choose to have an object, which is the default behavior, and in this case,
like an integer or a double, it will be allocated on the heap or on the stack, and be
deallocated automatically when it goes out of scope, typically at the end of the block,
when a closing curly brace is found.
So there is no need for garbage collector, since no garbage is generated.
On the other hand, you can choose to use pointers to objects, and then the objects are allocated
in the free store, and the programmer is responsible for freeing the memory.
C++ offers multiple inheritance unlike java, and virtual functions like java.
C++ also offers operator overloading.
This means that arithmetic operators like class for addition or asterisk for multiplication
can be redefined for each class.
This is useful, for instance, for a metric class.
Other operators like the square brackets and the arrow operator can also be overloaded.
Generic programming templates and the STL.
Generic programming can be used in C++ thanks to templates.
Class templates are classes defined in terms of generic types.
That is, a class can contain an object of type t, which is not defined.
All code, like member functions, etc., can be written in terms of this generic type.
When a programmer wants to use this class template, she has to say which is the concrete type
that will be used instead of t.
This is very useful when algorithms are exactly the same for different data types, like integers,
14 point numbers, etc.
In languages which don't super generic programming, the same algorithm has to be rewritten for
every different type, or the programmer has to choose the better type for some definition
of better for which to write the algorithm.
In C++, there are also function templates, which are functions defined in terms of generic
types.
The mechanism behind templates generates at compile time, the code for the concrete
types, which will be as efficient as handwritten code for this type.
C++ comes with the standard template library, the STL, which provides generic containers
and generic algorithms.
These containers are containers like vectors, lists, etc., whose elements are generic,
like integers, doubles, strings, and any other type or class.
Generic algorithms are algorithms which operate on generic types, like integers, doubles,
strings, or any other type or class.
These algorithms operate on ranges inside the container, so they are the same for a vector
of ints or for a list of doubles.
These ranges are defined by iterators, which are like pointers or coordinates inside
the container.
In this way, if you have n types of containers and m different algorithms, you don't have
to write n times m versions of the code, but just n plus m.
Therefore, let's go to write and maintain.
I am a huge fan of templates.
Functional programming.
Functional programming is not just programming using functions, but rather using functions
as first class citizens.
That means being able to pass functions as arguments to other functions and return
them as results.
In C, one can achieve this by using pointers to functions, but this is risky and ugly
in terms of function signature.
In C++, we can define functions as being types, and therefore, they can be used as arguments
to and return values from other functions.
The way of creating a function type in C++, we call them function objects or functors,
is to create a class and use operator overloading.
In the same way, yes, plus can be overloaded in a matrix class.
The open, close parenthesis operator can be overloaded, and therefore, if, for example,
myFunk is an object of the class F, where the operator has been overloaded, we can use
myFunk open, close parenthesis, like a normal function code.
And therefore, now we can define functions which take or return objects of class F and implement
functional programming.
The STL uses extensively function objects in order to tune the behavior of algorithms.
For example, the STL find if algorithm returns the position of the first element in a container
for which a particular condition is true.
It takes as one of its arguments the function which will be used to test if the elements
of the container verify a given condition.
Conclusion
As far as I know, C++ offers the best trade-off between efficiency and abstraction level.
When C++ can be as efficient as C, I don't see any reason to use C for a new programming
project.
Learning C is still useful if one needs to modify existing code.
However, if one wants to use an existing C library in a new project, C++ seems a better
choice, since C++ can be linked to C library.
I still would recommend using Python or a similar language like say Ruby for simple
scripts or for cases when an interpreted language is needed.
The recent C++ 11 C++ 14 versions of the language, which is by the way an ISO standard,
have introduced many new features which make the use of C++ easier and this is giving
a sort of renaissance to the language.
Nowadays, added to its classical uses in systems programming and scientific applications,
C++ is starting to be used in mobile applications.
Okay, that's going to do it for this episode.
If you want to send me any feedback, you can get in touch with me by email at garjolaadgarjola.net.
Your Jola is spelled G-A-R-J-O-L-A.
Thanks for listening and talk to you again soon.
Bye bye.
Thank you very much for listening to C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C++ 11 C
Find on the website or record a follow-up episode yourself. On this otherwise stated, today's show is released on the creative comments,
and in the description, share a light 3.0 license.
