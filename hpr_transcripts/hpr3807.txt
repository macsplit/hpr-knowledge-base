Episode: 3807
Title: HPR3807: PeePaw builds a computer
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3807/hpr3807.mp3
Transcribed: 2025-10-25 05:41:53

---

This is Hacker Public Radio Episode 3807 for Tuesday the 7th of March 2023.
Today's show is entitled People Builds a Computer.
It is the 20th show of Brian in Ohio and is about 34 minutes long.
It carries a clean flag.
The summary is, Brian starts the process of building an 8-bit retro computer.
Hello Hacker Public Radio Brian in Ohio here.
I'm out from under my rock and I'm doing another group of shows on a project that I've become
interested in.
You might notice the title of the show is Peapot Builds a Computer and you might ask
yourself, who's Peapot?
Well, that's me and at least that's who my grandson who's two years old has started
calling me.
He calls me Peapot and I've thought I've meant a little bit into computers and electronics
and hobby stuff and I'm thinking maybe sometime in the future when he's a little older
would be fun to show him a computer that he, if he wants to, wants to build and we could
build it together.
So to get a little bit of a lead turn on this, I thought maybe I should go through this
myself and document it on HPR and as a template as some notes to myself in the future when
me and my grandson might run through this project together in real life.
So why a retro computer?
There's a couple of reasons.
The first is I think that an 8-bit computer is a computer that anybody could put together
and kind of really delve into the inner workings of a computer.
You can do it with a microcontroller too but it's being more microcontroller, having
all of its components inside of itself, it's a little bit more interesting to have all
the peripherals and everything on the outside and having to put that stuff together.
It gives you some real understanding of what's going on at a real foundational level.
So then you might ask why the Z80, I grew up using Commodore 64's which are 6502 based
but when you look at the cost of a 6502 chip now they're about $15 whereas Z80 is less
than 5 and so cheap is an important part I think having something that's inexpensive they
can do the take care of the goals that you want to meet, that's the way to go.
A 6502's and Z80's are both still available, I think the Z80's, I know they're still
making them, I don't know if they still make them in the dip packages that I'm going to
use for this project but certainly they're out there easy to get and did I say they're
cheap?
So that's the way to go.
So my plan is to, I want to build some scratch, there's certainly lots of kits out there,
there's lots of very well-done boards and tutorials online and I've looked at all those
things and I'm garnering knowledge from them, that's great but I want to build this
from scratch, I want to be able to point to this thing and say, yeah I put that here,
I did this here, I made this mistake there, things like that.
And so the real template that I'm using is a computer called the Tech 1.
The Tech 1 was introduced in the 80s at Talking Electronics magazine.
So Talking Electronics was an Australian magazine that didn't last that long 15 or so issues
and in 3 or 4 of them they described this computer, this is the 80 computer that you
can build.
Looks a little bit like a Kim 1, Kim 1 was a single board computer that was built by
MOS technologies, basically as a marketing device for their 6502 chip.
So the Tech 1 uses a Z80 and all those issues are available on the website, basically
everything that the founder of Talking Electronics's name is Colin Mitchell.
He's basically put everything that he ever has done out in the public domain and he encourages
people to use his ideas and use his stuff to build projects and learn about electronics.
It's kind of a cool idea, a guy thinking ahead about free culture long before, well
long before it was really a popular to say open source like it is now.
Another book that's out there is called Build Your Own Z80 Computer, it's 1981 book
written by Steve Ciarcia, Ciarcia, and it's available at archive.org, there's links
for all this stuff in the show notes and that books kind of a good plan, a good foundation
or a good roadmap on how to build something, a system starting from nothing.
There's things in it that aren't going to be applicable, some of the RAM, he uses dynamic
RAM and I probably won't use that although I might, and maybe I don't know, but there's
other things and there's parts that he uses that you can find that are hard to get and
you'd have to substitute.
So those are just some of the little things you have to do and as you go along you have
to figure out how you're going to do it and how other people have maybe gotten around
some of the problems.
To get started I'm going to do the most basic thing is I'm going to build a NOOP tester
which I'll explain here in a few minutes but there's a link at the Z80.info site and
it shows a picture of a NOOP tester and we're going to, I'm going to do that but I'm going
to do it not with hardware, I'm going to use software and like I said I'll explain
in a second.
So I also want the system to be expandable, I want to be able to grow and try to see
a push limit, see how far I can get with building a system like this, I want to keep the
cost down so that's always going to be in the forefront of the idea and even if it's
more difficult but a little bit less expensive maybe I'll go with a more difficult route.
And eventually my goal would be to work up to a system like the Jupiter Ace.
So Jupiter Ace was a computer that was built in the, again around the same time in the
80's, see if I can pull up the page here.
Yeah, it built in the 82, a computer that looks a little bit like the Sinclair ZX, ZX
Spectrum or ZX81, both computers that really don't have any, any knowledge of, or
I never got to use those things here being here in the United States of America.
But the Jupiter Ace, it's big difference, well there's lots of differences but one of
the main difference from a user perspective then compared to the ZX80's or 81's is that
it boots into fourth and if you haven't noticed I do like fourth as a computer language
and so whereas other systems were booting into basic the designers of the Jupiter Ace had
it boot into a fourth environment and used fourth for its main interaction with the computer.
So that's the plan.
So how to get started, to get started I'm going to build a no-op tester and do a no-op
test on a Z80 chip that I have right now and to do that I'm going to use an Arduino
mega board and some fourth to spin up the most basic Z80 system.
Now again this is not a new idea, there's a project at 8-bit force that's called a
retro shield and they have a shield for an Arduino mega that you can do basically what
I'm going to do right now.
But I don't want to use the Arduino IDE, I'm happy with fourth and I understand fourth
and I think fourth is a better way to go with the micro control right now.
So that's what I'm going to do.
But it turns out no-op test is pretty easy actually.
If you give a Z80 chip a 5 volts, a clock and the right data on the data bus it will just
happily start running through its address space doing nothing.
It's basically does no operation, no-op test.
And so that's what this episode is about actually is to get a no-op tester functioning.
But there's actually another step back from there.
Most of the no-op testers that you'll see out there use LEDs and resistors and probably
have some kind of external like a 555 timer for the clock and put those things together
to do the no-op test.
But what I propose doing is to use all of the capabilities of the Arduino Mega board
in order to not have to use any LEDs or I think, just actually my goal here is to use
an Arduino Mega, a parallel spread board, the Z80 chip and just a few wires to get the
job done to see if this chip actually still works.
And in order to do that I'm going to make a logic probe and specifically a logic probe,
a software logic probe in fourth, basically what I'm going to make is a frequency counter
and the facilities of the Arduino Mega to do that.
If you don't know what a logic probe is, there is a link in the show notes for that.
But for this episode I've actually went to an app note that's available at the microchip
website which microchip bought acquired at Atmel, which was the makers of the Atmega chips.
But they acquired all of their app notes and everything.
So there's an app note, DOC 8365 and it talks about using a AVR microcontroller as a frequency
counter and in that app note there's a section about using a gated method to do frequency
counting and so to what that means is you're going to get a whatever you're going to use
what they call an external interrupt to count how many times something cycles from high
to low and for a certain period of time and then so they use 100 milliseconds as an idea
and then if you take that how many times you counted it at 100 milliseconds you multiply
by 10 you get a frequency, pretty simple system.
And so they're in the flash 4th, at the flash 4th website there's a tutorial on counting
button presses and that's pretty helpful in designing this frequency counter with this
logic, logic probe and there's a link in the show notes for that too it just tells you
how to set up some registers on a different kind of chip, a pick chip but you know it's
with a little bit of thought you can easily set it up on an AVR chip or an old AVR chip
and at mega chip.
So this project is going to need an Arduino mega running flash 4th and Arduino mega
is the reason to use that versus the regular Arduino Uno is because of the amount of IO
the amount of pins that are available on it the Arduino mega has 4, 16 bit timers,
2, 8 bit timers it's got 50 pins that you can use as input and output so there's plenty
of IO space to interact with a Z80 chip, some of the other things you'll need to do this
project is the datasheet for the at mega 2560 link in the show notes, some jumper wires
and a Z80 add a solderless spreadboard which I should add that to the show notes here.
I'll do that add that there, solderless spreadboard, so I've done this, I've written some
4th words to solve this problem, 4th is a problem oriented language, you start with
the base dictionary and then you create words to solve the problem that we have, so the
problem that we have is I want it to be able to make software logic probe and so a logic
probe that it's very simplest will tell you you can probe inside of a digital system and see
if a pin is high whatever the high voltage level is in this case it'd be 5 volts or low which is
ground so in the or zero volts and or if the pin is pulsing if it's transitioning through those
states it's not going to give you a frequency and that's really not its point the point is hey is
their activity on that pin is there or is it just high or low and with that you can do some
diagnosis it's a troubleshooting device and that's what we're going to use it for too but we're
going to set a buying one which you can still do easily they're not that expensive we're just going
to use this Arduino mega to do those things and so in order to do that I think I've mentioned
this before the best way to look at at initially at if you're just glossing through some fourth code
which is here in the show notes is to start from the bottom the bottom most word is probably the
most is probably the word that will get you the farthest understanding what's what's going on in
this in this collection in this vocabulary and so the first the bottom most word in this
little bit of code is sample pin and so sample pin has says the line sample pin has first off it has
a little parenthesis and a couple dashes and that's a kind of a that is a fourth standard
not standards not the right word a fourth yeah I guess standard it's it's a called a stack effect
comment basically what it's what it says is that this sample pin has nothing coming in on the stack
and it leaves nothing on the stack what it's done and so what it does is it calls a word open gate
it then waits it then closes the gate and then it calls a word process data so it's this
sample pin is defined by these forwards open gate wait close gate process the data so if you
if you listen then you know that this is this is what we talked about in the frequency counter
we're going to open a gate wait for a period of time close the gate and then we're going to look at
see how many counts we got to see what frequency this pin is oscillating that or if the barring that
if there's no oscillation is it high or low so then if you look up a little bit there the first word
they see above sample pin is wait wait says a hundred milliseconds and it hasn't again no stack
effects and in flash forth although MS is a word stands for milliseconds and basically it's just
I think Arduino has this too you give it a number and it pauses for that many milliseconds doesn't
do anything just a just a delay function so in this case it's a fixed 100 milliseconds that's what
what I'm using as the wait time and then then it closes the gate so let's take a look at
open and closing of the gates those are a little bit higher up opening the gate
I guess maybe now would be the best time to just think a little bit about what's the fourth code
the the first thing to think about is constants and the constants are declared higher up in the
in the in the in the code and the first line of that has a word constant is this is this line that
says dollar sign 100 constant pin h and so these this is where I'm using a constant merely as a
labeling system for these ports that the that are defined in the in the at mega data sheet and so
if you're not if you don't really know this you all of the functionality of a microcontroller
is controlled through the manipulation of these registers and in the at mega 2560 there's a there's
a hundred there's now that hundred and that's a hex number hundred hex numbers of these mapped into
RAM and so if you look at the data sheet the what you'll see at the there's a section called
registry summary it's toward the bottom of the data sheet and it has all the registers and
some of the registers just take a full eight-bit number and some of them are broken down where each
bit in that in that eight-bit byte that is that register has causes sets up a function of some
peripheral be it the serial port the the timers which is what we're going to use here the whether or
not there's interrupts or whether or not the pin is can be used to input data or output whether
or not you're going to do pulse with modulation so in when you're using Arduino and you set up
something like digital pin x and it's as an output you're you're you're manipulating the registers
but it's but it's obviscated from you it's it's it's you're not directly unless you dig into it
you won't really know what's going on but in fourth it's all exposed to you but in that you also
need to make sure that you have to make sure that you understand what's going on because you can
make things quit functioning that you need to function but anyway so I've defined some constants
here and to use those as labels because it sure is easier to say hey I want to make a pin on port
h high easier than remembering dollar sign one or two and and then there's so there's a there's
a quite a number of these that I define as constants and they consist of the the ports that we're
going to need for this project and the the ports we're going to use are port h port h has three
registers connected to it pin h ddr h and port h they're at hex 100 hex 101 and hex 102 we're
going to use the timer counter register for which is at hex a zero a one and a eight and we're
going to use port e which is has its three registers at hex two Charlie two delta and two echo
and lastly we're going to use the external interrupt control register for pin
where is that pin that's on the e port on port e and then we're going to use there's a mask
to do some bit manipulation um I'm sorry that that yeah there's a mask to do some controlling of
that of whether of how that pin sees inputs and what it's what it should do so those constants
are defined there there's a couple variables also a compare is a number that compare is going to
be a value that we use and count is a value that we're that we're going to use and in fourth when
when you use a constant if I use it's after I've defined it if I if I type in pin h after I just
define pin h what it does is it'll put the value that pin h has in it on the stack which is a
dollar sign 100 in this case with a variable a variable because you can you can change the the
um um contents of a variable do you when you put a variables name when you call it it puts
it initially just puts where the value is stored what register it is and then you use a couple of
or other words to decide what you're going to do with that those words are the at symbol
and the exclamation signal and those stand for fetching store the at the at sign fetch fetches
the value from that register and the the exclamation point store stores a value into that variable
a couple of other four words that we're going to use for this is m set m clear and m test and those
are unique to flashforth those are to help with bit manipulation in a microcontroller like the like
the at mega 2560 we're also going to use a timer the timer we're going to use is timer 4 timer 4
has the ability to um toggle the value of um pin uh sixth on the Arduino board um higher low
in the background at a certain frequency and we're going to use that for initially as a test
function just a test to see if this logic probe is going to work and lastly we're going to use that
um e uh that external interrupt register to to manipulate pin 2 to think it is pin 2 um on the board
on the Arduino mega board we're going to use to use it as a um external interrupt uh device
uh the meat of the logic probe uh will um begins at the word uh ext4.irq it's an interrupt routine that
that when uh there's an interrupt on that pin um it's going to increase the count the value in count
by one it fetches count increases by one stores the value back into count um the the logic
probe itself is initialized with a few words um uh that are in the defining the word logic probe
and knit and what you're doing is you're setting up uh timer register 4 to um do what they call
CTC mode uh what it does is it it it runs a timer it has a compare register it just continuously
compares that number to what's in the in the timer and when the number hits the timer um count it
toggles the value that's on pin 6 and then resets the the timer counter to zero and then continues
do that it does that just in the background so what we're doing is we're setting up a timer
we're getting it to toggle this pin high and low and then we're going to do some other stuff and
this is this is where the microchips are um well we're where uh things like in Arduino or you don't
necessarily see this but it's stuff that runs in the background it's not really they're not interrupts
they're they're actually peripherals running in the background that the the the the the microprocessor
works and and queries what it needs to what when you need it to to query it uh the um the rest of
the logic probe in it is just to set up the uh the crack pins as inputs or as uh yeah inputs
and outputs and to set some uh pull up registers and then um and then it attaches that interrupt
routine to the interrupt vector table and to um to make to fire off that interrupt what it happens
so uh in the um there's some I like to find a few other words start clock and stop clock that's
that's just to start and stop timer for uh you can there's a word set frequency that allows you to
change the compare value to change the frequency of the what's happening on that pin
there's a pin high and a pin low and that basically allows us to set the value at uh port H to
higher to low um to uh to test out the the logic probe and then there's those words open gate
and close gate open gate sets the count to zero uh starts the interruptor team and then you
and then close the gate shuts off the uh shuts off the interrupt routine and then in processing the
data uh it it does a little bit of uh it reduces the count in count by one and that's a that's a
thing you need to do um just to clean up the numbers and get the to get an accurate uh reading
and then um if there is a count that means that the pin is oscillating then it's going to return the
frequency by multiplying that value by 10 and then printing it out if there's no if the account is
zero um or less uh meaning that there was no oscillations uh it basically will um um
uh interrogate pin H um and if it and then tell you if the pin is higher low and there's the
functionality of that logic probe so just a few words uh it does the difference between
um when I built this up the real the really cool thing is basically you can you can interactively
test all these things you can manipulate these registers and uh work at the at the fourth prompt
to make sure things work and understand it before you build up your vocabulary and you end up
with um to to be able to solve this problem um if you're interested in that there's more
I did some fourth episodes earlier uh fourth that are on and are doing know and then there's all kinds of
uh um information on the web on on on fourths on microcontrollers uh
so the actual test I'm doing here uh just to get this there's a picture uh it's got the Arduino
board with the one-wire hook from pin two to pin four um what you do what's happened what'll happen
is you'll uh it start the sixteen bit timer running at a hundred hertz um then we'll we'll do a
little bit bit manipulation set it higher low and then we'll sample the pin to see if it works and
so um after uploading this vocabulary and uh starting the um starting the the Arduino board uh
I put the output from the serial terminal in the show notes and so you start out with that the uh
fourth prompt which is okay and then uh a couple of brackets and a hashtag sign and ram
that's the that's the fourth prompt and the first word uh you type in is a logic probe in it
that just sets up the the timer and the and the pin and then uh you hit you type in sample pin
and then the output from that it says this frequent free equals one hundred which is a hundred
hertz is what should we expect and so it's telling us it's oscillating at a hundred hertz
and now if we stop the clock you're going to sample the pin and it's either going to come up
as low as low or high in this case it it told us that the pin is low and then we can set the pin
high by using the word pin high and sample the pin again and it says that the pin is high
and now if I put in so the the original compare value was uh 1,249 um so if I take if I
take to basically take a divide that by 10 and use it just roughly 125 the frequency should go up by
by uh ten times because we're causing the inner the interrupt that triggers ten times faster
so you should see a frequency of about a thousand and so what I did was I uh the next next thing
I did was I put 125 and I called the word set frequency which basically changes the compare value
I started the clock again and then I sampled the pin and sure enough the uh frequency that comes
out of it is one thousand so um it seems like the logic probe is working and um with that I'll uh
bring this show to a close um a little bit rambly hope but it was interesting I think with the
show notes and a little thought you can probably all figure out what I was doing here um for the next
show I uh we'll use I'll repurpose that 16-bit clock and actually use it to drive a Z80 I'll hook up
the data port to the um uh to the Arduino mega and then we'll uh set up a no op test so we'll have
we'll have power a clock and we'll give it some data and we'll use the logic probe to uh see if
there's any activity on the address bus to see if the pin is uh if the if the chip is working um
so we'll do that in the next episode we'll use this logic probe to uh to move to the next step which
will be uh an actual no op test of this chip um so if you have any questions or comments uh
feel free to leave them in the show notes if you uh like fourth or if you're doing something with
retro computers please do some episodes for us it's always interesting and um if you uh
want to get a hold of me I think my email is available there and at hpr feel free to email me um
and so this is Brian I know hi I'm signing off and I want to remind everybody that you are more than
your body
you have been listening to hacker public radio at hacker public radio does org
today's show was contributed by a hbr listener like yourself if you ever thought of recording
podcast and click on our contribute link to find out how easy it really is hosting for hbr has
been kindly provided by an onsthost.com the internet archive and rsings.net on the
sell device status today's show is released on their creative comments attribution 4.0 international
