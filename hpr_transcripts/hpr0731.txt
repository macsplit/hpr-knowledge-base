Episode: 731
Title: HPR0731: Klaatu the ubiquity and potential danger of the rm command
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr0731/hpr0731.mp3
Transcribed: 2025-10-08 01:38:30

---

You're listening to Hacker Public Radio.
Hi, my name's Quasco.
This is the Anti-RN episode.
So, you know Unix and Linux and the RM command, right?
RM is that little command.
Two letters, really small, not a big deal.
We typically learn it really early on deceptively.
So, when we're learning command line stuff, right?
LS, delisted directory, CD is to change directory.
RM is to remove a file.
It's sort of just talked about very casually.
And then you start seeing on forums and in IRC
about how dangerous the RM command really is,
which is weird, that it would be so dangerous
since we learned it like as one of the first three commands
we've ever learned on the command line.
So, RM does, of course, remove files.
And it's kind of a dangerous command
because it removes files from your computer forever.
It's freeing up the space of that data occupied.
It's gone.
There's no undo.
There's not an unremove command.
And even if there was, it wouldn't work
because the files removed, it's gone.
So, I think perhaps we might be doing ourselves
and people we're introducing to the unique way
of doing things at this service, actually,
by talking so much and using so often this RM command.
I don't believe that the RM command is all it's cracked up to be
or rather it is all it's cracked up to be,
but there's no alternative.
So, my friend, DeepGeek, who you'll know
from previous HPR episodes and currently his own geek show,
Todd Geek to me, and actually information underground.
He was, for a little while, a couple of months ago,
he had found this book called The Unix Haters Guide
to, I don't know, Hating Unix or something like that.
And it was a book quite literally,
not, I thought it was maybe a sarcastic
or an ironic title or something,
but it was actually, it was literally an anti-unix book.
It was why Unix was so horrible.
And there was a lot of disinformation in it,
written by someone who clearly didn't understand Unix.
He just didn't understand how it all worked.
Just writing this book and apparently having gotten it
published as to why Unix was just the worst operating system
you could ever have.
And there was a lot of interesting smug chapters in it
about how he had this writer had switched to Mac
because at least that didn't use Unix
because apparently that book was written pre-OS 10,
so that was kind of funny.
Actually, it was quite funny.
So, in this book, there was a little bit about RM
and how horrible it was.
And it really started bringing actual clarity to me
because I realized that I've been using RM
and I've just kind of been taking that high horse stance
of, oh, I'm going to be a real Unix guru.
And I'm going to go ahead and use RM
and I'll just mitigate my use of it.
I'll be careful with it.
And I'll make sure that I back up a lot
so that if I do make a mistake and remove a file,
well, all I have to do is go back to my backup.
That's not the way to remove files from your system.
That's a horrible way of doing it
because no matter what, if you accidentally remove a file
that you didn't want to remove, then it's gone.
There's no going back.
So in that sense, the Unix Haters guide was absolutely correct.
RM is a very dangerous command
and I'm not saying, I think the Unix Haters guide was,
but I am not saying that RM is a bad command.
I'm saying that it's not the command
that we all think it is.
We're told that RM is a good way to get rid of files
that we don't need anymore.
Well, it is.
But it's actually really a better way
of freeing up disk space,
actually removing information bits from our computer.
From a systems administrator view,
that might be a very sensible command to have
and to know about.
Because if you're administering a server, for instance,
you're not really poking around
and actively working on that machine all day.
You're not removing files left and right.
Typically, when you go in
and you're going to remove a file or something,
it's because it's the time to remove that log file
or it's that you've decided that you no longer need
the copy of that RPM that you've just installed
or that you installed last month.
So you go in and you remove it
and it's a very selective and kind of,
you know, it's a project.
It's something on your list.
It made it onto your project planner,
onto your schedule today.
I'm going to go in and remove a file
and it's something you execute with military precision.
That's not really how we work on our desktops
and laptop computers, our personal computers.
And we might be in the command line
doing all kinds of cool things,
but we're moving files around.
We're reorganizing data, we're ditching old files.
That's how we work, just like on the GUI, right?
The GUI has a safeguard against accidental
deletion of files and that's called the trash can.
Or I think on the windows side
it's called recycle bin or something.
Whatever you call it,
it's a little picture of a waste basket of some sort
and you can place your files into it.
And that has the magical effect of removing it
from your site and humans are very well known
for the phenomenon of out of sight, out of mind.
If you move a file so that it's no longer on our desktop
or no longer in our document folder or whatever,
we think it's gone.
And we're at peace.
We no longer have a vendetta against that file.
The advantage is that if we moved something to the trash can
and then the next day realized that,
well, we really didn't want to remove that file after all,
we actually wanted it.
So we can go back into the trash can and rescue that file.
Just bring it right back out, reintegrated into our user space
and it's back, nothing's lost at all.
Nothing's changed in fact.
This is a huge advantage over removing things
in the command line.
So the answer is fairly simple, right?
Instead of removing, instead of using that RIM tool,
simply use the move command, right?
Move through to some temporary holding space.
I can't get myself to do that to save my life.
And I think that one of the conventions
that we've all been trained to accept on a computer
is that there is a trash can.
And the trash can will hold all of our files
until we explicitly tell it to empty the trash.
And when we empty the trash,
the files actually really go away.
I think it might be a really good idea
to emulate this activity on the command line.
And for once in my life,
I can actually wish for a feature
and actually implement it all at the same time.
As you know, I'm not a programmer,
but this turned out to be a really simple project
and I'm doing the project on getorious.org
so that you can pull the project and use it on your own systems.
But it's really simple.
So I'll just go through it right here.
You could probably just implement it yourself.
The first thing that you would want to do
is to create a trash folder somewhere in your file system.
I do it in my home directory
and I call the trash folder dot trash.
That way it's really, really out of my sight.
I don't have to think about it ever.
So if you just make dirt till this slash dot trash,
you've got a trash can now.
If you make dirt till this slash bin,
now you've got a little binary folder
where you can put custom applications
that you're going to write, which we're about to do.
You can put these custom applications
in this little application folder
and it's a good idea to do it that way
because that way if you are reinstalling your operating system
or migrating to a new computer
that you've just bought,
you typically just grab your home directory, right?
Well, if you grab that,
then you've got your little custom applications
right there in your little bin folder
in your home directory and so they come with you.
So you'll only have to do this trash thing
once it's really kind of nice.
So the trash program itself, let's call it,
oh, I don't know, trash.
And it could be seen as a verb then.
So we could say, for instance, trash foo
and then that would send foo into the till this slash dot
trash folder.
So we'll write this shell script.
It's a very simple shell script.
It's three lines.
Four, if you include the header.
The header should be the hash or the pound symbol,
exclamation mark slash bin slash bash.
I typically try to do that header as a generic,
slash bin slash sh, but I'm pretty sure
that one of the features that we use in this shell script
is bash specific.
So I don't want to risk aliasing it or sending it
to bin slash sh when for someone bin slash sh
is linked to, I don't know, corn shell or TCSH
or C shell, whatever.
I don't think this will work in those shells.
I think this is a bash centric shell script
because that's what I know.
If you know a more generic way of doing what I do here,
let me know and we can update it and generify it
because I'm all for that.
But for now, we're going to do it
as a bash specifically a bash script.
The first line would be move in the space,
double quote, dollar sign, and then the at sign,
you know, the at symbol that you're using to email.
So it's dollar sign, at sign, and then close quote,
and then space, tilde slash dot trash.
Just for user friendliness, I go to the next line
and I do an echo, space, double quote, dollar sign, at,
space, moved to trash, close quote.
And then I go to the next line and I do an echo,
space, quote, your trash now has,
and then I do the dollar sign and a parentheses,
du, space, dash, h, space, tilde slash dot trash,
space, and then the pipe symbol, space, cut, space,
dash, f1, close parentheses of files in it, close quote,
or something like that, you can word it however you want.
And that's it, that's the shell script.
So now we need to move that shell script
over to our little custom application directory.
So you can do a move, trash, space,
tilde slash bin slash trash.
So now you've just moved that shell script over
to your binary folder in your home directory
and then you would want to chamod it
so that it can be executed.
So chamod plus x tilde slash bin slash trash.
That's an application on your system now
that you can execute from a command line.
To give yourself real flexibility, which is what you would want.
You want this command to be very easy for you to use
so that you default to it as often as possible.
You would want to add your bin folder to your path.
So that would be something like path equals dollar sign path
colon tilde slash bin.
That way when you type bin trash, your system knows
to look in your entire path,
which would be things like slash user slash bin,
slash user slash local slash bin,
slash user slash local slash games.
And then finally slash home slash,
class two slash bin.
It would know to look in all those folders
for the command called trash.
You would want to export that path so that it persists.
And now if you just open up a random terminal,
first let's make some test files.
So you might want to do a touch foo bar bass.
Okay, now you've got three files.
Now if you type in trash, foo space bar,
then you should see it should echo back to you
that foo and bar have been moved to the trash.
And then it should say that your trash now contains
four dot zero k of information
or whatever you put for the words.
So now you know exactly that the files
that you specified were moved to the dot trash folder
and that your dot trash folder currently
contains four dot zero kilobytes of information.
So the dollar sign app symbol in that shell script
simply is, it's bash I think for all the arguments.
So trash being the command and anything that follows it
or arguments says that whatever follows the command,
take those and then move them in this case,
move to the tilde slash dot trash folder, simple.
So I mean already we've got a pretty good emulation
of a trash can like system.
We can trash fold files and folders
and they will be moved to the dot trash folder.
And then if we change our mind suddenly
and realize that we didn't mean to do that,
we can go to our dot trash folder
and we can rescue those things.
We can move them back out into the file system, no worries.
To complete this sort of trash can like behavior,
we could use an empty command
because obviously if your dot trash folder starts to get
like full of stuff and like 20 gigs,
you're gonna want to empty all this stuff in there.
You could just cd into tilde slash dot trash
and then remove everything out of there.
Once again, that remove command is still kind of
making me nervous and it's not so much
the remove command itself.
It's just the human propensity to type in stuff wrong.
So you might do, you might be in the,
you might think you're in the trash folder
and you'd just say, okay, cool rm-rf dot slash asterisk.
And now you're removing everything in that folder, right?
Oh, guess what, you forgot to change directory
into the home dot trash folder, oops.
Now you're emptying your entire home folder
or whatever.
You know, disasters happen really, really easily.
So the less I use, remove the better I feel.
So I create in my dot bash rc or on some systems,
they prefer dot bash underscore profile.
I create an alias and the alias goes a little bit
something like this, empty equals double quote,
rm space dash rvf space, tilde tilde slash dot trash
slash asterisk, ampersand ampersand echo single quote.
Your trash is empty, closing, quote, close, double quote.
And now whenever I type in empty,
as long as I get a new bash session
to or source the dot bash rc file by type in empty,
then with no arguments, just empty,
then my dot, my home dot trash folder
is anything inside of that is removed recursively,
verbosely and forcefully,
meaning that everything within the folder gets deleted,
the dot trash folder itself remains,
but anything inside of it gets wiped away
off the computer, it's gone forever.
Hopefully I didn't overuse empty now,
but typically you don't really think about your trash
until you do and then you empty it and then you're happy.
Hard coding the rm command to, you know,
the home directory dot trash folder
that just really, really makes sure
that you're not screwing up and using the remove command
on the wrong folder or you're not removing,
I don't know, more than you think you want to remove.
So that level of abstraction between you
and that deadly rm command I think
is a really, really good idea.
And frankly, I don't think this is just something
for new users and for people who are new to the command line.
I think this is for anyone using the command line
on a regular basis because if you're doing that,
you're bound to use the rm command
and if you're using the rm command,
the potential for a very, very final
and horrible disaster is fairly, fairly great.
So between the empty and the trash commands,
I have a pretty good system of not having to use rm
and yet still having the satisfaction
of moving files that I don't need anymore out of my way.
It's a very reasonable system I think
and it's one that I think we would do good to support
and kind of promote frankly.
And I'm not promoting this as my own idea.
I'm sure other people have come up with this.
In fact, I know they have.
Mine is one of two projects currently on getorious.org
with the same idea.
You can find this all the shell scripts
and my full installer on getorious.org slash trashy.
T-R-A-S-H-Y had to call it trashy,
not only because it founds funny,
but also because there was already a getorious.org slash trash.
I thought, oh, well, maybe someone's already done
the trash project.
So I went over there, turns out it's from Mac OS,
it's written in Objective C, it's not going to work for us.
If you do have some Mac boxes
and you do want a command line trash system,
then you can check that out and that's kind of cool
because that actually moves it into your GUI trash.
I don't really need that level of coolness,
the command line dot trash is fine for me.
If you're really good with GUI programming and stuff
and you want to come up with something a lot more fancy
where a trash command on the command line actually
sends it to the KDE trash or to the GNOME trash.
Hey, that's really cool.
Or maybe it's something that I could even do in my shell script
that I just don't know about in which case, please let me know
and I can change it and make it even fancier, I guess.
But as it is, as it stands right now,
it creates its own trash folder and it moves it into it
and it allows you to empty that.
And it's great.
I put it on getorious.org because again,
if you're at all like me, you'll sit down at your own computer,
you'll have trash installs, you'll be using trash,
it's great, it's wonderful, it's working.
And then for whatever reason, one day you're at work
or you're at a festival or something,
you're on some other computer that you're not used to.
You need to remove a file.
The one time that you've got Rm in your power,
you type in Rm and you accidentally
wipe the whole file system off the computer accidentally.
Yeah, it's just like that one time
and that's gotta be the most disastrous time.
So I like to have trash at just a moment's note.
I can just grab it from getorious.org, I can install it
and then I'm suddenly using trash and it's perfect.
So the idea is that you can set it up quickly and easily
on any computer you're in front of
that you're actually going to be using for real.
That for me was an important thing.
So getorious.org is perfect for that.
My problem of course, and I think probably
a lot of other people's problem would be
that we've kind of trained ourselves
and we've been trained to use the Rm command.
So our fingers just kind of know Rm,
that's where they go, right?
They insist upon using the Rm command.
So for a little while, I had to alias the Rm command
for the trash command, so that when I typed in Rm,
it actually moved everything.
It actually invoked the trash command,
which of course in turn invokes the move command.
Billions of ways to do this, my main point
is to not use the Rm command.
I believe it's taught to us because there's no alternative.
So I think that if you at least come up
with some other alternative for yourself
so that you can teach the people you're teaching
not to use Rm, but to use trash
or to use some other command, move dash i to the dot kde slash shared slash dot trash
or wherever that trash is.
You know, whatever, I just encourage you to get away from the Rm command
and start using some kind of alternative.
And the reason I encourage this is because I believe
that the Unix and Linux system is great.
I think it's really powerful and I think that it gives us all the power in the world
and that that's exactly the way we all want it.
But along with that power, as the cliche goes,
it comes great responsibility.
And part of our responsibility, I think,
to create little systems that work around some of that power.
You know, that's why a lot of distributions out there will alias for you.
The CP command for actually making you do a CP dash i
so that you don't accidentally copy a file over another file
or the move for a move dash i so that you actually,
you don't accidentally move a file over a different file.
These are good ideas and then it's just kind of the,
if the responsibility of the knowledgeable user,
you know, I mean, really the system administrator, I guess,
but since so many of us are both system admin and user on our own computer,
then you have to kind of put on your system administrator hat
and you have to think about, okay, what do I need to do?
To my.bashrc file or to my tilde slash bin file
to make sure that I'm not overusing Rm
or that I'm not clobbering files when I copy or move them around.
Thank you for listening to Hack or Public Radio.
HPR is sponsored by caro.net so head on over to
C-A-R-O dot E-C for all of us in here.
