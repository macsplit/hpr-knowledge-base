Episode: 3023
Title: HPR3023: Critique My Script, Episode 1 - Qots-Crew-Gen
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr3023/hpr3023.mp3
Transcribed: 2025-10-24 15:20:05

---

This is Hacker Public Radio, Episode 3123 for Wednesday 4 March 2020.
Today's show is entitled Critique My Script, Episode 1 Coase Crew Gen. It is hosted by Carl
and is about 13 minutes long
and carries a clean flag. The summer is
discussion of using a shell script a randomly generated hen man air crew.
This episode of HPR is brought to you by An Honesthost.com.
Get 15% discount on all shared hosting with the offer code
HPR15, that's HPR15.
Better web hosting that's Honest and Fair at An Honesthost.com.
Hello HPR, this is Carl. You may remember me from
previous episodes such as HPR2915 intro by recording setup.
And that's it. That was the only other episode I've done. This is number 2.
Ken sent a email out today asking for shows and I've been meaning to do one so I thought I'd better go ahead and do it.
My only goal for this show is to make it better than that first one so I'm going to set the bar low in other words.
I think the title for this episode is going to be Critique My Script, Episode 1,
which would imply that it might be a series. I'm not sure that it will be, but I'm going to imply that.
I'm going to go over a script I did, a shell script I did for a website that I'm working on,
and I'm going to go over it. It's really simple. I'm going to go over it, sort of line by line,
and I hope to get some feedback on whether you like it or not and tips for improvement.
The background for this is that I used to play a single player board game called B17,
Queen of the Skies, made by the Avalon Hill game company back in the 80s.
One of the first things that you had to do was create your bomber and your 10 person aircrew.
I always hated that part because I always thought my aircrew, my name sounded stupid.
When the game arrived, I decided that before I even played it, I was going to create a script to generate the 10 person crew.
That's what this show is about, is the script that I wrote to do that, and you can see it.
I got a link to the website where you can see it in the show notes.
The first little section of the shell script is just four variables.
First underscore names, last underscore names, crew underscore positions, and crew underscore ranks.
These are just files that are local to where the script is executing helper files.
They're pretty self-explanatory.
A list of first names and a list of last names, which I happen to have the file names actually, surname names.
One cool thing I think about this is that I did spend a little bit of time trying to find lists of first and last names that were specific to the period.
These should be fairly common names for that period.
Then the crew positions file is just a 10 position file with the name of the crew position, and crew ranks is the same thing, a 10 line file with the various ranks.
Then the next two variables are just the length of the first name and last name file.
One thing to note here is that the one thing I learned when I wrote this script was that WC.
So if I were to just do WC minus L, and then the name of the file, let's say first names, that returns 200 and then a space, and then the name of the file again, first names dot text.
And it was bugging me that I couldn't just get 200 without the first name without the file name echoed back at me again.
And that file redirect into WC dash L, that's what that accomplishes. So if you do a WC dash L with a less than and then the name of the file first names dot text, you just get that just returns 200 without the file name.
So I can then populate the what's that process substitution to prop to populate that when first names variable, and then I do the same thing with the when last names variable.
So now I've got two variables, one with the length, the number of lines in the first names file, and the number of lines in the last names file.
So the next thing I need to do then is to randomly select a line from the first names file and a line from the last names file, put those two things together to get a full name, do that 10 times, and that's my crew.
Just a real quick aside, I think I meant to mention this at the beginning, and I don't think I did, and that's that I try to restrict my shell script to work within the confines of a busy box environment.
So if you don't, if you see me doing something that would be easily solvable in a more fully featured shell like bash or something, that's the reason I'm not doing it is I'm just trying to stay within busy box.
So back to the script, the next line is the line that I was most excited to talk about for this episode, because I think it it's a common problem that that comes up in a script and I think it's a kind of a cool and flexible solution that I'll be able to reuse.
I'm setting a variable called num pairs that I'm going to use later on in the script to iterate in a loop and generate the crew numbers or the crew names.
On the left side of the pipe is a print F and then three parameters that will be fed into awk to generate the number sets that I need.
So the first of the three parameters is the number 10, so it's basically saying, hey, I want 10 lines and each one of those lines will be a pair of numbers separated by a comma.
So I need 10 crew members with and each crew member has a first name and a last name, so I need 10 lines with a number between one and the length of the first names file and then a comma and then a number between one and the length of the last names file, then a carriage return to move to the next line and then I need 10, I need that 10 times.
So that's what that print F does.
So I'm sending to awk the number 10, the length of the first names file and then the length of the last names file and then awk when it starts it first executes that begin section.
And there's an s-rand function there, which is seeding awk's random number generator.
And from what I read, you get pretty good random numbers out of awk as long as you stay in awk, as long as you see the random number generator and get the number, you get the numbers out before you finish that process.
Because if you were to start the process again, the uniqueness of the random numbers isn't as good, I guess. So if I were to call awk 10 times, in other words, the results wouldn't be as good as if I stay in awk for the and generate all 10 numbers and then exit awk.
And I just listened to that bit back again and I said generate all 10 numbers, what I meant to say is generate all 10 sets of numbers, which is what I'm really doing here.
So we're into awk now, we've fed it three numbers, it's seeded its internal random number generator, then we start an outer loop and we've just got an eye, you know, a counter variable, essentially eye, which is incrementing, starting at one and it's incrementing each incrementing by one through each iteration of the loop.
Up until dollar sign, less than or equal to dollar sign one and the dollar sign one is that for, is that very first parameter we passed in, which was a 10.
So that's what's controlling the number of, or the 10 sets of numbers that are going to come out of this function, essentially, is the eye bit.
So the next part then is we're doing another incrementing variable called f, which corresponds to each of the two remaining fields that we passed in.
So f equals two, we so we start it to the second number that we passed in with our print F statement and we go up to nf, which is the number of fields, which happens to be three in this example.
And for, for each one of those, then we're going to generate, we're going to use ox, ran function, which returns the number between zero and one.
And you multiply that by dollar sign f, which is kind of one of the interesting parts about that is so we set f to two, we then refer to dollar sign f, which means field two that was passed in.
So that would be lend first names, the length of the first names file.
So what this little part does is basically pick a random number between zero and one, although never zero and never one, multiply it by the number of the length of our first name file, or, you know, the number of lines in our first names file and adds one.
So essentially where that little bit gives us a return or produces a random number between one and the number of lines in the first names file and then it adds a comma and then returns and then goes to the second iteration of the loop.
So the second time through that inner loop, f is now equals to three, which will correspond to the third field, which was the last names.
So now we get a number between one and the number of lines in the last names file, with again, appended by a comma, which is sort of not clean because you always end up with a comma after every number, even after the last number.
Then it adds a new line and does that 10 times.
So if we just run this in our, run this in our shell.
So I'll print, so basically print f 10 space 20 space 100 into that aqua function and hit return and what I get back is 14 comma 10 comma on the first line, 1 comma 38 comma on the second line, 18 comma 26,
6 comma 14 11 comma 81.
Yeah, so I've got, I've got, I get 10 sets, 10 lines and each line has two numbers on it separated by a comma.
So first name, last name.
And you could do this.
The cool part about this is you could do it like I also change the first number to a 20.
Now I get 20 lines of two numbers.
So I'll leave it at 20 space 20 space 100 and then I'll add a third number.
Well, really a fourth number and let's just say 400.
So now I'm passing in 20, which is saying, hey, give me 20 lines of numbers, 20 sets of numbers.
And then I've got three additional numbers I'm passing in 20, which is I want my first number to between one to be between one and 20.
And then 100, which says, you know, I want my number to be between one and 100 and then 400, you know, between one and 400 hit enter and I get 20 lines.
First line is 11 comma 75 comma 207, 6 comma 31 comma 26, 14 comma 65 comma 165.
So it's, it's real flexible and reusable, I think.
And then the rest of the script is, I think, pretty much self-explanatory.
We've got a little bit of HTML generation going on and then we go into the main for loop where we're taking those numbers sets that we generated.
And we're using cut with the comma as the delimiter to split to get a, you know, the first number from the first to the from the first number set.
And then we're, we're using said to pull the name, the name that corresponds to that line number out of the first names file.
Then we get the, we call cut again, get that second number, do the same thing with the last names file.
And then for crew position and crew rank, I'm just using another iterator one through 10.
I've got, I've already got those files set up in the correct order.
And then it generates some more HTML, HTML, which is the table.
So what you end up with is a table of crew rank crew position and then the first name last name.
Actually, now that I look at the table, it's position, then rank, then name.
And again, the, the URL will be in the show notes.
I'd be very interested to hear what you think. This has been Carl for episode number two.
You've been listening to Hacker Public Radio at Hacker Public Radio dot org.
We are a community podcast network that releases shows every weekday, Monday through Friday.
Today's show, like all our shows, was contributed by an HBR listener like yourself.
If you ever thought of recording a podcast, then click on our contributing to find out how easy it really is.
Hacker Public Radio was founded by the digital dog pound and the Infonomicon Computer Club.
And it's part of the binary revolution at binrev.com.
If you have comments on today's show, please email the host directly.
Leave a comment on the website or record a follow-up episode yourself.
Unless otherwise stated, today's show is released on the creative comments,
attribution, share light, free dot org license.
