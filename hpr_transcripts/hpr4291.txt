Episode: 4291
Title: HPR4291: AM on the Nyquist Prompt
Source: https://hub.hackerpublicradio.org/ccdn.php?filename=/eps/hpr4291/hpr4291.mp3
Transcribed: 2025-10-25 22:35:25

---

This is Hacker Public Radio Episode 4291 from Monday the 13th of January 2025.
Today's show is entitled, Am, on the Nyquist Prompt.
It is part of the series Ham Radio.
It is hosted by Lee and is about 13 minutes long.
It carries a clean flag.
The summary is, Lee experiments with Amplitude Modulation and learns a list in the process.
Hi, I'm Lee and I'm going to talk about both Am to Radio and Coding.
For me, this began at Ogcamp in October 2024, when Ken Falling gave a talk that got
me interested in Am to Radio.
They ended up bringing me back to things I'd learned and experimented with a long time ago.
My top-rated transmitter designed for Am to Radio, or at least to transmit, requires a license.
The Radio Society of Great Britain produced a manual, and reading this is a necessary
step to gaining an Am to Radio license.
I acquired the manual and started working through it.
The first section I read was fairly familiar to me, since I've been making circuits since
I was a kid and studied some electronics both theoretical and practical at high school
and later as part of an information systems degree.
It was about things like voltage, current, and ohms, law, and power and such.
While these things should be second nature, that shouldn't be taken for granted.
I remember quite clearly being interviewed to get into Queen's College in Cambridge, and
I felt to come up with some of the basic formulas relating to a battery having internal
resistance.
I guess because of the way my brain works, situation I was in had switched me into social
mode rather than technical mode, two ways of thinking I'm not very good at combining
simultaneously.
Needless to say, I didn't get into Cambridge.
So I don't take this knowledge for granted, or happily revisit it, though I did decide
to skip a little forward in the Am to Radio manual.
The first thing I came across in the manual that really got my attention was about amplitude
modulation.
This is one of the most simple ways of making a radio signal.
Radio signals being carried by electromagnetic waves, prefer to be sent as waves, or in
other words oscillating signals, rather than as plain signals which you might transmit
over an intercom.
So the simplest types of modulation work by having a carrier signal, which is a simple
waveform, and then this is modified by the second signal, which is a signal that contains
the actual message we want to send.
The two basic ways of doing this is to either make the carrier signal louder and quieter
as the message signal gets louder and quieter, or we could make the carrier signal have a
higher or lower pitch as the message signal gets louder and quieter.
These methods of modulation are known as amplitude modulation frequency modulation respectively.
What interested me was a reminder of what set of frequencies you get out when you have
a carrier wave of a fixed frequency, and then modulate it with a signal of some other
frequency or set of frequencies.
According to the maths, what happens when you multiply two sine waves is you get two cosine
waves, one having a frequency that's the difference, and one having a frequency that's
the sum of the original frequencies.
This means for amplitude modulation, the resulting waveform has an upper band, which is like
the message signal, in terms of its spectrum, but above the carrier frequency, and then
lower band, which is a reverse spectrum below the carrier frequency.
This looks like what you would get if you put paint on the right hand side of a piece
of paper, then folded it in half and unfolded it again.
Now while I do like maths, I'm an engineer at heart, and don't really believe something
until I see it demonstrated.
So at this point, I decided to concoct an experiment.
I wanted to make a sine wave, multiply it by another sine wave, and see if the result
in signal really consisted of the two frequencies in the way that matched the formula I've mentioned.
How did I do this?
It turns out that the same software I'm using to record an LED's podcast has very flexible
digital signal processing capabilities, in terms of a scripting language called Nyquist,
available through the built-in Nyquist prompt, and you can even create quite complicated
plugins in Nyquist for audio manipulation, and share them with others.
Although I've never used this aspect of audacity before, I thought I'd have a go, and soon
found out Nyquist is based on another language called Lisp.
So I'm now going to a little detail about what Lisp is.
While Lisp is a functional programming language, and it dates back to the relatively early days
of computer science, I have been acquainted with the opinion functional languages suggest
toys computer science is played with.
From time around high school, I'm going to university, someone I knew who went to another
uni to study computer science, referred me to languages like Lisp and Scheme, and I've
sort of fascinated.
I remember writing a tic-tac-toe game in Prologue at the time, which is not strictly a functional
language, but has similar properties.
The property of functional languages were things that are mutable by default, make them powerful,
in that they are not so subject to the horrors of other types of programming, where you
might write some code, but it could have all sorts of effects that you're not aware of,
rather than just doing something with some inputs and producing an output.
I've another particular commercially successful software company, with an office just across
the road from where I live, whose flagship coding framework is based on F-sharp, a functional
language that uses .net and could pass down to the same bytecode as the object orientated
C++ language C-sharp.
So no functional languages are more than a toy.
Some of you will also know that Lisp features in the EMAX.
To recap, I wanted to do some digital signal processing and signal generation, and my chosen
method was to use the Nyquist language, which is based on Lisp.
Of course, the last thing I would ever do would be to learn how to do something one lesson
at a time by reading the manual, although I'm trying to do that for the radio.
My way of learning Lisp was to try things out.
This is what I observed about Lisp.
As I said, it's a functional language, which means everything is like a flow of information
through functions from one or more inputs to a single output.
This is expressed by putting some expression in brackets.
The first token inside the bracket is generally the function being called.
It's maybe the name of predefined or user defined function, or it may just be a mathematical
symbol.
And the following tokens are the parameters to that function or operation.
And of course, brackets can be nested inside each other.
There are exceptions to this immutability, where some operation has side effects that
affect the state of the environment.
As an example, this would be setting a variable.
So when the variable is set, it becomes available to subsequent operations.
I was using the copy of Lisp that came with Nyquist IDE, which was unsourced forge,
and documented on the website of the Computer Science Department of Carnegie Mellon University.
I was doing this on the Mac, and for some Java related reason, I couldn't get the IDE
to run, so I clicked Show Package Contents and extracted the command line executable called
Nye.
Then I searched around and found the associated Lisp source libraries for Nyquist, which
the Nye program kept trying to refer to.
Hacking was a painful process.
Every time I ran a script and it came up with an error, I had to type OpenBracketX, it
closed bracket to get out.
And heaven helped me if I pressed any other keys, because it got into confusing state.
If you ever run VIM or VI without knowing the keyboard shortcuts needed to exit, you
know what I mean.
I was editing code in Sublime Text, though.
Matching brackets could be a bit hellish, but at least Sublime Text would helpfully underline
the opposite bracket to the one the cursor was on.
I realized there were different modes of this compiler called Sal, an X Lisp, which basically
had different syntax, but would do the same thing.
I was pretty sure I was using the X Lisp mode.
So I attempted to write a script that would create a sine wave mathematically, put it
into a buffer and then save it as a way far.
This took about 50 iterations since I didn't know Lisp and I didn't exactly know what
functions were available.
The Google AI-based assistant I was using to help me would often come up with code that
even if correct certainly did not match the flavor Lisp I was using or the Nyquist functions
available.
I tried different ways of building up collections of numbers.
One way was recursive and led to overflow.
The other way was to run a loop in this work, but I felt like a cheat making a functional
language do something iterative and sequential.
By the end of it, my code had turned from something that was originally nested and functional
into something very linear, and I'd given up at this point using DeFiN to define functions.
Basically I started by setting some variables to constant values with setQ, then every line
was set in a variable with the setQ command based on applying some operation to the previous
variables.
Eventually the code ran up to the point of generating my list of numbers that represented
the sine wave, but however hard I tried I could not get the file to come out.
I was a bit stuck getting the list to become an arrow which seemed to be important before
converting to a sound, but maybe that wasn't necessary.
Keywords that I read about like coerce were apparently missing from this flavor of Lisp.
When I did get to outputting a file it was nowhere to be found, and I wondered if Macos
was blocking file output in some way.
So after all this I cut my losses and went back to the Nyquist prompt in Audacity.
I had groct by that time there was already some built-in functions for generating a sine
wave called OSC or HZOSC.
My efforts to numerically define a sine wave had come to nothing and I realised they were
quite in vain anyway.
So then I went back to what I wanted to do originally which was multiply two sine waves
with different frequencies, and this was surprisingly easy, just a little one line of code in the Nyquist
prompt.
Though before I got there, an issue I had that puzzled me for some time was that I was passing
the wrong parameters to my oscillator functions that were producing ridiculously high frequencies
that could not possibly be rendered at 44 kHz sampling rate.
There's a lower information science and signal processing that to represent an analog
frequency in digital form the sampling rate has to be at least twice that frequency.
This is on my common sense if you think that a waveform has a peak and trough, so you
need at least one peak and one trough to have been sampled for the wave to be digitised
hence two samples per wavelength.
At me enough this theorem is attributed to the Swedish mathematician Harry Nyquist
and known as Nyquist theorem.
As a result of my frequency being impossible to reproduce Nyquist interpreter decided to
automatically reduce the frequencies by several orders of magnitude, so the frequencies
I was getting out were no relation to the frequencies I thought I was asking for.
When I figured this out thanks to seeing a warning in the debugger I adjusted my parameters
and the function I was calling and got my good sine waves.
Then these were multiplied, or in other words one was modulated with the other, since
so both sine waves is not really a distinction as to which one is modulating which, but if
you think of it as an AM radio signal where there is a carrier wave in the message signal
I would say the higher frequency carrier has been modulated with the lower frequency message
signal.
To find out what frequencies were in my resulting waveform I used the spectrum analyzer
in audacity.
Now the frequency peaks are not always a single line, if the size parameter is small, the
peak can be very wide and curved, if the parameters big the peak is more narrow and pointed.
If the frequency nicely snaps to peak frequencies then they can be more or less read by moving
the mouse there.
Another issue is whether the frequencies are on a linear or logarithmic scale, it makes
more sense to be logarithmic, since as the pitch we perceive increases by equal steps
the frequency increases exponentially.
At the end of all this what I had done was created two tones and multiplied them and plotted
the spectrum.
The original tones being one kilohertz and half a kilohertz.
A resulting spectrum showed a peak at half a kilohertz which was a difference and one
that one and half kilohertz the sum.
The next bit in the AM to radio manual mentions that in practice if one of these tones is the
carrier frequency of one of them is the signal then the carrier should not be modulated all
the way down to zero or the way up to maximum.
The reason is this avoids distortion and clipping so the quality is better when received.
It's also more power efficient so the transmission can travel further given the transmitter
as a limited power output.
Well overall it was a successful experiment.
My first step towards studying for a foundation license which I would need to actually be
legally permitted to transmit using the low cost handsets I've already acquired rather
than just listening.
In the process I spent several hours learning how to write a program in LISP even though
at the end of the day one line of code suffice.
The next time I want to write LISP I think I'll just install the SBCL common LISP compiler
start with some simple functional source code examples and go from there.
Anyway, perhaps one day we'll talk on the airwaves.
That's all for now.
Thanks for listening and bye.
You have been listening to Hacker Public Radio at Hacker Public Radio does work.
Today's show was contributed by a HBR LISP like yourself.
If you ever thought of recording podcasts you click on our contribute link to find out
how easy it really is.
The hosting for HBR has been kindly provided by an honesthost.com, the internet archive
and our syncs.net.
On this advice status today's show is released under Creative Commons, Attribution 4.0 International
License.
